[{"content":"This series of posts is intended to be a set of reasons I love using the Rust programming language. This isn\u0026rsquo;t a statement to say that you should use it, but hopefully it can bring some light on the differences between languages such as C++/C# and Rust, and show what Rust could bring to the table.\nEach post will just be a self-contained entry about a single feature of Rust that I appreciate, so feel free to flick through as needed.\n","permalink":"https://forgottenmaster.github.io/posts/rust/whyrust/introduction/","summary":"This series of posts is intended to be a set of reasons I love using the Rust programming language. This isn\u0026rsquo;t a statement to say that you should use it, but hopefully it can bring some light on the differences between languages such as C++/C# and Rust, and show what Rust could bring to the table.\nEach post will just be a self-contained entry about a single feature of Rust that I appreciate, so feel free to flick through as needed.","title":"Introduction"},{"content":"There isn\u0026rsquo;t too much to say for what a function actually is, since being a programmer, we use them every day. However for completeness I\u0026rsquo;ll include a post here.\nFor our purposes it will help to think of a function as a black box, that takes one or more inputs and returns an output. We can then chain these functions together by taking the output of function 1, and passing it to the next function and so on.\nThe advantage of thinking of them as a chain like this rather than a stack as programmers are used to thinking of them, is that this chain will easily map to the concept of the forward pass of a neural network later on.\nAssuming the existence of the following two functions, each of which takes a single parameter:\n$$ f(x) = x^2 $$ $$ g(x) = x + 10 $$\nWe can code these functions as below, along with how they\u0026rsquo;re chained together to act as one big composite function that takes input into the first, and extracts output from the last:\nlet f = |x: f64| x * x; let g = |x: f64| x + 10.0; let input = 42.0; // input into the first function in the chain let intermediate = f(input); // after invoking function \u0026#34;f\u0026#34;, the output is an intermediate result let output = g(intermediate); // to get the final input, we can pass this intermediate result through \u0026#34;g\u0026#34;  A diagram showing function omposition would look something like this, where the chain of two functions results in the same as running through a single function that is the composite of the two\n","permalink":"https://forgottenmaster.github.io/posts/machinelearning/deeplearningfromscratch/chapter1/functions/","summary":"There isn\u0026rsquo;t too much to say for what a function actually is, since being a programmer, we use them every day. However for completeness I\u0026rsquo;ll include a post here.\nFor our purposes it will help to think of a function as a black box, that takes one or more inputs and returns an output. We can then chain these functions together by taking the output of function 1, and passing it to the next function and so on.","title":"Functions"},{"content":"This series of posts will be my notes from the following book \nThe main reason for this series of posts will be to allow me to create notes in my own words in order to understand the concepts being taught in this book.\nOne thing to note is that any code snippets I include in these posts will be in Rust, rather than Python. I will be using the Rust crate ndarray as my data structure, in lieu of numpy\u0026rsquo;s ndarray.\n","permalink":"https://forgottenmaster.github.io/posts/machinelearning/deeplearningfromscratch/introduction/","summary":"This series of posts will be my notes from the following book \nThe main reason for this series of posts will be to allow me to create notes in my own words in order to understand the concepts being taught in this book.\nOne thing to note is that any code snippets I include in these posts will be in Rust, rather than Python. I will be using the Rust crate ndarray as my data structure, in lieu of numpy\u0026rsquo;s ndarray.","title":"Introduction"},{"content":"C Style Enums In C#, C++, and a lot of other popular programming languages, we have access to a type called an \u0026ldquo;enumeration\u0026rdquo; (or enum for short). This is simply a type safe collection of named constant values.\nFor example in C++, making an enum whose variants represent a set of allowed colors for a hypothetical UI framework could be written as (with the values of the variants explicitly typed out for transparency):\nenum Color { Red = 1, Green = 2, Blue = 3 }; A function can then go ahead and accept a \u0026ldquo;Color\u0026rdquo; and the user will be able to pass only the named colors. Except that in C++, this is not true. Nothing stops the caller from casting an arbitrary integer as a \u0026ldquo;Color\u0026rdquo;. For example calling a SetColor function that takes a Color, the caller can do:\nwidget.SetColor(static_cast\u0026lt;Color\u0026gt;(10)); // what even is color with value 10???. It hasn\u0026#39;t been defined so likely won\u0026#39;t be correctly handled.  This is not desired as SetColor can\u0026rsquo;t assume that the given Color is only one that was specified in the enumeration. If someone can arbitrarily cast an integer to Color, what is the function supposed to do with it?.\nIn Rust, we can have value type enums the same way:\nenum Color { Red = 1, Green = 2, Blue = 3 } And casting such an enum value into an integer is totally fine, the following snippet will print \u0026ldquo;Selected color is: 3\u0026rdquo;:\n// enum variant to integral value is safely supported because it\u0026#39;s a total function - all enum variants in this style of enumeration // can be cast to the respective integer value. println!(\u0026#34;Selected color is: {}\u0026#34;, Color::Blue as u8); This is totally fine and allowed by Rust because all variants of this C-style enumeration can be casted safely to an integer. We say it\u0026rsquo;s infallible\nHowever, casting an integer to an enumeration type is not infallible because not all possible integral values have a variant in the enumeration, we can\u0026rsquo;t do the following - it simply does not compile:\n// does not compile as integral to enum conversion is not implemented since it can fail for certain values of integer. let int_as_color = 10 as Blue; Rust is a safe and cautious language and the compiler will just not allow operations that could fail, therefore converting from enum to integral isn\u0026rsquo;t supported by default, however the enum creator can implement the TryFromtrait for any integral types.\nHowever this is boilerplate that\u0026rsquo;s already been done and available in a crate. Therefore to allow for C-style enums in Rust with safe conversions in both directions, it\u0026rsquo;s best to use https://crates.io/crates/num_enum\nTuple Enums In C++, the above is all you get, loosely typed integers that aren\u0026rsquo;t even that safe. With Rust, enums become more powerful with the ability to store different data inside of each variant.\nThese are similar to an algebraic data type such as Haskell has. It could be thought of similar to a union in C++ in that an element of the enum type takes up the amount of space required for the biggest variant (allowing it to store in an array), but strongly typed so you can\u0026rsquo;t access data you shouldn\u0026rsquo;t.\nAs an example, suppose we want to have an \u0026ldquo;Angle\u0026rdquo; enumeration. An angle could be stored in either Degrees or Radians, but both are stored as floats. In this case the tuple enum would look as follows:\nenum Angle { Degrees(f32), Radians(f32) } In both of these variants, we store an f32, but behind the scenes each instance of Angle is tagged with its discriminant (Degrees or Radians) and the only way to access the data inside is through pattern matching. This means we literally can\u0026rsquo;t access data that we shouldn\u0026rsquo;t for the variant we have. An example of implementing the Intotrait for this would be:\nimpl Into\u0026lt;f32\u0026gt; for Angle { fn into(self) -\u0026gt; f32 { match self { Self::Degrees(val) =\u0026gt; val, Self::Radians(val) =\u0026gt; val } } } An example of an enumeration with differing types could be a Color, where we can choose between different color formats:\nenum Color { RGBF32(f32, f32, f32), RGBAF32(f32, f32, f32, f32), RGBU8(u8, u8, u8), RGBAU8(u8, u8, u8, u8) } That is, we can choose between colors with RGB or RGBA components, and can choose the type of the components we\u0026rsquo;re storing. However because this is essentially a strongly typed union, and Rust requires all types to have a defined size to be stored, the largest size would still be picked, in this case each Color would be 16 bytes large (corresponding to the size of RGBAF32 which is largest).\nPattern matching works the exact same way. For example, a method on Color which can return whether the color supports transparency could be written as follows:\nimpl Color { fn supports_transparency(\u0026amp;self) -\u0026gt; bool { match self { Self::RGBF32(..) =\u0026gt; false, Self::RGBAF32(..) =\u0026gt; true, Self::RGBU8(..) =\u0026gt; false, Self::RGBAU8(..) =\u0026gt; true } } } Named Field Enums A variant in an enum can use the tuple syntax for defining the types it contains, and pattern matching as described above, however we can also store values associated with an enum variant by name in a record/struct like syntax. We can freely mix and match these on a per-variant basis. For example an enumeration which represents an Error. We might support storing an ErrorMessage, ErrorCode, or both. This might look as follows:\nenum Error { Message(String), Code(i32), Both { message: String, code: i32 } } When pattern matching on tuple types, we need to use the tuple patterns. When matching on record types, we need to use that syntax. An example of a function to try to get an error code from an Error would be:\nimpl Error { fn try_get_code(\u0026amp;self) -\u0026gt; Option\u0026lt;i32\u0026gt; { match self { Self::Message(..) =\u0026gt; None, Self::Code(c) =\u0026gt; Some(*c), Self::Both{code: c, ..} =\u0026gt; Some(*c) } } } Empty Enums!? Empty enums can\u0026rsquo;t be constructed. This may sound kind of pointless, what does\nenum Void { } Even mean if it can\u0026rsquo;t be constructed?\nAs it turns out this can be very useful for statically proving that we can\u0026rsquo;t ever take a particular branch of code in some cases, and is sometimes seen in generic code.\nFor example, in Rust we have the Result type which has two type parameters. One is the success type, and one is the error type. Say that a trait requires a return type of Result\u0026lt;SuccessType, ErrorType\u0026gt; from a function\ntrait TryOperation { type SuccessType; type ErrorType; fn try_operation(\u0026amp;mut self) -\u0026gt; Result\u0026lt;Self::SuccessType, Self::ErrorType\u0026gt; } In order to implement such a trait, we must provide an ErrorType to satisfy the signature of the trait, but for an infallible operation which is guaranteed to not fail, what do we choose for an ErrorType?. Any type is as good as any other type if we never need to construct it and we never return it:\nstruct InfallibleOperation { } impl TryOperation for InfallibleOperation { type SuccessType = (); // Unit type is like \u0026#34;void\u0026#34; in other languages, it\u0026#39;s a type we can use when we don\u0026#39;t need to return any information.  type ErrorType = ???; // What do we put here if this operation never fails?  fn try_operation(\u0026amp;mut self) -\u0026gt; Result\u0026lt;Self::SuccessType, Self::ErrorType\u0026gt; { println!(\u0026#34;Hello, World!\u0026#34;); } } The implementation of this function simply prints to the console and never fails, we\u0026rsquo;re \u0026ldquo;trying\u0026rdquo; to perform the operation but it will always succeed. It turns out in these cases we can communicate this at the type level to the caller by using the empty enum as the ErrorType (e.g. Void). If the caller sees that the signature for this is:\nfn try_operation(\u0026amp;mut self) -\u0026gt; Result\u0026lt;(), Void\u0026gt; Then they can easily see that the error case can never possibly happen (because an instance of Void physically cannot be constructed). In this case, the caller knows it\u0026rsquo;s safe to not even handle the possibility of error as this is ensured by the compiler in the types.\n","permalink":"https://forgottenmaster.github.io/posts/rust/whyrust/enums/","summary":"C Style Enums In C#, C++, and a lot of other popular programming languages, we have access to a type called an \u0026ldquo;enumeration\u0026rdquo; (or enum for short). This is simply a type safe collection of named constant values.\nFor example in C++, making an enum whose variants represent a set of allowed colors for a hypothetical UI framework could be written as (with the values of the variants explicitly typed out for transparency):","title":"Enums"},{"content":"Maths The derivative of a function is the rate at which the output changes with respect to a change in the input at a specific value for the input. This last part is important as the derivative of a function is essentially the gradient, or tangent of the graph of that function at a specific point which can of course change depending on where you are on the number line.\nThe formula for calculating the derivative of a given function \u0026ldquo;f\u0026rdquo; with respect to it\u0026rsquo;s input parameter \u0026ldquo;x\u0026rdquo;, at a given value of x which we call \u0026ldquo;a\u0026rdquo; here, can be written as:\n$$ \\frac{\\partial f}{\\partial x}(a) = \\lim_{\\Delta \\to 0} \\frac{f(a + \\Delta) - f(a - \\Delta)}{2 \\times \\Delta} $$\nLet\u0026rsquo;s break this down a little.\nWe\u0026rsquo;ll take the left hand side of the formula first, that is \\( \\frac{\\partial f}{\\partial x}(a) \\) which is the partial derivative of f with respect to x, at the given value of a. If we wanted to take another partial derivative of f, for example if the function took multiple parameters, the parameter we\u0026rsquo;re taking the partial derivative with respect to will appear as the denominator. For example, in a function such as:\n$$ f(x, y, z) = x + y + z $$\nThen the partial derivatives could be written as: \\( \\frac{\\partial f}{\\partial x} \\), \\( \\frac{\\partial f}{\\partial y} \\), and \\( \\frac{\\partial f}{\\partial z} \\)\nWhat\u0026rsquo;s a limit?\nThe first symbol in the right hand side is this \\( \\lim_{\\Delta \\to 0} \\) which means \u0026ldquo;as \\(\\Delta\\) approaches 0\u0026rdquo;. Limits are a way of talking about the way the function reacts to bringing certain parameters closer to a given limit. Essentially, the closer the parameter is to the limit, the more accurate the approximation is. In our case we talk about the function being as \\(\\Delta\\) approaches 0, the right hand side becomes more accurately the correct value for the derivative.\nOf course, \\(\\Delta\\) can never be 0, as this would result in a divide by zero operation which is undefined, but we can get arbitrarily close.\nWhat\u0026rsquo;s delta?\nThe symbol \\(\\Delta\\) is the greek symbol \u0026ldquo;Delta\u0026rdquo; which we use here to mean a change. Since to calculate the derivative we\u0026rsquo;re applying a small change to the value, and measuring how the output is affected by this small change.\nHow is the derivative calculated?\nThe rest of the right hand side is simply calculating the actual derivative at the value a, with the given \\(\\Delta\\) value. For a pretty close approximation of the true derivative, we can choose a very small value of delta, for example 0.001. We first add the small value to the value at which we\u0026rsquo;re calculating the derivative, this is the \\( f(a + \\Delta) \\)\nThis gives us the output of the function at a point ever so slightly in front of the test value (a). In order to measure a rate of change, two samples are required. We could have simply applied the function to a itself, however in order to account for asymmetry in the graph, we can get a better test by applying the function to the value located slightly behind the test value, this is \\( f(a - \\Delta) \\).\nFinally we take the difference of these two sample points, that is the difference in their outputs. This gives us the difference in the function output \\( f(a + \\Delta) - f(a - \\Delta) \\).\nIn order to get the gradient, once we have the change in the output of the function, we must divide by the change in the input. Since we both added and subtracted \\( \\Delta \\) to get our sample input points, the range (change in input) is \\( 2 \\times \\Delta \\)\n Code We can code up a function that can calculate the derivative of another function at a given input value, and given the value of the small delta we\u0026rsquo;re applying.\nThe function we write here will take a float in and output a float for simplicity. We could of course use generics to allow this to work for various types. With floats being the data type used, it would look as follows\nfn derivative(f: impl Fn(f64) -\u0026gt; f64, a: f64, delta: f64) -\u0026gt; f64 { let front_result = f(a + delta); let back_result = f(a - delta); let input_change = delta * 2.0; let output_change = front_result - back_result; output_change / input_change } An example call of finding the derivative of a function:\n$$ f(x) = x^2 $$\nat the input value 42 might look as follows:\nlet f = |x| x * x; let a = 42.0; let delta = 0.001; derivative(f, a, delta)  Diagram A derivative of a function being the rate of change of the output with change in the input can be visualised by the following diagram. This diagram shows a function f, which maps \u0026ldquo;x\u0026rdquo; to \u0026ldquo;y\u0026rdquo;, and shows a change in the input (dx) producing a change in the output (dy). The ratio of \\( \\frac{dy}{dx} \\) gives us the derivative\n","permalink":"https://forgottenmaster.github.io/posts/machinelearning/deeplearningfromscratch/chapter1/derivatives/","summary":"Maths The derivative of a function is the rate at which the output changes with respect to a change in the input at a specific value for the input. This last part is important as the derivative of a function is essentially the gradient, or tangent of the graph of that function at a specific point which can of course change depending on where you are on the number line.","title":"Derivatives"},{"content":"The chain rule allows us to determine the derivative of a composite function as a product of the derivatives of each of the individual functions.\nThe reason this is a product is because, say you had a function \u0026ldquo;f\u0026rdquo; which has a derivative of 3 at a particular value of x. That means, when you increase the input by 1, the output increases by 3.\nThen say you have a second function \u0026ldquo;g\u0026rdquo; which has a derivative of 5 at the value output by \u0026ldquo;f\u0026rdquo; for x. This again means that when you increase the input by 1, then the output increases proportionally, this time by 5.\nHowever, the compound function \\( g \\circ f \\) will chain these two together in such a way that increasing the input to f increases the output of f by 3, and because they were chained, this is the same as increasing the input to g by 3.\nSince the gradient of g is 5 meaning that the output change is 5 times the change of the input, then raising the input to that function by 3 must result in a raise of the output by 15.\nSince derivatives are calculated as the gradient at a particular value, we need to know the inputs and outputs of both functions in order to calculate the partial derivatives.\nOnce we have these, we can just multiply them together.\nThe formula for the chain rule in this situation will be:\n$$ (g \\circ f)'(x) = g'(f(x)) \\times f'(x) $$\nThat is, calculating the rate of change (gradient) of the initial function f at the given value of x. After this, calculating the gradient of the second function, g, at the value output by f.\nTherefore in order to calculate these compound derivatives, we need to run two passes.\nThe first pass, called the forward pass, is where we simply are obtaining the input and output values for all functions involved. The second pass, called the backward pass, is where we use the inputs and outputs of the functions in order to calculate their gradients at that point. The final step is then just to multiply together to get the gradient of the composite function.\nThis two-pass sequence can be visualised with the following diagram. In it, we have three functions and an x value that\u0026rsquo;s passed in. we run the x value through the functions in order to get \\( f(x) \\), then \\( g(f(x)) \\), and finally \\( h(g(f(x))) \\).\nThe dashed lines represents the backward pass where we take the calculated values to determine the derivatives of f, g, and h at the appropriate input values.\n We can code up the calculation of the derivative of such a chain of functions as displayed in the diagram. For this section of code, we\u0026rsquo;ll assume the existence of a helper function called \u0026ldquo;derivative\u0026rdquo; which, given a function and a value at which the calculate the derivative, will approximate the derivative using the logic described in the previous post.\n// forward pass, calculating all inputs/outputs let x = 42.0; // initial input let f_of_x = f(x); // output from f (also input to g) let g_of_f_of_x = g(f_of_x); // output from g (also input to h) let h_of_g_of_f_of_x = h(g_of_f_of_x); output from h which is the final output // backward pass, calculating the derivatives of the functions at the calculated inputs let deriv_h = derivative(h, g_of_f_of_x); // calculate the derivative of h at the value that was output from g let deriv_g = derivative(g, f_of_x); // calculate derivative of g at the value that was output from f let deriv_f = derivative(f, x); // calculate derivative of f at the value of x  // multiply together to get the final rate of change of the output with change to x deriv_h * deriv_g * deriv_f ","permalink":"https://forgottenmaster.github.io/posts/machinelearning/deeplearningfromscratch/chapter1/chainrule/","summary":"The chain rule allows us to determine the derivative of a composite function as a product of the derivatives of each of the individual functions.\nThe reason this is a product is because, say you had a function \u0026ldquo;f\u0026rdquo; which has a derivative of 3 at a particular value of x. That means, when you increase the input by 1, the output increases by 3.\nThen say you have a second function \u0026ldquo;g\u0026rdquo; which has a derivative of 5 at the value output by \u0026ldquo;f\u0026rdquo; for x.","title":"Chain Rule"},{"content":"So far, we\u0026rsquo;ve learned how to chain functions together, and how to calculate the derivative of a function at a specific input value. We\u0026rsquo;ve also learned how to apply the chain rule when we are chaining multiple functions together. However, how do we calculate the derivative of a function, or chain of functions when a function has multiple inputs?.\nAs it turns out, we can calculate the derivative in the same way!, we just need to, in the case where there are multiple inputs, calculate the partial derivative with respect to the given parameter.\nLets start off with a single function, one that takes two inputs and returns a single output\nIn such a function, the change in the output can be affected by a change in either input (x or y). Because of this, calculating the derivative with respect to x at a given value might result in a different value to what is given when calculating the derivative for input y. These are the partial derivatives of the function, where each partial derivative is how the output changes with a given change of the input (while keeping the other inputs constant).\nThe formulas for these partial derivatives can be given as:\n$$ \\frac {\\partial f} {\\partial x} = \\lim_{\\Delta \\to 0} \\frac {f(x + \\Delta, y) - f(x - \\Delta, y)} {2 \\times \\Delta} $$ $$ \\frac {\\partial f} {\\partial y} = \\lim_{\\Delta \\to 0} \\frac {f(x, y + \\Delta) - f(x, y - \\Delta)} {2 \\times \\Delta} $$\nApplying the chain rule We can apply the chain rule in the same way when calculating the partial derivative of a composite function with respect to one of the inputs. Since the change in input causes a change in the input to the next function, which then causes a change in the input to the next, and so on, we will still do a backward pass the same way as we would with a single input. We just follow it back to the point where the input is given. For example with the following\nWe can see that the first function has two inputs whereas g and h have only 1 input. So there will be two partial derivatives for this composite function. These can be given as follows (applying the chain rule):\n$$ (f \\circ g \\circ h)_x = f_x(x, y) \\times g'(f(x, y)) \\times h'(g(f(x, y))) $$ $$ (f \\circ g \\circ h)_y = f_y(x, y) \\times g'(f(x, y)) \\times h'(g(f(x, y))) $$\nNote that here we are using Legrange\u0026rsquo;s Notation as it can be cleaner than the Leibniz notation. In this notation we can use \\(f'(x)\\) to denote the derivative of function f taking a single input, at value x.\nWith multiple inputs, the input we\u0026rsquo;re describing the partial derivative of can be given as a subscript. e.g. \\(f_x(x, y)\\) would be saying we are interested in how much a change in x will cause a change in the output of the function, at the point defined by the given values of x and y.\nOverall the chain rule works the same way as a single input, except we are defining the input we\u0026rsquo;re interested in when back propagating to work out the derivative.\nLet\u0026rsquo;s assume the following functions to calculate the derivative of a given 2 input function with respect to each of the inputs:\nfn derivative_x(f: impl Fn(f64, f64) -\u0026gt; f64, x: f64, y: f64, delta: f64) -\u0026gt; f64 { (f(x + delta, y) - f(x - delta, y)) / (2.0 * delta) } fn derivative_y(f: impl Fn(f64, f64) -\u0026gt; f64, x: f64, y: f64, delta: f64) -\u0026gt; f64 { (f(x, y + delta) - f(x, y - delta)) / (2.0 * delta) } Along with the existence of the previous function, \u0026ldquo;derivative\u0026rdquo; which performs the same calculation but on a single input function. We can then calculate the derivatives of the composite function as shown above with the following functions:\nfn derivative_x_chain(f: impl Fn(f64, f64) -\u0026gt; f64, g: impl Fn(f64) -\u0026gt; f64, h: impl Fn(f64) -\u0026gt; f64, x: f64, y: f64, delta: f64) -\u0026gt; f64 { // forward pass to calculate inputs  let f_of_xy = f(x, y); let g_of_f_of_xy = g(f_of_xy); // backward pass to calculate partial derivatives  let derivative_f = derivative_x(f, x, y, delta); let derivative_g = derivative(g, f_of_xy, delta); let derivative_h = derivative(h, g_of_f_of_xy, delta); // total derivative with respect to x of compound function  derivative_f * derivative_g * derivative_h } fn derivative_y_chain(f: impl Fn(f64, f64) -\u0026gt; f64, g: impl Fn(f64) -\u0026gt; f64, h: impl Fn(f64) -\u0026gt; f64, x: f64, y: f64, delta: f64) -\u0026gt; f64 { // forward pass to calculate inputs  let f_of_xy = f(x, y); let g_of_f_of_xy = g(f_of_xy); // backward pass to calculate partial derivatives  let derivative_f = derivative_y(f, x, y, delta); let derivative_g = derivative(g, f_of_xy, delta); let derivative_h = derivative(h, g_of_f_of_xy, delta); // total derivative with respect to x of compound function  derivative_f * derivative_g * derivative_h } For a runnable example of comparing calculating the derivative of a composite function both directly and via the chain rule, I have written a simple example on the Rust Playground which shows that the derivative calculated for a composite function directly results in the same value as a derivative calculated using the chain rule (both single and multiple input functions are tested).\n","permalink":"https://forgottenmaster.github.io/posts/machinelearning/deeplearningfromscratch/chapter1/multipleinputs/","summary":"So far, we\u0026rsquo;ve learned how to chain functions together, and how to calculate the derivative of a function at a specific input value. We\u0026rsquo;ve also learned how to apply the chain rule when we are chaining multiple functions together. However, how do we calculate the derivative of a function, or chain of functions when a function has multiple inputs?.\nAs it turns out, we can calculate the derivative in the same way!","title":"Multiple Inputs"},{"content":"After learning what a derivative of a function is, and how to apply the chain rule to a composite function, we then learned how to calculate the derivative of a function with multiple inputs by tracing back through the chain of functions following the route of one of the parameters while holding the others constant.\nThe next step in the prerequisite mathematics we need to build the foundations of a neural network is to determine what the derivative of a function means when one or more of the inputs is a vector.\nGiven the following block diagram for a chain of functions\nThat is, a function, f which takes two inputs both of which are vectors (denoted by the bar above the name), and a function, g which operates on the resulting value.\nFurthermore, let\u0026rsquo;s say that f is actually the dot product function. This function is written as follows, if we assume that X and W are both vectors of length 3:\n$$ f(X, W) = X \\cdot W = X_1 \\times W_1 + X_2 \\times W_2 + X_3 \\times W_3 $$\nAs a reminder, the derivative of a function is the ratio of the change in the output given a change in the input, at a specific input value (point on the graph of the function). This is easy to determine when the inputs and outputs are plain values as it\u0026rsquo;s just a ratio of the two deltas.\nWhen an input is a vector though, what does a change in the input mean?. In fact, this is easily interpreted as a change in one of the components of the input.\nAs seen in the dot product formula (though the function can be any function on vectors), a vector can be decomposed into a list of individual numbers/components. Therefore we can calculate the derivative of the function with respect to an individual component by holding the others to be constant and varying the one we\u0026rsquo;re interested in.\nAfter applying this first function though, the second is operating on a single value and so the chain rule applies as before. In the case of the dot product, this gives us 6 partial derivatives: 3 with respect to the 3 components in the input vector X and 3 with respect to the components of W.\nThe formulas for calculating the derivatives then for the composite function will be as follows in accordance with the chain rule (where n is a valid index for the input vector):\n$$ (g \\circ f)_{X_n} = f_{X_n}(X, W) \\times g'(f(X, W)) $$ $$ (g \\circ f)_{W_n} = f_{W_n}(X, W) \\times g'(f(X, W)) $$\nLooking back at the formula for calculating the dot product we can see that holding all values constant except for a single component we are interested in causes a change in the output proportional to the matching component of the other vector. For example if we let \\(X_1\\) increase by 1 while holding all other components constant, we can see that the only part of the formula containing \\(X_1\\) is\n$$ X_1 \\times W_1 $$\nIncreasing \\(X_1\\) by 1 then increases the output only by \\(W_1\\)\nWhen we calculate the derivative for the other components then, we find out that elementwise, the derivatives of the dot product with respect to X can be represented by:\n$$ \\begin{bmatrix} W_1 \u0026amp; W_2 \u0026amp; W_3 \\end{bmatrix} $$\nand by the same token, the component wise derivatives of the dot product with respect to W is:\n$$ \\begin{bmatrix} X_1 \u0026amp; X_2 \u0026amp; X_3 \\end{bmatrix} $$\nWhen we write the dot product as row and column vectors in order to have the correct shapes for performing the dot product:\n$$ \\begin{bmatrix} X_1 \u0026amp; X_2 \u0026amp; X_3 \\end{bmatrix} \\cdot \\begin{bmatrix} W_1 \\\\ W_2 \\\\ W_3 \\end{bmatrix} $$\nWe can see that the component wise derivative with respect to X will be \\( \\begin{bmatrix} W_1 \u0026amp; W_2 \u0026amp; W_3 \\end{bmatrix} \\), that is \\(W^T\\) and the component wise derivative with respect to W will be \\( \\begin{bmatrix} X_1 \\\\ X_2 \\\\ X_3 \\end{bmatrix} \\), that is \\(X^T\\)\nConclusion In conclusion, calculating the derivative of a function with vector inputs is just calculating the derivative of the function with respect to each component in the vector. Additionally, and most importantly for deep learning, the derivative of the dot product of a row vector X with a column vector W turns out to be \\(W^T\\) and \\(X^T\\) respectively.\n","permalink":"https://forgottenmaster.github.io/posts/machinelearning/deeplearningfromscratch/chapter1/vectorinputs/","summary":"After learning what a derivative of a function is, and how to apply the chain rule to a composite function, we then learned how to calculate the derivative of a function with multiple inputs by tracing back through the chain of functions following the route of one of the parameters while holding the others constant.\nThe next step in the prerequisite mathematics we need to build the foundations of a neural network is to determine what the derivative of a function means when one or more of the inputs is a vector.","title":"Vector Inputs"},{"content":" Ubisoft Reflections\nSenior Gameplay Programmer\nApril 2020 - Present\nAs a senior gameplay programmer I have been responsible for architecting and implementing large systems in Assassin\u0026rsquo;s Creed VR. Where the product statement isn\u0026rsquo;t clear or is incomplete, I have worked with other disciplines to ensure the final design does what is required. During this time I have gained experience in Unity3D including DOTS and best practices for efficient programs. Additionally, I attempt to always share my knowledge as I develop it myself so as to allow others to also build their skills.\nUbisoft Reflections\nGameplay Programmer\nMarch 2018 - April 2020\nAs a gameplay programmer I have helped design and implement some fairly large systems for \u0026ldquo;Tom Clancy\u0026rsquo;s The Division 2\u0026rdquo; with the main feature being clans. As part of the clans feature I worked with designers, as well as the online team in order to develop clan missions and rewards, and clan spaces.\nUbisoft Reflections\nJunior Gameplay Programmer\nNovember 2014 - March 2018\nIn this position I worked on \u0026ldquo;Tom Clancy\u0026rsquo;s The Division\u0026rdquo; as well as the associated expansion packs and DLC. I gained industry experience using C++ in a large codebase, and also with the in-house engine used to develop these (Snowdrop). I gained experience in using visual scripting and node graph systems.\n Eutechnyx Ltd.\nProgrammer\nJuly 2010 - November 2014\nWhile working at Eutechnyx I was part of the team developing \u0026ldquo;Auto Club Revolution\u0026rdquo;, a social network and gaming site revolving around car enthusiasts. I gained experience with front and back end web technologies using HTML/CSS/JavaScript for the frontend, and Python for the backend. Additional technologies used were MongoDB for the database management software, along with Redis for caching. Being a dynamic website, I gained experience interfacing with popular APIs including Facebook, and payment providers.\n Newcastle University\nMSc, Computer Games Engineering\n2008-2009\nDissertation titled \u0026ldquo;Games with a purpose\u0026rdquo;\nGraduated with merit\nNewcastle University\nBSc, Computing Science\n2005-2008\nDissertation titled \u0026ldquo;Video records of everyday life\u0026rdquo;\nGraduated with first class degree\n","permalink":"https://forgottenmaster.github.io/resume/","summary":"Ubisoft Reflections\nSenior Gameplay Programmer\nApril 2020 - Present\nAs a senior gameplay programmer I have been responsible for architecting and implementing large systems in Assassin\u0026rsquo;s Creed VR. Where the product statement isn\u0026rsquo;t clear or is incomplete, I have worked with other disciplines to ensure the final design does what is required. During this time I have gained experience in Unity3D including DOTS and best practices for efficient programs. Additionally, I attempt to always share my knowledge as I develop it myself so as to allow others to also build their skills.","title":"Résumé"}]