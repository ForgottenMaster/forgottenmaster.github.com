<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Enums | Robin Firth</title>
<meta name="keywords" content="" />
<meta name="description" content="C Style Enums In C#, C&#43;&#43;, and a lot of other popular programming languages, we have access to a type called an &ldquo;enumeration&rdquo; (or enum for short). This is simply a type safe collection of named constant values.
For example in C&#43;&#43;, making an enum whose variants represent a set of allowed colors for a hypothetical UI framework could be written as (with the values of the variants explicitly typed out for transparency):">
<meta name="author" content="">
<link rel="canonical" href="https://forgottenmaster.github.io/posts/rust/whyrust/enums/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.6f60056d44d3f7eb69a4bc6c332b59960f3a995802bded244750232f33713c49.css" integrity="sha256-b2AFbUTT9&#43;tppLxsMytZlg86mVgCve0kR1AjLzNxPEk=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js" integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://forgottenmaster.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://forgottenmaster.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://forgottenmaster.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://forgottenmaster.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://forgottenmaster.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.96.0" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta property="og:title" content="Enums" />
<meta property="og:description" content="C Style Enums In C#, C&#43;&#43;, and a lot of other popular programming languages, we have access to a type called an &ldquo;enumeration&rdquo; (or enum for short). This is simply a type safe collection of named constant values.
For example in C&#43;&#43;, making an enum whose variants represent a set of allowed colors for a hypothetical UI framework could be written as (with the values of the variants explicitly typed out for transparency):" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://forgottenmaster.github.io/posts/rust/whyrust/enums/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-26T17:14:48&#43;01:00" />
<meta property="article:modified_time" content="2021-09-26T17:14:48&#43;01:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Enums"/>
<meta name="twitter:description" content="C Style Enums In C#, C&#43;&#43;, and a lot of other popular programming languages, we have access to a type called an &ldquo;enumeration&rdquo; (or enum for short). This is simply a type safe collection of named constant values.
For example in C&#43;&#43;, making an enum whose variants represent a set of allowed colors for a hypothetical UI framework could be written as (with the values of the variants explicitly typed out for transparency):"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://forgottenmaster.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Rust",
      "item": "https://forgottenmaster.github.io/posts/rust/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Why Rust?",
      "item": "https://forgottenmaster.github.io/posts/rust/whyrust/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "Enums",
      "item": "https://forgottenmaster.github.io/posts/rust/whyrust/enums/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Enums",
  "name": "Enums",
  "description": "C Style Enums In C#, C++, and a lot of other popular programming languages, we have access to a type called an \u0026ldquo;enumeration\u0026rdquo; (or enum for short). This is simply a type safe collection of named constant values.\nFor example in C++, making an enum whose variants represent a set of allowed colors for a hypothetical UI framework could be written as (with the values of the variants explicitly typed out for transparency):",
  "keywords": [
    
  ],
  "articleBody": "C Style Enums In C#, C++, and a lot of other popular programming languages, we have access to a type called an “enumeration” (or enum for short). This is simply a type safe collection of named constant values.\nFor example in C++, making an enum whose variants represent a set of allowed colors for a hypothetical UI framework could be written as (with the values of the variants explicitly typed out for transparency):\nenum Color {  Red = 1,  Green = 2,  Blue = 3 }; A function can then go ahead and accept a “Color” and the user will be able to pass only the named colors. Except that in C++, this is not true. Nothing stops the caller from casting an arbitrary integer as a “Color”. For example calling a SetColor function that takes a Color, the caller can do:\nwidget.SetColor(static_castColor(10)); // what even is color with value 10???. It hasn't been defined so likely won't be correctly handled.  This is not desired as SetColor can’t assume that the given Color is only one that was specified in the enumeration. If someone can arbitrarily cast an integer to Color, what is the function supposed to do with it?.\nIn Rust, we can have value type enums the same way:\nenum Color {  Red = 1,  Green = 2,  Blue = 3 } And casting such an enum value into an integer is totally fine, the following snippet will print “Selected color is: 3”:\n// enum variant to integral value is safely supported because it's a total function - all enum variants in this style of enumeration // can be cast to the respective integer value. println!(\"Selected color is: {}\", Color::Blue as u8); This is totally fine and allowed by Rust because all variants of this C-style enumeration can be casted safely to an integer. We say it’s infallible\nHowever, casting an integer to an enumeration type is not infallible because not all possible integral values have a variant in the enumeration, we can’t do the following - it simply does not compile:\n// does not compile as integral to enum conversion is not implemented since it can fail for certain values of integer. let int_as_color = 10 as Blue; Rust is a safe and cautious language and the compiler will just not allow operations that could fail, therefore converting from enum to integral isn’t supported by default, however the enum creator can implement the TryFromtrait for any integral types.\nHowever this is boilerplate that’s already been done and available in a crate. Therefore to allow for C-style enums in Rust with safe conversions in both directions, it’s best to use https://crates.io/crates/num_enum\nTuple Enums In C++, the above is all you get, loosely typed integers that aren’t even that safe. With Rust, enums become more powerful with the ability to store different data inside of each variant.\nThese are similar to an algebraic data type such as Haskell has. It could be thought of similar to a union in C++ in that an element of the enum type takes up the amount of space required for the biggest variant (allowing it to store in an array), but strongly typed so you can’t access data you shouldn’t.\nAs an example, suppose we want to have an “Angle” enumeration. An angle could be stored in either Degrees or Radians, but both are stored as floats. In this case the tuple enum would look as follows:\nenum Angle {  Degrees(f32),  Radians(f32) } In both of these variants, we store an f32, but behind the scenes each instance of Angle is tagged with its discriminant (Degrees or Radians) and the only way to access the data inside is through pattern matching. This means we literally can’t access data that we shouldn’t for the variant we have. An example of implementing the Intotrait for this would be:\nimpl Intof32 for Angle {  fn into(self) - f32 {  match self {  Self::Degrees(val) = val,  Self::Radians(val) = val  }  } } An example of an enumeration with differing types could be a Color, where we can choose between different color formats:\nenum Color {  RGBF32(f32, f32, f32),  RGBAF32(f32, f32, f32, f32),  RGBU8(u8, u8, u8),  RGBAU8(u8, u8, u8, u8) } That is, we can choose between colors with RGB or RGBA components, and can choose the type of the components we’re storing. However because this is essentially a strongly typed union, and Rust requires all types to have a defined size to be stored, the largest size would still be picked, in this case each Color would be 16 bytes large (corresponding to the size of RGBAF32 which is largest).\nPattern matching works the exact same way. For example, a method on Color which can return whether the color supports transparency could be written as follows:\nimpl Color {  fn supports_transparency(\u0026self) - bool {  match self {  Self::RGBF32(..) = false,  Self::RGBAF32(..) = true,  Self::RGBU8(..) = false,  Self::RGBAU8(..) = true   }  } } Named Field Enums A variant in an enum can use the tuple syntax for defining the types it contains, and pattern matching as described above, however we can also store values associated with an enum variant by name in a record/struct like syntax. We can freely mix and match these on a per-variant basis. For example an enumeration which represents an Error. We might support storing an ErrorMessage, ErrorCode, or both. This might look as follows:\nenum Error {  Message(String),  Code(i32),  Both {  message: String,  code: i32  } } When pattern matching on tuple types, we need to use the tuple patterns. When matching on record types, we need to use that syntax. An example of a function to try to get an error code from an Error would be:\nimpl Error {  fn try_get_code(\u0026self) - Optioni32 {  match self {  Self::Message(..) = None,  Self::Code(c) = Some(*c),  Self::Both{code: c, ..} = Some(*c)  }  } } Empty Enums!? Empty enums can’t be constructed. This may sound kind of pointless, what does\nenum Void { } Even mean if it can’t be constructed?\nAs it turns out this can be very useful for statically proving that we can’t ever take a particular branch of code in some cases, and is sometimes seen in generic code.\nFor example, in Rust we have the Result type which has two type parameters. One is the success type, and one is the error type. Say that a trait requires a return type of Resultfrom a function\ntrait TryOperation {  type SuccessType;  type ErrorType;  fn try_operation(\u0026mut self) - ResultSelf::SuccessType, Self::ErrorType } In order to implement such a trait, we must provide an ErrorType to satisfy the signature of the trait, but for an infallible operation which is guaranteed to not fail, what do we choose for an ErrorType?. Any type is as good as any other type if we never need to construct it and we never return it:\nstruct InfallibleOperation { }  impl TryOperation for InfallibleOperation {  type SuccessType = (); // Unit type is like \"void\" in other languages, it's a type we can use when we don't need to return any information.  type ErrorType = ???; // What do we put here if this operation never fails?  fn try_operation(\u0026mut self) - ResultSelf::SuccessType, Self::ErrorType {  println!(\"Hello, World!\");  } } The implementation of this function simply prints to the console and never fails, we’re “trying” to perform the operation but it will always succeed. It turns out in these cases we can communicate this at the type level to the caller by using the empty enum as the ErrorType (e.g. Void). If the caller sees that the signature for this is:\nfn try_operation(\u0026mut self) - Result(), Void Then they can easily see that the error case can never possibly happen (because an instance of Void physically cannot be constructed). In this case, the caller knows it’s safe to not even handle the possibility of error as this is ensured by the compiler in the types.\n",
  "wordCount" : "1326",
  "inLanguage": "en",
  "datePublished": "2021-09-26T17:14:48+01:00",
  "dateModified": "2021-09-26T17:14:48+01:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://forgottenmaster.github.io/posts/rust/whyrust/enums/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Robin Firth",
    "logo": {
      "@type": "ImageObject",
      "url": "https://forgottenmaster.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://forgottenmaster.github.io/" accesskey="h" title="Robin Firth (Alt + H)">Robin Firth</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://forgottenmaster.github.io/resume/" title="Résumé">
                    <span>Résumé</span>
                </a>
            </li>
            <li>
                <a href="https://forgottenmaster.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://forgottenmaster.github.io/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://forgottenmaster.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/rust/">Rust</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/rust/whyrust/">Why Rust?</a></div>
    <h1 class="post-title">
      Enums
    </h1>
    <div class="post-meta"><span title='2021-09-26 17:14:48 +0100 BST'>September 26, 2021</span>&nbsp;·&nbsp;7 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#c-style-enums" aria-label="C Style Enums">C Style Enums</a></li>
                <li>
                    <a href="#tuple-enums" aria-label="Tuple Enums">Tuple Enums</a></li>
                <li>
                    <a href="#named-field-enums" aria-label="Named Field Enums">Named Field Enums</a></li>
                <li>
                    <a href="#empty-enums" aria-label="Empty Enums!?">Empty Enums!?</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="c-style-enums">C Style Enums<a hidden class="anchor" aria-hidden="true" href="#c-style-enums">#</a></h3>
<p>In C#, C++, and a lot of other popular programming languages, we have access to a type called an &ldquo;enumeration&rdquo; (or enum for short). This is simply a type safe collection of named constant values.</p>
<p>For example in C++, making an enum whose variants represent a set of allowed colors for a hypothetical UI framework could be written as (with the values of the variants explicitly typed out for transparency):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Color</span> {
</span></span><span style="display:flex;"><span>    Red <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>    Green <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>,
</span></span><span style="display:flex;"><span>    Blue <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p>A function can then go ahead and accept a &ldquo;Color&rdquo; and the user will be able to pass only the named colors. Except that in C++, this is not true. Nothing stops the caller from casting an arbitrary integer as a &ldquo;Color&rdquo;. For example calling a SetColor function that takes a Color, the caller can do:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>widget.SetColor(<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>Color<span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">10</span>)); <span style="color:#75715e">// what even is color with value 10???. It hasn&#39;t been defined so likely won&#39;t be correctly handled.
</span></span></span></code></pre></div>
<p>This is not desired as SetColor can&rsquo;t assume that the given Color is only one that was specified in the enumeration. If someone can arbitrarily cast an integer to Color, what is the function supposed to do with it?.</p>
<p>In Rust, we can have value type enums the same way:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Color</span> {
</span></span><span style="display:flex;"><span>    Red <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>    Green <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>,
</span></span><span style="display:flex;"><span>    Blue <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>And casting such an enum value into an integer is totally fine, the following snippet will print &ldquo;Selected color is: 3&rdquo;:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// enum variant to integral value is safely supported because it&#39;s a total function - all enum variants in this style of enumeration
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// can be cast to the respective integer value.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>println!(<span style="color:#e6db74">&#34;Selected color is: {}&#34;</span>, Color::Blue <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u8</span>);</span></span></code></pre></div>
<p>This is totally fine and allowed by Rust because all variants of this C-style enumeration can be casted safely to an integer. We say it&rsquo;s <em>infallible</em></p>
<p>However, casting an integer to an enumeration type is not infallible because not all possible integral values have a variant in the enumeration, we can&rsquo;t do the following - it simply does not compile:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// does not compile as integral to enum conversion is not implemented since it can fail for certain values of integer.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> int_as_color <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span> <span style="color:#66d9ef">as</span> Blue;</span></span></code></pre></div>
<p>Rust is a safe and cautious language and the compiler will just not allow operations that could fail, therefore converting from enum to integral isn&rsquo;t supported by default, however the enum creator can implement the TryFrom<!-- raw HTML omitted --> trait for any integral types.</p>
<p>However this is boilerplate that&rsquo;s already been done and available in a crate. Therefore to allow for C-style enums in Rust with safe conversions in both directions, it&rsquo;s best to use <a href="https://crates.io/crates/num_enum">https://crates.io/crates/num_enum</a></p>
<h3 id="tuple-enums">Tuple Enums<a hidden class="anchor" aria-hidden="true" href="#tuple-enums">#</a></h3>
<p>In C++, the above is all you get, loosely typed integers that aren&rsquo;t even that safe. With Rust, enums become more powerful with the ability to store different data inside of each variant.</p>
<p>These are similar to an algebraic data type such as Haskell has. It could be thought of similar to a union in C++ in that an element of the enum type takes up the amount of space required for the biggest variant (allowing it to store in an array), but strongly typed so you can&rsquo;t access data you shouldn&rsquo;t.</p>
<p>As an example, suppose we want to have an &ldquo;Angle&rdquo; enumeration. An angle could be stored in either Degrees or Radians, but both are stored as floats. In this case the tuple enum would look as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Angle</span> {
</span></span><span style="display:flex;"><span>    Degrees(<span style="color:#66d9ef">f32</span>),
</span></span><span style="display:flex;"><span>    Radians(<span style="color:#66d9ef">f32</span>)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>In both of these variants, we store an f32, but behind the scenes each instance of Angle is tagged with its discriminant (Degrees or Radians) and the only way to access the data inside is through pattern matching. This means we literally can&rsquo;t access data that we shouldn&rsquo;t for the variant we have. An example of implementing the Into<!-- raw HTML omitted --> trait for this would be:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Into<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f32</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> Angle {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">into</span>(self) -&gt; <span style="color:#66d9ef">f32</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> self {
</span></span><span style="display:flex;"><span>            Self::Degrees(val) <span style="color:#f92672">=&gt;</span> val,
</span></span><span style="display:flex;"><span>            Self::Radians(val) <span style="color:#f92672">=&gt;</span> val
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>An example of an enumeration with differing types could be a Color, where we can choose between different color formats:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Color</span> {
</span></span><span style="display:flex;"><span>    RGBF32(<span style="color:#66d9ef">f32</span>, <span style="color:#66d9ef">f32</span>, <span style="color:#66d9ef">f32</span>),
</span></span><span style="display:flex;"><span>    RGBAF32(<span style="color:#66d9ef">f32</span>, <span style="color:#66d9ef">f32</span>, <span style="color:#66d9ef">f32</span>, <span style="color:#66d9ef">f32</span>),
</span></span><span style="display:flex;"><span>    RGBU8(<span style="color:#66d9ef">u8</span>, <span style="color:#66d9ef">u8</span>, <span style="color:#66d9ef">u8</span>),
</span></span><span style="display:flex;"><span>    RGBAU8(<span style="color:#66d9ef">u8</span>, <span style="color:#66d9ef">u8</span>, <span style="color:#66d9ef">u8</span>, <span style="color:#66d9ef">u8</span>)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>That is, we can choose between colors with RGB or RGBA components, and can choose the type of the components we&rsquo;re storing. However because this is essentially a strongly typed union, and Rust requires all types to have a defined size to be stored, the largest size would still be picked, in this case each Color would be 16 bytes large (corresponding to the size of RGBAF32 which is largest).</p>
<p>Pattern matching works the exact same way. For example, a method on Color which can return whether the color supports transparency could be written as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Color {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">supports_transparency</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> self {
</span></span><span style="display:flex;"><span>            Self::RGBF32(<span style="color:#f92672">..</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">false</span>,
</span></span><span style="display:flex;"><span>            Self::RGBAF32(<span style="color:#f92672">..</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>            Self::RGBU8(<span style="color:#f92672">..</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">false</span>,
</span></span><span style="display:flex;"><span>            Self::RGBAU8(<span style="color:#f92672">..</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="named-field-enums">Named Field Enums<a hidden class="anchor" aria-hidden="true" href="#named-field-enums">#</a></h3>
<p>A variant in an enum can use the tuple syntax for defining the types it contains, and pattern matching as described above, however we can also store values associated with an enum variant by name in a record/struct like syntax. We can freely mix and match these on a per-variant basis. For example an enumeration which represents an Error. We might support storing an ErrorMessage, ErrorCode, or both. This might look as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Error</span> {
</span></span><span style="display:flex;"><span>    Message(String),
</span></span><span style="display:flex;"><span>    Code(<span style="color:#66d9ef">i32</span>),
</span></span><span style="display:flex;"><span>    Both {
</span></span><span style="display:flex;"><span>        message: String,
</span></span><span style="display:flex;"><span>        code: <span style="color:#66d9ef">i32</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>When pattern matching on tuple types, we need to use the tuple patterns. When matching on record types, we need to use that syntax. An example of a function to try to get an error code from an Error would be:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Error {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">try_get_code</span>(<span style="color:#f92672">&amp;</span>self) -&gt; Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> self {
</span></span><span style="display:flex;"><span>            Self::Message(<span style="color:#f92672">..</span>) <span style="color:#f92672">=&gt;</span> None,
</span></span><span style="display:flex;"><span>            Self::Code(c) <span style="color:#f92672">=&gt;</span> Some(<span style="color:#f92672">*</span>c),
</span></span><span style="display:flex;"><span>            Self::Both{code: <span style="color:#a6e22e">c</span>, <span style="color:#f92672">..</span>} <span style="color:#f92672">=&gt;</span> Some(<span style="color:#f92672">*</span>c)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="empty-enums">Empty Enums!?<a hidden class="anchor" aria-hidden="true" href="#empty-enums">#</a></h3>
<p>Empty enums can&rsquo;t be constructed. This may sound kind of pointless, what does</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Void</span> {
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Even mean if it can&rsquo;t be constructed?</p>
<p>As it turns out this can be very useful for statically proving that we can&rsquo;t ever take a particular branch of code in some cases, and is sometimes seen in generic code.</p>
<p>For example, in Rust we have the Result type which has two type parameters. One is the success type, and one is the error type. Say that a trait requires a return type of Result&lt;SuccessType, ErrorType&gt; from a function</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> TryOperation {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SuccessType</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ErrorType</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">try_operation</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; Result<span style="color:#f92672">&lt;</span>Self::SuccessType, Self::ErrorType<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>In order to implement such a trait, we <strong>must</strong> provide an ErrorType to satisfy the signature of the trait, but for an infallible operation which is guaranteed to not fail, what do we choose for an ErrorType?. Any type is as good as any other type if we never need to construct it and we never return it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">InfallibleOperation</span> {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> TryOperation <span style="color:#66d9ef">for</span> InfallibleOperation {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SuccessType</span> <span style="color:#f92672">=</span> (); <span style="color:#75715e">// Unit type is like &#34;void&#34; in other languages, it&#39;s a type we can use when we don&#39;t need to return any information.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ErrorType</span> <span style="color:#f92672">=</span> <span style="color:#f92672">???</span>; <span style="color:#75715e">// What do we put here if this operation never fails?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">try_operation</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; Result<span style="color:#f92672">&lt;</span>Self::SuccessType, Self::ErrorType<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;Hello, World!&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>The implementation of this function simply prints to the console and never fails, we&rsquo;re &ldquo;trying&rdquo; to perform the operation but it will always succeed. It turns out in these cases we can communicate this at the type level to the caller by using the empty enum as the ErrorType (e.g. Void). If the caller sees that the signature for this is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">try_operation</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; Result<span style="color:#f92672">&lt;</span>(), Void<span style="color:#f92672">&gt;</span></span></span></code></pre></div>
<p>Then they can easily see that the error case can <strong>never</strong> possibly happen (because an instance of Void physically cannot be constructed). In this case, the caller knows it&rsquo;s safe to not even handle the possibility of error as this is ensured by the compiler in the types.</p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://forgottenmaster.github.io/">Robin Firth</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
