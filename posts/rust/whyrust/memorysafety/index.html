<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Memory Safety | Robin Firth</title>
<meta name="keywords" content="" />
<meta name="description" content="Move By Default In most programming languages, there is no one true &ldquo;owner&rdquo; of any given piece of data. Data can be allocated on the stack or the heap but references to it can be passed around as needed. There isn&rsquo;t a way of the compiler to track ownership of a piece of data in most languages such as C&#43;&#43;.
Additionally expensive copies of structures may be done without us realising, or being able to opt out of it.">
<meta name="author" content="">
<link rel="canonical" href="https://forgottenmaster.github.io/posts/rust/whyrust/memorysafety/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.6f60056d44d3f7eb69a4bc6c332b59960f3a995802bded244750232f33713c49.css" integrity="sha256-b2AFbUTT9&#43;tppLxsMytZlg86mVgCve0kR1AjLzNxPEk=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://forgottenmaster.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://forgottenmaster.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://forgottenmaster.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://forgottenmaster.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://forgottenmaster.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.89.4" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta property="og:title" content="Memory Safety" />
<meta property="og:description" content="Move By Default In most programming languages, there is no one true &ldquo;owner&rdquo; of any given piece of data. Data can be allocated on the stack or the heap but references to it can be passed around as needed. There isn&rsquo;t a way of the compiler to track ownership of a piece of data in most languages such as C&#43;&#43;.
Additionally expensive copies of structures may be done without us realising, or being able to opt out of it." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://forgottenmaster.github.io/posts/rust/whyrust/memorysafety/" />
<meta property="og:image" content="https://forgottenmaster.github.io/posts/rust/whyrust/memorysafety/cover.jpg" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-15T01:31:14&#43;01:00" />
<meta property="article:modified_time" content="2021-10-15T01:31:14&#43;01:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://forgottenmaster.github.io/posts/rust/whyrust/memorysafety/cover.jpg" />
<meta name="twitter:title" content="Memory Safety"/>
<meta name="twitter:description" content="Move By Default In most programming languages, there is no one true &ldquo;owner&rdquo; of any given piece of data. Data can be allocated on the stack or the heap but references to it can be passed around as needed. There isn&rsquo;t a way of the compiler to track ownership of a piece of data in most languages such as C&#43;&#43;.
Additionally expensive copies of structures may be done without us realising, or being able to opt out of it."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://forgottenmaster.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Rust",
      "item": "https://forgottenmaster.github.io/posts/rust/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Why Rust?",
      "item": "https://forgottenmaster.github.io/posts/rust/whyrust/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "Memory Safety",
      "item": "https://forgottenmaster.github.io/posts/rust/whyrust/memorysafety/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Memory Safety",
  "name": "Memory Safety",
  "description": "Move By Default In most programming languages, there is no one true \u0026ldquo;owner\u0026rdquo; of any given piece of data. Data can be allocated on the stack or the heap but references to it can be passed around as needed. There isn\u0026rsquo;t a way of the compiler to track ownership of a piece of data in most languages such as C++.\nAdditionally expensive copies of structures may be done without us realising, or being able to opt out of it.",
  "keywords": [
    
  ],
  "articleBody": "Move By Default In most programming languages, there is no one true “owner” of any given piece of data. Data can be allocated on the stack or the heap but references to it can be passed around as needed. There isn’t a way of the compiler to track ownership of a piece of data in most languages such as C++.\nAdditionally expensive copies of structures may be done without us realising, or being able to opt out of it. For example in C++ and C# the following code will result in making a copy of SomeLargeStruct\nSomeExpensiveStruct s1; SomeExpensiveStruct s2 = s1; // this will make a copy of s1  In Rust, each piece of data has a single owner at any one time. If the owning binding or function goes out of scope, the data is dropped and this gives an opportunity for the type to do any resources allocated. This is similar to a destructor in C++. Due to the single ownership model, Rust moves data by default on assigment, or when passing into and out of functions.\nAn example of the flow of ownership in Rust is the following\nlet v1 = vec![1, 2, 3]; // v1 is a binding that owns a vector with the integers 1, 2, and 3 let v2 = v1; // v1 is *moved* to binding v2. v2 is now the owner of the vector, v1 has relinquished control println!(\"{}\", v1); // here we are trying to print out v1, but v1 isn't the owner of any data and so can't give out references, etc.  In the above code snippet, the binding v1 transfers ownership of the data to the binding v2, trying to use v1 afterwards results in the following compiler output\nerror[E0382]: use of moved value: `v1`\r-- src/main.rs:4:10\r|\r2 | let v1 = vec![1, 2, 3];\r| -- move occurs because `v1` has type `Vec`, which does not implement the `Copy` trait\r3 | let v2 = v1;\r| -- value moved here\r4 | dbg!(v1);\r| ^^ value used here after move\r Rust won’t let us compile a program which violates the ownership rules like this.\nThe above example is of a move that occurs when assigning from one binding to another, but the same will happen if we passed into a function, for example\nfn foo(v: Veci32) { // v is a vector of integers, ownership is transferred into the function from outside  // the function is the owner of the data, so at the end of the function, the data is dropped } fn main() { let v = vec![1, 2, 3]; foo(v); // ownership is transferred into the function here  dbg!(v); } Will result in a similar compiler error as before:\nerror[E0382]: use of moved value: `v`\r-- src/main.rs:7:10\r|\r5 | let v = vec![1, 2, 3];\r| - move occurs because `v` has type `Vec`, which does not implement the `Copy` trait\r6 | foo(v);\r| - value moved here\r7 | dbg!(v);\r| ^ value used here after move\r Use After Free In languages such as C++, there are no mechanisms which prevent a use after free error. For example the following code is completely valid\nstruct SomeStruct { public: const char* name; }; SomeStruct\u0026 allocAndReturn() { SomeStruct s; s.name = \"Hello, World!\"; return s; } int main() { SomeStruct\u0026 s = allocAndReturn(); std::cout  s.name  std::endl; // Boom!, we've used an invalid reference  return 0; } As the C++ compiler doesn’t track ownership or lifetimes, it doesn’t prevent the function from returning a reference to an object that then goes out of scope, then when it tries to access s.name the program segfaults.\nContrast this in Rust, where the compiler tracks lifetimes, it is able to detect a use after free and will fail to compile. If we attempt to return a reference to an object created in a function as in the above program, we won’t be able to compile. As it’s difficult to do the above function in Rust without delving into lifetime annotations, a smaller program demonstrates the same issue\nfn main() { let v = { let v = vec![4, 5, 6]; \u0026v }; dbg!(v); } As Rust is an expression based language, we can create an arbitrary scope or code block that ends in an expression, and use that to assign to a binding, or anywhere else an expression is accepted.\nIn the code snippet, we are creating a vector v inside the block, and then trying to return a reference to it, out of the block and bind it to the outer v binding.\nHowever Rust detects that we are trying to keep a reference for longer than the object is in scope and gives the following compiler error\nerror[E0597]: `v` does not live long enough\r-- src/main.rs:4:9\r|\r2 | let v = {\r| - borrow later stored here\r3 | let v = vec![4, 5, 6];\r4 | \u0026v\r| ^^ borrowed value does not live long enough\r5 | };\r| - `v` dropped here while still borrowed\r This is the Rust’s borrow checker and lifetime rules at work.\nModification While Reading In other languages, it’s common for a mutable and immutable reference to exist at the same time. For example in C++ we may do the following:\nSomeStruct s; const SomeStruct \u0026s1 = s; SomeStruct\u0026 s2 = s; The implications of this is that someone that is holding an immutable reference to an object will observe changes made to the object (through a mutable reference). This is contrary to what the definition should be of an immutable reference, the holder shouldn’t see any changes as it’s immutable.\nIf we attempt to do this in Rust, it will fail to compile as we cannot take a mutable and immutable reference at the same time (though we may take as many immutable references as we’d like since none will observe any changes).\nfn main() { let mut v = vec![1, 2, 3]; let v1 = \u0026v; let v2 = \u0026mut v; dbg!(v1); } We are greeted with the following compile error\nerror[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable\r-- src/main.rs:4:14\r|\r3 | let v1 = \u0026v;\r| -- immutable borrow occurs here\r4 | let v2 = \u0026mut v;\r| ^^^^^^ mutable borrow occurs here\r5 | dbg!(v1);\r| -- immutable borrow later used here\r Rust guarantees memory safety here by allowing either 0 or more immutable references OR 0 or 1 mutable reference. It is forbidden to have a mutable reference while ANY references are taken, and only 1 mutable reference can be taken at a time.\nThis means if you hold a mutable reference to an object, the compiler guarantees that only you can make changes to the object. It also guarantees that if you hold an immutable reference you will never see any state changes through that.\nThis isn’t strictly true….there are types in the standard library that allow for interior mutability, that is, mutating through an immutable reference. However, they are also perfectly safe to use because they perform the check at runtime instead. When using those types, you are only allowed to mutate a value if nothing else currently holds a borrow to it.\nIn conclusion, most programming languages have no real protections against multiple sources writing to an object, even when other sources have read-only access. Rust has a policy of only 1 writer at a time, and only when there are no readers in existence.\nThis does require some code restructuring to separate the reading from the writing, but results in much safer code and prevents common problems such as modifying a collection while iterating over it, which is impossible in Rust due to the borrow checker.\nThread Safety The last topic on memory safety in Rust will be a few words on how the safety rules also apply in a multithreaded context.\nMost languages don’t have any guarantees about whether an object is safe to be accessed from multiple threads at a time, and if an object is not safe, but is accessed concurrently from 2 threads, this is called a data race, and is not a good thing.\nRust provides a system by which the compiler will fail to compile a program if we try to use a non thread-safe type in a multithreaded context.\nThe way it achieves this is by using two core traits called Send and Sync\nThese are implemented (or not implemented) by types automatically based on the data inside the types. If all the members of a custom type are Send, or Sync then the type itself is Send or Sync.\nSend means that instances of this type can be transferred over to a different thread. This is transfer of ownership across a thread boundary.\nSync means that instances of this type can be accessed from multiple threads at the same time, that is references to the instance are Send.\nThe developer can implement Send and Sync manually on types if those types aren’t automatically deemed Send/Sync, however to do so is an unsafe operation as it requires that the developer has checked that the type is indeed thread-safe.\n",
  "wordCount" : "1540",
  "inLanguage": "en",
  "image":"https://forgottenmaster.github.io/posts/rust/whyrust/memorysafety/cover.jpg","datePublished": "2021-10-15T01:31:14+01:00",
  "dateModified": "2021-10-15T01:31:14+01:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://forgottenmaster.github.io/posts/rust/whyrust/memorysafety/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Robin Firth",
    "logo": {
      "@type": "ImageObject",
      "url": "https://forgottenmaster.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://forgottenmaster.github.io/" accesskey="h" title="Robin Firth (Alt + H)">Robin Firth</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://forgottenmaster.github.io/resume/" title="Résumé">
                    <span>Résumé</span>
                </a>
            </li>
            <li>
                <a href="https://forgottenmaster.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://forgottenmaster.github.io/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://forgottenmaster.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/rust/">Rust</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/rust/whyrust/">Why Rust?</a></div>
    <h1 class="post-title">
      Memory Safety
    </h1>
    <div class="post-meta"><span title='2021-10-15 01:31:14 +0100 BST'>October 15, 2021</span>

</div>
  </header> 
<figure class="entry-cover">
        <img loading="lazy" srcset="https://forgottenmaster.github.io/posts/rust/whyrust/memorysafety/cover_hu8803a04aa267aed231a1d2427190cd32_70284_360x0_resize_q75_box.jpg 360w ,https://forgottenmaster.github.io/posts/rust/whyrust/memorysafety/cover.jpg 390w" 
            sizes="(min-width: 768px) 720px, 100vw" src="https://forgottenmaster.github.io/posts/rust/whyrust/memorysafety/cover.jpg" alt="Memory Safety Cover Image" 
            width="390" height="280">
        
</figure><div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#move-by-default" aria-label="Move By Default">Move By Default</a></li>
                <li>
                    <a href="#use-after-free" aria-label="Use After Free">Use After Free</a></li>
                <li>
                    <a href="#modification-while-reading" aria-label="Modification While Reading">Modification While Reading</a></li>
                <li>
                    <a href="#thread-safety" aria-label="Thread Safety">Thread Safety</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="move-by-default">Move By Default<a hidden class="anchor" aria-hidden="true" href="#move-by-default">#</a></h3>
<p>In most programming languages, there is no one true &ldquo;owner&rdquo; of any given piece of data. Data can be allocated on the stack or the heap but references to it can be passed around as needed. There isn&rsquo;t a way of the compiler to track ownership of a piece of data in most languages such as C++.</p>
<p>Additionally expensive copies of structures may be done without us realising, or being able to opt out of it. For example in C++ and C# the following code will result in making a copy of SomeLargeStruct</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">SomeExpensiveStruct s1;
SomeExpensiveStruct s2 <span style="color:#f92672">=</span> s1; <span style="color:#75715e">// this will make a copy of s1
</span></code></pre></div>
<p>In Rust, each piece of data has a single owner at any one time. If the owning binding or function goes out of scope, the data is <em>dropped</em> and this gives an opportunity for the type to do any resources allocated. This is similar to a destructor in C++. Due to the single ownership model, Rust moves data by default on assigment, or when passing into and out of functions.</p>
<p>An example of the flow of ownership in Rust is the following</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> v1 <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];     <span style="color:#75715e">// v1 is a binding that owns a vector with the integers 1, 2, and 3
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> v2 <span style="color:#f92672">=</span> v1;                <span style="color:#75715e">// v1 is *moved* to binding v2. v2 is now the owner of the vector, v1 has relinquished control
</span><span style="color:#75715e"></span>println!(<span style="color:#e6db74">&#34;{}&#34;</span>, v1);         <span style="color:#75715e">// here we are trying to print out v1, but v1 isn&#39;t the owner of any data and so can&#39;t give out references, etc.
</span></code></pre></div>
<p>In the above code snippet, the binding v1 transfers ownership of the data to the binding v2, trying to use v1 afterwards results in the following compiler output</p>
<pre><code>error[E0382]: use of moved value: `v1`
 --&gt; src/main.rs:4:10
  |
2 |     let v1 = vec![1, 2, 3];
  |         -- move occurs because `v1` has type `Vec&lt;i32&gt;`, which does not implement the `Copy` trait
3 |     let v2 = v1;
  |              -- value moved here
4 |     dbg!(v1);
  |          ^^ value used here after move
</code></pre>
<p>Rust won&rsquo;t let us compile a program which violates the ownership rules like this.</p>
<p>The above example is of a move that occurs when assigning from one binding to another, but the same will happen if we passed into a function, for example</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">foo</span>(v: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span>) {   <span style="color:#75715e">// v is a vector of integers, ownership is transferred into the function from outside
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// the function is the owner of the data, so at the end of the function, the data is dropped
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
    foo(v); <span style="color:#75715e">// ownership is transferred into the function here
</span><span style="color:#75715e"></span>    dbg!(v);
}</code></pre></div>
<p>Will result in a similar compiler error as before:</p>
<pre><code>error[E0382]: use of moved value: `v`
 --&gt; src/main.rs:7:10
  |
5 |     let v = vec![1, 2, 3];
  |         - move occurs because `v` has type `Vec&lt;i32&gt;`, which does not implement the `Copy` trait
6 |     foo(v);
  |         - value moved here
7 |     dbg!(v);
  |          ^ value used here after move
</code></pre>
<h3 id="use-after-free">Use After Free<a hidden class="anchor" aria-hidden="true" href="#use-after-free">#</a></h3>
<p>In languages such as C++, there are no mechanisms which prevent a use after free error. For example the following code is completely valid</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SomeStruct</span>
{
    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> name;
};

SomeStruct<span style="color:#f92672">&amp;</span> allocAndReturn()
{
    SomeStruct s;
    s.name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello, World!&#34;</span>;
    <span style="color:#66d9ef">return</span> s;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    SomeStruct<span style="color:#f92672">&amp;</span> s <span style="color:#f92672">=</span> allocAndReturn();
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> s.name <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">// Boom!, we&#39;ve used an invalid reference
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}</code></pre></div>
<p>As the C++ compiler doesn&rsquo;t track ownership or lifetimes, it doesn&rsquo;t prevent the function from returning a reference to an object that then goes out of scope, then when it tries to access s.name the program segfaults.</p>
<p>Contrast this in Rust, where the compiler tracks lifetimes, it is able to detect a use after free and will fail to compile. If we attempt to return a reference to an object created in a function as in the above program, we won&rsquo;t be able to compile. As it&rsquo;s difficult to do the above function in Rust without delving into lifetime annotations, a smaller program demonstrates the same issue</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> {
        <span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>];
        <span style="color:#f92672">&amp;</span>v
    };
    dbg!(v);
}</code></pre></div>
<p>As Rust is an expression based language, we can create an arbitrary scope or code block that ends in an expression, and use that to assign to a binding, or anywhere else an expression is accepted.</p>
<p>In the code snippet, we are creating a vector v inside the block, and then trying to return a reference to it, out of the block and bind it to the outer v binding.</p>
<p>However Rust detects that we are trying to keep a reference for longer than the object is in scope and gives the following compiler error</p>
<pre><code>error[E0597]: `v` does not live long enough
 --&gt; src/main.rs:4:9
  |
2 |     let v = {
  |         - borrow later stored here
3 |         let v = vec![4, 5, 6];
4 |         &amp;v
  |         ^^ borrowed value does not live long enough
5 |     };
  |     - `v` dropped here while still borrowed
</code></pre>
<p>This is the Rust&rsquo;s borrow checker and lifetime rules at work.</p>
<h3 id="modification-while-reading">Modification While Reading<a hidden class="anchor" aria-hidden="true" href="#modification-while-reading">#</a></h3>
<p>In other languages, it&rsquo;s common for a mutable and immutable reference to exist at the same time. For example in C++ we may do the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">SomeStruct s;
<span style="color:#66d9ef">const</span> SomeStruct <span style="color:#f92672">&amp;</span>s1 <span style="color:#f92672">=</span> s;
SomeStruct<span style="color:#f92672">&amp;</span> s2 <span style="color:#f92672">=</span> s;</code></pre></div>
<p>The implications of this is that someone that is holding an immutable reference to an object will observe changes made to the object (through a mutable reference). This is contrary to what the definition should be of an immutable reference, the holder shouldn&rsquo;t see any changes as it&rsquo;s immutable.</p>
<p>If we attempt to do this in Rust, it will fail to compile as we cannot take a mutable and immutable reference at the same time (though we may take as many immutable references as we&rsquo;d like since none will observe any changes).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> v <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
    <span style="color:#66d9ef">let</span> v1 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>v;
    <span style="color:#66d9ef">let</span> v2 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> v;
    dbg!(v1);
}</code></pre></div>
<p>We are greeted with the following compile error</p>
<pre><code>error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:4:14
  |
3 |     let v1 = &amp;v;
  |              -- immutable borrow occurs here
4 |     let v2 = &amp;mut v;
  |              ^^^^^^ mutable borrow occurs here
5 |     dbg!(v1);
  |          -- immutable borrow later used here
</code></pre>
<p>Rust guarantees memory safety here by allowing either 0 or more immutable references OR 0 or 1 mutable reference. It is forbidden to have a mutable reference while ANY references are taken, and only 1 mutable reference can be taken at a time.</p>
<p>This means if you hold a mutable reference to an object, the compiler guarantees that <strong>only</strong> you can make changes to the object. It also guarantees that if you hold an immutable reference you will <strong>never</strong> see any state changes through that.</p>
<p>This isn&rsquo;t strictly true&hellip;.there are types in the standard library that allow for interior mutability, that is, mutating through an immutable reference. However, they are also perfectly safe to use because they perform the check at runtime instead. When using those types, you are only allowed to mutate a value if nothing else currently holds a borrow to it.</p>
<p>In conclusion, most programming languages have no real protections against multiple sources writing to an object, even when other sources have read-only access. Rust has a policy of only 1 writer at a time, and only when there are no readers in existence.</p>
<p>This does require some code restructuring to separate the reading from the writing, but results in much safer code and prevents common problems such as modifying a collection while iterating over it, which is impossible in Rust due to the borrow checker.</p>
<h3 id="thread-safety">Thread Safety<a hidden class="anchor" aria-hidden="true" href="#thread-safety">#</a></h3>
<p>The last topic on memory safety in Rust will be a few words on how the safety rules also apply in a multithreaded context.</p>
<p>Most languages don&rsquo;t have any guarantees about whether an object is safe to be accessed from multiple threads at a time, and if an object is not safe, but is accessed concurrently from 2 threads, this is called a data race, and is not a good thing.</p>
<p>Rust provides a system by which the compiler will fail to compile a program if we try to use a non thread-safe type in a multithreaded context.</p>
<p>The way it achieves this is by using two core traits called <strong>Send</strong> and <strong>Sync</strong></p>
<p>These are implemented (or not implemented) by types automatically based on the data inside the types. If all the members of a custom type are Send, or Sync then the type itself is Send or Sync.</p>
<p><strong>Send</strong> means that instances of this type can be transferred over to a different thread. This is transfer of ownership across a thread boundary.</p>
<p><strong>Sync</strong> means that instances of this type can be accessed from multiple threads at the same time, that is references to the instance are Send.</p>
<p>The developer <em>can</em> implement Send and Sync manually on types if those types aren&rsquo;t automatically deemed Send/Sync, however to do so is an unsafe operation as it requires that the developer has checked that the type is indeed thread-safe.</p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="https://forgottenmaster.github.io/">Robin Firth</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
