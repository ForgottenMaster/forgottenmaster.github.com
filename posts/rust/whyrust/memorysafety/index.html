<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Memory Safety | Robin Firth</title>
<meta name="keywords" content="" />
<meta name="description" content="Here we&rsquo;ll go over the memory model in Rust, along with the language design choices that allow for Rust to guarantee memory safety in any programs written using it. We will also be comparing Rust against C&#43;&#43; as they are both low level programming languages that are suitable for systems programming.
Memory guarantees The Rust language was designed with memory safety in mind and as such, the following guarantees are always true in a Rust program:">
<meta name="author" content="">
<link rel="canonical" href="https://forgottenmaster.github.io/posts/rust/whyrust/memorysafety/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.6f60056d44d3f7eb69a4bc6c332b59960f3a995802bded244750232f33713c49.css" integrity="sha256-b2AFbUTT9&#43;tppLxsMytZlg86mVgCve0kR1AjLzNxPEk=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js" integrity="sha256-uVus3DnjejMqn4g7Hni&#43;Srwf3KK8HyZB9V4809q9TWE="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://forgottenmaster.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://forgottenmaster.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://forgottenmaster.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://forgottenmaster.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://forgottenmaster.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.110.0">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta property="og:title" content="Memory Safety" />
<meta property="og:description" content="Here we&rsquo;ll go over the memory model in Rust, along with the language design choices that allow for Rust to guarantee memory safety in any programs written using it. We will also be comparing Rust against C&#43;&#43; as they are both low level programming languages that are suitable for systems programming.
Memory guarantees The Rust language was designed with memory safety in mind and as such, the following guarantees are always true in a Rust program:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://forgottenmaster.github.io/posts/rust/whyrust/memorysafety/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-15T01:31:14&#43;01:00" />
<meta property="article:modified_time" content="2021-10-15T01:31:14&#43;01:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Memory Safety"/>
<meta name="twitter:description" content="Here we&rsquo;ll go over the memory model in Rust, along with the language design choices that allow for Rust to guarantee memory safety in any programs written using it. We will also be comparing Rust against C&#43;&#43; as they are both low level programming languages that are suitable for systems programming.
Memory guarantees The Rust language was designed with memory safety in mind and as such, the following guarantees are always true in a Rust program:"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://forgottenmaster.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Rust",
      "item": "https://forgottenmaster.github.io/posts/rust/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Why Rust?",
      "item": "https://forgottenmaster.github.io/posts/rust/whyrust/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "Memory Safety",
      "item": "https://forgottenmaster.github.io/posts/rust/whyrust/memorysafety/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Memory Safety",
  "name": "Memory Safety",
  "description": "Here we\u0026rsquo;ll go over the memory model in Rust, along with the language design choices that allow for Rust to guarantee memory safety in any programs written using it. We will also be comparing Rust against C++ as they are both low level programming languages that are suitable for systems programming.\nMemory guarantees The Rust language was designed with memory safety in mind and as such, the following guarantees are always true in a Rust program:",
  "keywords": [
    
  ],
  "articleBody": "Here we’ll go over the memory model in Rust, along with the language design choices that allow for Rust to guarantee memory safety in any programs written using it. We will also be comparing Rust against C++ as they are both low level programming languages that are suitable for systems programming.\nMemory guarantees The Rust language was designed with memory safety in mind and as such, the following guarantees are always true in a Rust program:\nA value has only one owner in the code at a given time. When the owner of a value goes out of scope, the value is dropped. A value cannot be referenced after it’s dropped. A value cannot have ownership transferred while there are still references taken to it. A value can only be mutably referenced if there are no other references. In contrast, C++ guarantees the following:\nNo memory safety guarantees The design decisions taken by the Rust language team in developing the language mean that the following types of bugs don’t exist in Rust:\nUse after free Double free Modification while reading (e.g. changing collection while iterating) Data races (multiple threads accessing same memory location at the same time) Disclaimer Rust has a method to allow the developer to write unsafe code, and ensures that developers know exactly which portions of the code have been manually checked for correctness versus those portions of the code that have been determined to be correct by the compiler.\nWhen writing unsafe Rust, it is the developers responsibility to ensure that everything they do in that unsafe block upholds Rust’s memory safety guarantees. Safe Rust must be able to assume that unsafe Rust code blocks are correct.\nThe above memory safety guarantees therefore are only valid if all the unsafe code blocks are correct and also following the guarantees. It’s 100% possible to introduce the above behaviours and therefore undefined behaviour by abusing the powers granted by the unsafe keyword.\nThe problems in C++ and how to solve them As mentioned in the Memory guarantees section, Rust guarantees that invalid memory is never used, and also guarantees data races where one source can be writing to a memory location while another is reading from it (multiple readers is fine).\nThis section will go over the 4 big issues which the C++ compiler doesn’t do anything to help with, and how the Rust compiler will catch them.\n1. Use after free C++ #include using namespace std; int main() { string* s = new string{\"Hello, World!\"}; delete s; s-\u003epush_back('c'); return 0; }\nResult (runtime)\nRuntime error #stdin #stdout #stderr 0.01s 5436KB Rust fn main() { let mut s = String::from(\"Hello, World!\"); drop(s); s.push('c'); }\nResult (compile time)\nerror[E0382]: borrow of moved value: `s`\r--\u003e src/main.rs:4:5\r|\r2 | let mut s = String::from(\"Hello, World!\");\r| ----- move occurs because `s` has type `String`, which does not implement the `Copy` trait\r3 | drop(s);\r| - value moved here\r4 | s.push('c');\r| ^^^^^^^^^^^ value borrowed here after move 2. Double free C++ #include using namespace std; int main() { string* s = new string{\"Hello, World!\"}; delete s; delete s; return 0; }\nResult (runtime)\nRuntime error #stdin #stdout #stderr 0.01s 5432KB Rust fn main() { let s = String::from(\"Hello, World!\"); drop(s); drop(s); }\nResult (compile time)\nerror[E0382]: use of moved value: `s`\r--\u003e src/main.rs:4:10\r|\r2 | let s = String::from(\"Hello, World!\");\r| - move occurs because `s` has type `String`, which does not implement the `Copy` trait\r3 | drop(s);\r| - value moved here\r4 | drop(s);\r| ^ value used here after move 3. Modification while reading C++ #include #include using namespace std; int main() { vector\u003cint\u003e v; v.push_back(1); v.push_back(2); v.push_back(3); for (int\u0026 i : v) { v.reserve(10); // causes reallocation, while iterating over the vector cout \u003c\u003c i \u003c\u003c endl; } return 0; }\nResult (runtime)\nSuccess #stdin #stdout 0.01s 5516KB\r-1913700720\r21879\r-1913774064 Rust fn main() { let mut v = Vec::with_capacity(3); v.push(1); v.push(2); v.push(3); for i in \u0026v { v.reserve(10); println!(\"{i}\"); } }\nResult (compile time)\nerror[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable\r--\u003e src/main.rs:7:9\r|\r6 | for \u0026i in \u0026v {\r| --\r| |\r| immutable borrow occurs here\r| immutable borrow later used here\r7 | v.reserve(10);\r| ^^^^^^^^^^^^^ mutable borrow occurs here 4. Data races Rust prevents data races by using two marker interfaces which are automatically implemented for types that are safe to send to a different thread or to share between threads. When writing custom types that should be threadsafe using unsafe code, you may need to manually implement these to tell the compiler that it can assume that these are thread safe and that implementation was checked by the developer.\nFrom the point of view of safe Rust though, it can use these traits/interfaces to identify that all types being used in a multithreaded situation are in fact marked as being thread safe.\nThese traits are called Send and Sync.\nSend identifies a type as being safe to have its ownership transferred to another thread. Sync identifies a type as being safe to have references transferred to another thread.\nA type that is marked as Sync is essentially saying that it’s proven to be safe and correct to access the methods from multiple threads at the same time.\nThis kind of markup is something that C++ is missing. C++ allows any types to be used and accessed from multiple threads which results in potential data races as multiple threads write to the same memory location at the same time.\nBy allowing a method of flagging a type as being thread safe, and only allowing those types to be used in a multithreaded environment, the possibility of a data race is eliminated.\nThe example below does not compile because we’re trying to share an Rc (reference counted heap based ownership) between threads which is not flagged as thread safe because the reference count being used is not atomic:\nuse std::rc::Rc; use std::thread; fn main() { let v = Rc::new(42); thread::scope(|s| { s.spawn(|| println!(\"{}\", Rc::clone(\u0026v))); s.spawn(|| println!(\"{}\", Rc::clone(\u0026v))); }); } Results in the compiler error:\nerror[E0277]: `Rc` cannot be shared between threads safely\r--\u003e src/main.rs:7:17\r|\r7 | s.spawn(|| println!(\"{}\", Rc::clone(\u0026v)));\r| ----- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `Rc` cannot be shared between threads safely\r| |\r| required by a bound introduced by this call\r|\r= help: the trait `Sync` is not implemented for `Rc`\r= note: required for `\u0026Rc` to implement `Send` However, using an Arc (atomic reference counted heap allocated value) is thread safe, specifically because the reference count being used is atomic and thus safe for sending to multiple threads:\nuse std::sync::Arc; use std::thread; fn main() { let v = Arc::new(42); thread::scope(|s| { s.spawn(|| println!(\"{}\", Arc::clone(\u0026v))); s.spawn(|| println!(\"{}\", Arc::clone(\u0026v))); }); } We then get the correct output\n42\r42 ",
  "wordCount" : "1144",
  "inLanguage": "en",
  "datePublished": "2021-10-15T01:31:14+01:00",
  "dateModified": "2021-10-15T01:31:14+01:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://forgottenmaster.github.io/posts/rust/whyrust/memorysafety/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Robin Firth",
    "logo": {
      "@type": "ImageObject",
      "url": "https://forgottenmaster.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://forgottenmaster.github.io/" accesskey="h" title="Robin Firth (Alt + H)">Robin Firth</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://forgottenmaster.github.io/resume/" title="Résumé">
                    <span>Résumé</span>
                </a>
            </li>
            <li>
                <a href="https://forgottenmaster.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://forgottenmaster.github.io/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://forgottenmaster.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/rust/">Rust</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/rust/whyrust/">Why Rust?</a></div>
    <h1 class="post-title">
      Memory Safety
    </h1>
    <div class="post-meta"><span title='2021-10-15 01:31:14 +0100 BST'>October 15, 2021</span>&nbsp;·&nbsp;6 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#memory-guarantees" aria-label="Memory guarantees">Memory guarantees</a></li>
                <li>
                    <a href="#disclaimer" aria-label="Disclaimer">Disclaimer</a></li>
                <li>
                    <a href="#the-problems-in-c-and-how-to-solve-them" aria-label="The problems in C&#43;&#43; and how to solve them">The problems in C++ and how to solve them</a><ul>
                        
                <li>
                    <a href="#1-use-after-free" aria-label="1. Use after free">1. Use after free</a></li>
                <li>
                    <a href="#2-double-free" aria-label="2. Double free">2. Double free</a></li>
                <li>
                    <a href="#3-modification-while-reading" aria-label="3. Modification while reading">3. Modification while reading</a></li>
                <li>
                    <a href="#4-data-races" aria-label="4. Data races">4. Data races</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Here we&rsquo;ll go over the memory model in Rust, along with the language design choices that allow for Rust to guarantee memory safety in any programs written using it. We will also be comparing Rust against C++ as they are both low level programming languages that are suitable for systems programming.</p>
<h1 id="memory-guarantees">Memory guarantees<a hidden class="anchor" aria-hidden="true" href="#memory-guarantees">#</a></h1>
<p>The Rust language was designed with memory safety in mind and as such, the following guarantees are <strong>always</strong> true in a Rust program:</p>
<ol>
<li>A value has only one owner in the code at a given time.</li>
<li>When the owner of a value goes out of scope, the value is dropped.</li>
<li>A value cannot be referenced after it&rsquo;s dropped.</li>
<li>A value cannot have ownership transferred while there are still references taken to it.</li>
<li>A value can only be mutably referenced if there are no other references.</li>
</ol>
<p>In contrast, C++ guarantees the following:</p>
<ul>
<li>No memory safety guarantees</li>
</ul>
<p>The design decisions taken by the Rust language team in developing the language mean that the following types of bugs don&rsquo;t exist in Rust:</p>
<ol>
<li>Use after free</li>
<li>Double free</li>
<li>Modification while reading (e.g. changing collection while iterating)</li>
<li>Data races (multiple threads accessing same memory location at the same time)</li>
</ol>
<h1 id="disclaimer">Disclaimer<a hidden class="anchor" aria-hidden="true" href="#disclaimer">#</a></h1>
<p>Rust has a method to allow the developer to write unsafe code, and ensures that developers know exactly which portions of the code have been manually checked for correctness versus those portions of the code that have been determined to be correct by the compiler.</p>
<p>When writing unsafe Rust, it is the developers responsibility to ensure that everything they do in that unsafe block upholds Rust&rsquo;s memory safety guarantees. Safe Rust must be able to assume that unsafe Rust code blocks are correct.</p>
<p>The above memory safety guarantees therefore are only valid if all the unsafe code blocks are correct and also following the guarantees. It&rsquo;s 100% possible to introduce the above behaviours and therefore undefined behaviour by abusing the powers granted by the unsafe keyword.</p>
<h1 id="the-problems-in-c-and-how-to-solve-them">The problems in C++ and how to solve them<a hidden class="anchor" aria-hidden="true" href="#the-problems-in-c-and-how-to-solve-them">#</a></h1>
<p>As mentioned in the Memory guarantees section, Rust guarantees that invalid memory is never used, and also guarantees data races where one source can be writing to a memory location while another is reading from it (multiple readers is fine).</p>
<p>This section will go over the 4 big issues which the C++ compiler doesn&rsquo;t do anything to help with, and how the Rust compiler will catch them.</p>
<h2 id="1-use-after-free">1. Use after free<a hidden class="anchor" aria-hidden="true" href="#1-use-after-free">#</a></h2>
<p>C++
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	string<span style="color:#f92672">*</span> s <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> string{<span style="color:#e6db74">&#34;Hello, World!&#34;</span>};
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">delete</span> s;
</span></span><span style="display:flex;"><span>	s<span style="color:#f92672">-&gt;</span>push_back(<span style="color:#e6db74">&#39;c&#39;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></p>
<p>Result (runtime)</p>
<pre tabindex="0"><code>Runtime error #stdin #stdout #stderr 0.01s 5436KB
</code></pre><p>Rust
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> s <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Hello, World!&#34;</span>);
</span></span><span style="display:flex;"><span>    drop(s);
</span></span><span style="display:flex;"><span>    s.push(<span style="color:#e6db74">&#39;c&#39;</span>);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></p>
<p>Result (compile time)</p>
<pre tabindex="0"><code>error[E0382]: borrow of moved value: `s`
 --&gt; src/main.rs:4:5
  |
2 |     let mut s = String::from(&#34;Hello, World!&#34;);
  |         ----- move occurs because `s` has type `String`, which does not implement the `Copy` trait
3 |     drop(s);
  |          - value moved here
4 |     s.push(&#39;c&#39;);
  |     ^^^^^^^^^^^ value borrowed here after move
</code></pre><h2 id="2-double-free">2. Double free<a hidden class="anchor" aria-hidden="true" href="#2-double-free">#</a></h2>
<p>C++
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	string<span style="color:#f92672">*</span> s <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> string{<span style="color:#e6db74">&#34;Hello, World!&#34;</span>};
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">delete</span> s;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">delete</span> s;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></p>
<p>Result (runtime)</p>
<pre tabindex="0"><code>Runtime error #stdin #stdout #stderr 0.01s 5432KB
</code></pre><p>Rust
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Hello, World!&#34;</span>);
</span></span><span style="display:flex;"><span>    drop(s);
</span></span><span style="display:flex;"><span>    drop(s);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></p>
<p>Result (compile time)</p>
<pre tabindex="0"><code>error[E0382]: use of moved value: `s`
 --&gt; src/main.rs:4:10
  |
2 |     let s = String::from(&#34;Hello, World!&#34;);
  |         - move occurs because `s` has type `String`, which does not implement the `Copy` trait
3 |     drop(s);
  |          - value moved here
4 |     drop(s);
  |          ^ value used here after move
</code></pre><h2 id="3-modification-while-reading">3. Modification while reading<a hidden class="anchor" aria-hidden="true" href="#3-modification-while-reading">#</a></h2>
<p>C++
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v;
</span></span><span style="display:flex;"><span>	v.push_back(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	v.push_back(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>	v.push_back(<span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> i : v)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		v.reserve(<span style="color:#ae81ff">10</span>); <span style="color:#75715e">// causes reallocation, while iterating over the vector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		cout <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></p>
<p>Result (runtime)</p>
<pre tabindex="0"><code>Success #stdin #stdout 0.01s 5516KB
-1913700720
21879
-1913774064
</code></pre><p>Rust
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> v <span style="color:#f92672">=</span> Vec::with_capacity(<span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>    v.push(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    v.push(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    v.push(<span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#f92672">&amp;</span>v {
</span></span><span style="display:flex;"><span>        v.reserve(<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;{i}&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></p>
<p>Result (compile time)</p>
<pre tabindex="0"><code>error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:7:9
  |
6 |     for &amp;i in &amp;v {
  |               --
  |               |
  |               immutable borrow occurs here
  |               immutable borrow later used here
7 |         v.reserve(10);
  |         ^^^^^^^^^^^^^ mutable borrow occurs here
</code></pre><h2 id="4-data-races">4. Data races<a hidden class="anchor" aria-hidden="true" href="#4-data-races">#</a></h2>
<p>Rust prevents data races by using two marker interfaces which are automatically implemented for types that are safe to send to a different thread or to share between threads. When writing custom types that should be threadsafe using <strong>unsafe</strong> code, you may need to manually implement these to tell the compiler that it can assume that these are thread safe and that implementation was checked by the developer.</p>
<p>From the point of view of safe Rust though, it can use these traits/interfaces to identify that all types being used in a multithreaded situation are in fact marked as being thread safe.</p>
<p>These traits are called Send and Sync.</p>
<p><strong>Send</strong> identifies a type as being safe to have its ownership transferred to another thread.
<strong>Sync</strong> identifies a type as being safe to have <em>references</em> transferred to another thread.</p>
<p>A type that is marked as Sync is essentially saying that it&rsquo;s proven to be safe and correct to access the methods from multiple threads at the same time.</p>
<p>This kind of markup is something that C++ is missing. C++ allows any types to be used and accessed from multiple threads which results in potential data races as multiple threads write to the same memory location at the same time.</p>
<p>By allowing a method of flagging a type as being thread safe, and only allowing those types to be used in a multithreaded environment, the possibility of a data race is eliminated.</p>
<p>The example below does not compile because we&rsquo;re trying to share an Rc (reference counted heap based ownership) between threads which is not flagged as thread safe because the reference count being used is not atomic:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::rc::Rc;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::thread;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> Rc::new(<span style="color:#ae81ff">42</span>);
</span></span><span style="display:flex;"><span>    thread::scope(<span style="color:#f92672">|</span>s<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>        s.spawn(<span style="color:#f92672">||</span> println!(<span style="color:#e6db74">&#34;{}&#34;</span>, Rc::clone(<span style="color:#f92672">&amp;</span>v)));
</span></span><span style="display:flex;"><span>        s.spawn(<span style="color:#f92672">||</span> println!(<span style="color:#e6db74">&#34;{}&#34;</span>, Rc::clone(<span style="color:#f92672">&amp;</span>v)));
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Results in the compiler error:</p>
<pre tabindex="0"><code>error[E0277]: `Rc&lt;i32&gt;` cannot be shared between threads safely
 --&gt; src/main.rs:7:17
  |
7 |         s.spawn(|| println!(&#34;{}&#34;, Rc::clone(&amp;v)));
  |           ----- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `Rc&lt;i32&gt;` cannot be shared between threads safely
  |           |
  |           required by a bound introduced by this call
  |
  = help: the trait `Sync` is not implemented for `Rc&lt;i32&gt;`
  = note: required for `&amp;Rc&lt;i32&gt;` to implement `Send`
</code></pre><p>However, using an <strong>Arc</strong> (atomic reference counted heap allocated value) is thread safe, specifically because the reference count being used is atomic and thus safe for sending to multiple threads:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::sync::Arc;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::thread;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> Arc::new(<span style="color:#ae81ff">42</span>);
</span></span><span style="display:flex;"><span>    thread::scope(<span style="color:#f92672">|</span>s<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>        s.spawn(<span style="color:#f92672">||</span> println!(<span style="color:#e6db74">&#34;{}&#34;</span>, Arc::clone(<span style="color:#f92672">&amp;</span>v)));
</span></span><span style="display:flex;"><span>        s.spawn(<span style="color:#f92672">||</span> println!(<span style="color:#e6db74">&#34;{}&#34;</span>, Arc::clone(<span style="color:#f92672">&amp;</span>v)));
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>We then get the correct output</p>
<pre tabindex="0"><code>42
42
</code></pre>

  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://forgottenmaster.github.io/">Robin Firth</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
