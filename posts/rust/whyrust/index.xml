<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Why Rust? on Robin Firth</title>
    <link>https://forgottenmaster.github.io/posts/rust/whyrust/</link>
    <description>Recent content in Why Rust? on Robin Firth</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <lastBuildDate>Sun, 26 Sep 2021 17:10:58 +0100</lastBuildDate><atom:link href="https://forgottenmaster.github.io/posts/rust/whyrust/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introduction</title>
      <link>https://forgottenmaster.github.io/posts/rust/whyrust/introduction/</link>
      <pubDate>Sun, 26 Sep 2021 17:11:38 +0100</pubDate>
      
      <guid>https://forgottenmaster.github.io/posts/rust/whyrust/introduction/</guid>
      <description>This series of posts is intended to be a set of reasons I love using the Rust programming language. This isn&amp;rsquo;t a statement to say that you should use it, but hopefully it can bring some light on the differences between languages such as C++/C# and Rust, and show what Rust could bring to the table.
Each post will just be a self-contained entry about a single feature of Rust that I appreciate, so feel free to flick through as needed.</description>
    </item>
    
    <item>
      <title>Enums</title>
      <link>https://forgottenmaster.github.io/posts/rust/whyrust/enums/</link>
      <pubDate>Sun, 26 Sep 2021 17:14:48 +0100</pubDate>
      
      <guid>https://forgottenmaster.github.io/posts/rust/whyrust/enums/</guid>
      <description>C Style Enums In C#, C++, and a lot of other popular programming languages, we have access to a type called an &amp;ldquo;enumeration&amp;rdquo; (or enum for short). This is simply a type safe collection of named constant values.
For example in C++, making an enum whose variants represent a set of allowed colors for a hypothetical UI framework could be written as (with the values of the variants explicitly typed out for transparency):</description>
    </item>
    
    <item>
      <title>Memory Safety</title>
      <link>https://forgottenmaster.github.io/posts/rust/whyrust/memorysafety/</link>
      <pubDate>Fri, 15 Oct 2021 01:31:14 +0100</pubDate>
      
      <guid>https://forgottenmaster.github.io/posts/rust/whyrust/memorysafety/</guid>
      <description>Move By Default In most programming languages, there is no one true &amp;ldquo;owner&amp;rdquo; of any given piece of data. Data can be allocated on the stack or the heap but references to it can be passed around as needed. There isn&amp;rsquo;t a way of the compiler to track ownership of a piece of data in most languages such as C++.
Additionally expensive copies of structures may be done without us realising, or being able to opt out of it.</description>
    </item>
    
    <item>
      <title>Traits</title>
      <link>https://forgottenmaster.github.io/posts/rust/whyrust/traits/</link>
      <pubDate>Sat, 23 Oct 2021 09:55:16 +0100</pubDate>
      
      <guid>https://forgottenmaster.github.io/posts/rust/whyrust/traits/</guid>
      <description>What are traits? Traits in Rust can basically be thought of as interfaces in C#. They can do everything that a C# interface can do except with a few more capabilities. We will start off by equating the common functionality of traits in Rust with C# interfaces, and then explore the additional capabilities we get with Rust traits.
Describes capabilities In C# interfaces, we can describe a set of function signatures which will tell the user the capabilities of that interface, such that they know when they call something what data to pass in, and what they should get back.</description>
    </item>
    
  </channel>
</rss>
