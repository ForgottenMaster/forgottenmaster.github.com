<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Traits | Robin Firth</title>
<meta name="keywords" content="" />
<meta name="description" content="What are traits? Traits in Rust can basically be thought of as interfaces in C#. They can do everything that a C# interface can do except with a few more capabilities. We will start off by equating the common functionality of traits in Rust with C# interfaces, and then explore the additional capabilities we get with Rust traits.
Describes capabilities In C# interfaces, we can describe a set of function signatures which will tell the user the capabilities of that interface, such that they know when they call something what data to pass in, and what they should get back.">
<meta name="author" content="">
<link rel="canonical" href="https://forgottenmaster.github.io/posts/rust/whyrust/traits/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.6f60056d44d3f7eb69a4bc6c332b59960f3a995802bded244750232f33713c49.css" integrity="sha256-b2AFbUTT9&#43;tppLxsMytZlg86mVgCve0kR1AjLzNxPEk=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://forgottenmaster.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://forgottenmaster.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://forgottenmaster.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://forgottenmaster.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://forgottenmaster.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.92.2" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta property="og:title" content="Traits" />
<meta property="og:description" content="What are traits? Traits in Rust can basically be thought of as interfaces in C#. They can do everything that a C# interface can do except with a few more capabilities. We will start off by equating the common functionality of traits in Rust with C# interfaces, and then explore the additional capabilities we get with Rust traits.
Describes capabilities In C# interfaces, we can describe a set of function signatures which will tell the user the capabilities of that interface, such that they know when they call something what data to pass in, and what they should get back." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://forgottenmaster.github.io/posts/rust/whyrust/traits/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-23T09:55:16&#43;01:00" />
<meta property="article:modified_time" content="2021-10-23T09:55:16&#43;01:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Traits"/>
<meta name="twitter:description" content="What are traits? Traits in Rust can basically be thought of as interfaces in C#. They can do everything that a C# interface can do except with a few more capabilities. We will start off by equating the common functionality of traits in Rust with C# interfaces, and then explore the additional capabilities we get with Rust traits.
Describes capabilities In C# interfaces, we can describe a set of function signatures which will tell the user the capabilities of that interface, such that they know when they call something what data to pass in, and what they should get back."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://forgottenmaster.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Rust",
      "item": "https://forgottenmaster.github.io/posts/rust/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Why Rust?",
      "item": "https://forgottenmaster.github.io/posts/rust/whyrust/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "Traits",
      "item": "https://forgottenmaster.github.io/posts/rust/whyrust/traits/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Traits",
  "name": "Traits",
  "description": "What are traits? Traits in Rust can basically be thought of as interfaces in C#. They can do everything that a C# interface can do except with a few more capabilities. We will start off by equating the common functionality of traits in Rust with C# interfaces, and then explore the additional capabilities we get with Rust traits.\nDescribes capabilities In C# interfaces, we can describe a set of function signatures which will tell the user the capabilities of that interface, such that they know when they call something what data to pass in, and what they should get back.",
  "keywords": [
    
  ],
  "articleBody": "What are traits? Traits in Rust can basically be thought of as interfaces in C#. They can do everything that a C# interface can do except with a few more capabilities. We will start off by equating the common functionality of traits in Rust with C# interfaces, and then explore the additional capabilities we get with Rust traits.\nDescribes capabilities In C# interfaces, we can describe a set of function signatures which will tell the user the capabilities of that interface, such that they know when they call something what data to pass in, and what they should get back. The caller need not know how the function is implemented by a specific type, just that it does what is described on the tin.\nFor example, a C# interface which provides the capability to get an identifier through a GetIdentifier function which takes no arguments, and returns the ID of the instance as an integer can look as follows:\ninterface IGetIdentifier { int GetIdentifier(); } In Rust we can describe the exact same functionality. Note however a few changes in order to follow naming conventions or required by the language syntax:\n interface keyword is renamed to trait In Rust, the naming convention for a trait that has a single method is just the name of the method itself Rust has sized integer types so int is replaced with i32 (can be any of the other integer types too) Rust requires each member function to take explicitly the object we’re calling on. This allows us to tell the compiler/caller whether we’re taking an immutable reference, mutable reference, or taking ownership. In this case we only need an immutable reference to get an identifier Rust naming convention for functions and variables is snake_case. Therefore GetIdentifier method is renamed get_identifer.  The equivalent Rust definition is therefore:\ntrait GetIdentifier { fn get_identifier(\u0026self) - i32; } Generics In C# we are also able to make an interface generic. This is useful if we need to implement an interface multiple times for a given type for different situations. We can’t implement the same interface multiple times, but each different set of generic parameters is essentially a different interface.\nLet’s say we extend the above interface to work for any identifier type and not just integers. The C# snippet would be extended to look as follows:\ninterface IGetIdentifier { T GetIdentifier(); } Likewise, the Rust snippet is extended with the exact same syntax:\ntrait GetIdentifierT { fn get_identifier(\u0026self) - T; } Bounded generics This is the ability to constrain generic parameter types to ones that only implement certain interfaces. In C# we have the ability to constrain based on interface or base class type, however in Rust we don’t have struct inheritance but do have trait inheritance. As a result, in Rust we can only constrain on interface. But this is good practice anyways as inheritance of behaviour is better than inheritance of state.\nIn C# if we want to bound the above interface to only allow T’s that implement an “IIdentifier” interface, that is an interface that allows the type to be used as an identifier, would look like this:\ninterface IGetIdentfier where T : IIdentifier { T GetIdentifier(); } In Rust, we have two options for defining trait bounds, we can do it as above with a “where” syntax. This is useful when there are lots of bounds for a type and we can break them up over multiple lines which is more readable in most cases:\ntrait GetIdentifierT where T: Identifier { fn get_identifier(\u0026self) - T; } However we also have the ability to define these trait bounds inline, which for fewer trait bounds could be neater:\ntrait GetIdentifierT: Identifier { fn get_identifier(\u0026self) - T; } Default implementations Since C#8 we have the ability to provide default implementations for methods, to be used if the implementor doesn’t provide their own implementation. This lets us define some required methods that must be implemented, by not defining a default implementation, and provided methods (which can still be overridden, but don’t need to be) by giving a default.\nFor example in C#, if we assume that the definition of the “IIdentifier” interface is as follows:\ninterface Identifier { string GetString(); } Then we can add a provided method to the GetIdentifier interface which will print out the string identifier (note that we still require the GetIdentifier function to be implemented since there’s no possible way we can know how to get one). We get the resulting code:\ninterface IGetIdentifier where T: IIdentifier { T GetIdentifier(); void PrintIdentifier() { System.Console.WriteLine($\"{GetIdentifier().GetString()}\"); } } We can do the same in Rust too in the same way as the following code snippet shows:\ntrait GetIdentifierT: Identifier { fn get_identifier(\u0026self) - T; fn print_identifier(\u0026self) { println!(\"{}\", self.get_identifier().get_string()); } } Implementing We can of course implement an interface or trait in both C# and Rust (what use would an interface be if we couldn’t!?). However the syntax is different, and this is where we start to see C# and Rust diverge quite dramatically.\nIn C# we have to provide the implementation of the interface at the same point as we define the implementing class/struct itself. For example, implementing the IIdentifier interface for a struct Foo:\nstruct Foo : IIdentifier { public int identifier; public string GetString() = $\"{identifier}\"; } And implementing the IGetIdentifiertrait for a second struct FooGetter:\nstruct FooGetter : IGetIdentifier { public Foo identifier; public Foo GetIdentifier() = identifier; } In Rust however, the difference is that we define implementation blocks separate to the variables inside the struct itself. This allows us to break up behaviour/functions from the pure data contained in the structure. Each trait has its own implementation block so the implementation of the above structures and trait implementations will look as follows:\n#[derive(Clone)] struct Foo { pub i32 identifier; } impl Identifier for Foo { pub fn get_string(\u0026self) - String { format!(\"{}\", self.identifier) } } struct FooGetter { pub Foo identifier; } impl GetIdentifierFoo for FooGetter { pub fn get_identifier(\u0026self) - Foo { self.identifier.clone() } } Note the Clone implementation required on Foo, and the clone function call in get_identifier. This is required because in Rust every type is movable, and clones are explicit. Adding the #[derive(Clone)] attribute to the struct allows us to automatically derive a deep clone implementation as long as all the struct fields implement Clone.\nNote that this is not idiomatic Rust, clones are rarely used as we can pass references around safely and the compiler will check the ownership and lifetime rules for us.\nIs that it? So you might look at the previous content and think that Rust traits are just C# interfaces with a different syntax. They can do everything C# interfaces can do right?. Well, yes, except that there are more capabilities that Rust gives us that just aren’t possible in C#\nThe following few sections then will only contain Rust snippets as there’s no valid way to represent them in C# (or C++, or most languages I’ve used - except Haskell, which makes traits similar to typeclasses).\nAssociated Types In the above code snippets, we had a generic trait GetIdentifier which was implemented on FooGetter with the generic parameter Foo. However this opens the way for us to have multiple implementations on FooGetter with different types. However what if we want to force the user to define a maximum of 1 implementation of GetIdentifier?\nWell, we have to remove the generics, and we end up with a trait as follows:\ntrait GetIdentifier { fn get_identifier(\u0026self) - ??? // what type goes here? } However, we have a problem here since we don’t know what the actual identifier type is now for any given implementation. We’ve removed the ability to specify it in a generic parameter, so in C# the only way to do this would be to fix the concrete type we return. That means all implementors of GetIdentifier returns the same type.\nTechnically in C# we can do it by returning the IIdenfier interface itself:\ninterface IGetIdentifier { IIdentifier GetIdentifier(); } Which indeed will allow each implementor to determine what the actual type they’re returning is, as long as it implements the IIdenfier interface.\nThe downside here is that we are forced to box the result which means a heap allocation, which means garbage collector tracking overhead.\nWe can do the same thing in Rust, we have to be explicit about returning a dynamic trait object in a box though:\ntrait GetIdentifier { fn get_identifier(\u0026self) - Boxdyn Identifier; } However this still requires allocating heap storage and returning. An additional downside is type erasure. We’ve lost all information about the actual concrete type, all we know is the Box has an Identifier in it, so can only access the methods of the Identifier trait and nothing more.\nThere must be a better way!?. Enter associated types:\ntrait GetIdentifier { type IdentifierType: Identifier; fn get_identifier(\u0026self) - Self::IdentifierType; fn print_identifier(\u0026self) { println!(\"{}\", self.get_identifier().get_string()); } } Problems solved!. There’s a bit of new syntax here, but the main points are:\n We define an associated type on the trait with the type T syntax, allowing each implementor to specify a different concrete type We place a trait bound on it so that only concrete types implementing the Identifier trait can be used We return Self::IdentifierType from the get_identifier function. Importantly this is the concrete type, meaning no heap allocations and no type erasure  One further thing with associated types is that we can add trait bounds that force them to a specific concrete type. For example, say that we want to create a function that will take any GetIdentifier and print it, but only if the identifier type is an i32. We can do this as a trait bound with the following syntax:\nfn call_print_identifier_if_i32T: GetIdentifierIdentifierType = i32(t: \u0026T) { t.print_identifier(); } We can also even place trait bounds on associated types within trait bounds!. For example if we want a function that will accept any GetIdentifier, but only if the IdentifierType implements Clone, we can do so:\nfn do_somethingT(t: \u0026T) where T: GetIdentifier, T as GetIdentifier::IdentifierType: Clone { let c = t.get_identifier().clone(); // do something with cloned instance } Associated methods Unlike C# (and most other languages) interfaces which can only define methods tied to the specific instance of the implementing type, due to requiring dynamic dispatch and using a vtable, in Rust we can also define methods at the type level. These would be called static methods in other languages but in Rust, they are known as associated methods.\nA simple example of a trait making use of this functionality is the Default trait in the standard library. If we were to define it ourselves, we can do it like this:\ntrait Default { fn default() - Self; } Self here is the implementing type, and notice how an associated method is indicated not by a keyword, but by the lack of self, \u0026self, or \u0026mut self in the first argument position.\nThese associated methods can be called with :: syntax, for example if our type Foo implements Default, we can call it as:\nlet default_foo = Foo::default(); Extension traits The next feature Rust provides us with respect to traits is as a side effect of having to implement them separate to the type we’re implementing on. This implies we can implement traits for types that we don’t actually own. This isn’t possible in C# or C++ where the implementation of a type is defined at the same time as the type itself.\nThis means that we are able to add functionality to existing types, even standard library types or primitive types by creating a trait and implementing it.\nFor example, say that we want to add a AsBytes trait which specifies that the type has a method called as_bytes which returns a vector of u8’s representing the bytes of the type.\nSuch a trait can be defined like:\ntrait AsBytes { fn as_bytes(\u0026self) - Vecu8; } And we can implement that for our own types, however, unlike in most other languages, we can implement this for existing types even primitives. For example on a u32:\nimpl AsBytes for u32 { fn as_bytes(\u0026self) - Vecu8 { self.to_le_bytes().to_vec() } } to_le_bytes is a function that the standard library provides for us, that will give us an array of u8’s of length 4 with the bytes of the u32 in it. We can call to_vec on this to turn it into a dynamically sized vector instead to return.\nBlanket implementations The final feature for traits that we have with Rust is the ability to implement a trait for all types, optionally bounded with trait bounds.\nLet’s say we want to add a method to all iterators which will result in a new iterator that prints out the item (for all items that are displayable) as it iterates them.\nNote that we can do this with a map call to decorate a function, taking the input, printing it and returning it again to make a new iterator. This would look something like this:\nlet iter = (0..10).map(|elem| { println!(\"{}\", elem); elem }); However this requires the user to roll the function themselves to print and return, and is a bit unwieldy. What we’d like is:\nlet iter = (0..).print(); We can do this with a blanket implementation that adds this print function to all iterators. First we need a structure to wrap the iterator that will step through and do the printing:\nstruct PrintT { iterator: T } We will need to implement the Iterator trait here for the new structure, so that we can step over and print the elements. However we can only do this if the elements implement the Display trait. We can use trait bounds to ensure that:\n T is an Iterator The elements from T implement Display  This will look as follows:\nimplT: Iterator Iterator for PrintT where T as Iterator::Item: Display { type Item = T as Iterator::Item; // just passing the items through  fn next(\u0026mut self) - OptionSelf::Item { let item = self.iterator.next()?; println!(\"{}\", item); Some(item) } } The little ? syntax when we call the next function of the iterator we’re wrapping is a little outside of the scope of the article, but the easiest way to think of it is if that call returns None, then we return None immediately. Otherwise item is set to the value inside the Some (which we then print and return).\nFinally we need to actually add the convenience function to all iterators. We can do this by creating an extension trait called IteratorPrint with the print function we want:\ntrait IteratorPrint where Self: Sized { fn print(self) - PrintSelf { Print { iterator: self } } } We need to specify Self: Sized because traits in Rust can be implemented even for dynamically sized types which can’t exist on their own and must be boxed or put behind a reference.\nSince we need to put self into the Print structure, it will need to have a compile time known size, so we specify we can only use it with such types.\nNow we have all the boilerplate setup, we can actually do the blanket implementation. We’ll add it only to compatible iterators, otherwise we end up with a more cryptic compile error. The actual final code for this is as follows:\nimplT: Iterator IteratorPrint for T where T as Iterator::Item: Display { } Then we can take any iterator that has elements that are displayable, and use this print function on it, even if we didn’t write the iterator type ourselves!. For example the following is valid:\n(0..10).print().for_each(|_| {}); The for_each call will just apply the closure to each element, in our case we just want to do nothing, but it will trigger the prints as it iterates.\n",
  "wordCount" : "2640",
  "inLanguage": "en",
  "datePublished": "2021-10-23T09:55:16+01:00",
  "dateModified": "2021-10-23T09:55:16+01:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://forgottenmaster.github.io/posts/rust/whyrust/traits/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Robin Firth",
    "logo": {
      "@type": "ImageObject",
      "url": "https://forgottenmaster.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://forgottenmaster.github.io/" accesskey="h" title="Robin Firth (Alt + H)">Robin Firth</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://forgottenmaster.github.io/resume/" title="Résumé">
                    <span>Résumé</span>
                </a>
            </li>
            <li>
                <a href="https://forgottenmaster.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://forgottenmaster.github.io/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://forgottenmaster.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/rust/">Rust</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/rust/whyrust/">Why Rust?</a></div>
    <h1 class="post-title">
      Traits
    </h1>
    <div class="post-meta"><span title='2021-10-23 09:55:16 +0100 BST'>October 23, 2021</span>&nbsp;·&nbsp;13 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#what-are-traits" aria-label="What are traits?">What are traits?</a></li>
                <li>
                    <a href="#describes-capabilities" aria-label="Describes capabilities">Describes capabilities</a></li>
                <li>
                    <a href="#generics" aria-label="Generics">Generics</a></li>
                <li>
                    <a href="#bounded-generics" aria-label="Bounded generics">Bounded generics</a></li>
                <li>
                    <a href="#default-implementations" aria-label="Default implementations">Default implementations</a></li>
                <li>
                    <a href="#implementing" aria-label="Implementing">Implementing</a></li>
                <li>
                    <a href="#is-that-it" aria-label="Is that it?">Is that it?</a></li>
                <li>
                    <a href="#associated-types" aria-label="Associated Types">Associated Types</a></li>
                <li>
                    <a href="#associated-methods" aria-label="Associated methods">Associated methods</a></li>
                <li>
                    <a href="#extension-traits" aria-label="Extension traits">Extension traits</a></li>
                <li>
                    <a href="#blanket-implementations" aria-label="Blanket implementations">Blanket implementations</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="what-are-traits">What are traits?<a hidden class="anchor" aria-hidden="true" href="#what-are-traits">#</a></h3>
<p>Traits in Rust can basically be thought of as interfaces in C#. They can do everything that a C# interface can do except with a few more capabilities. We will start off by equating the common functionality of traits in Rust with C# interfaces, and then explore the additional capabilities we get with Rust traits.</p>
<h3 id="describes-capabilities">Describes capabilities<a hidden class="anchor" aria-hidden="true" href="#describes-capabilities">#</a></h3>
<p>In C# interfaces, we can describe a set of function signatures which will tell the user the capabilities of that interface, such that they know when they call something what data to pass in, and what they should get back. The caller need not know how the function is implemented by a specific type, just that it does what is described on the tin.</p>
<p>For example, a C# interface which provides the capability to get an identifier through a GetIdentifier function which takes no arguments, and returns the ID of the instance as an integer can look as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#66d9ef">interface</span> IGetIdentifier
{
    <span style="color:#66d9ef">int</span> GetIdentifier();
}</code></pre></div>
<p>In Rust we can describe the exact same functionality. Note however a few changes in order to follow naming conventions or required by the language syntax:</p>
<ol>
<li>interface keyword is renamed to trait</li>
<li>In Rust, the naming convention for a trait that has a single method is just the name of the method itself</li>
<li>Rust has sized integer types so int is replaced with i32 (can be any of the other integer types too)</li>
<li>Rust requires each member function to take explicitly the object we&rsquo;re calling on. This allows us to tell the compiler/caller whether we&rsquo;re taking an immutable reference, mutable reference, or taking ownership. In this case we only need an immutable reference to get an identifier</li>
<li>Rust naming convention for functions and variables is snake_case. Therefore GetIdentifier method is renamed get_identifer.</li>
</ol>
<p>The equivalent Rust definition is therefore:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">trait</span> GetIdentifier {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_identifier</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">i32</span>;
}</code></pre></div>
<h3 id="generics">Generics<a hidden class="anchor" aria-hidden="true" href="#generics">#</a></h3>
<p>In C# we are also able to make an interface generic. This is useful if we need to implement an interface multiple times for a given type for different situations. We can&rsquo;t implement the same interface multiple times, but each different set of generic parameters is essentially a different interface.</p>
<p>Let&rsquo;s say we extend the above interface to work for any identifier type and not just integers. The C# snippet would be extended to look as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#66d9ef">interface</span> IGetIdentifier&lt;T&gt; 
{
    T GetIdentifier();
}</code></pre></div>
<p>Likewise, the Rust snippet is extended with the exact same syntax:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">trait</span> GetIdentifier<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_identifier</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">T</span>;
}</code></pre></div>
<h3 id="bounded-generics">Bounded generics<a hidden class="anchor" aria-hidden="true" href="#bounded-generics">#</a></h3>
<p>This is the ability to constrain generic parameter types to ones that only implement certain interfaces. In C# we have the ability to constrain based on interface or base class type, however in Rust we don&rsquo;t have struct inheritance but do have trait inheritance. As a result, in Rust we can only constrain on interface. But this is good practice anyways as inheritance of behaviour is better than inheritance of state.</p>
<p>In C# if we want to bound the above interface to only allow T&rsquo;s that implement an &ldquo;IIdentifier&rdquo; interface, that is an interface that allows the type to be used as an identifier, would look like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#66d9ef">interface</span> IGetIdentfier&lt;T&gt; <span style="color:#66d9ef">where</span> T : IIdentifier 
{
    T GetIdentifier();
}</code></pre></div>
<p>In Rust, we have two options for defining trait bounds, we can do it as above with a &ldquo;where&rdquo; syntax. This is useful when there are lots of bounds for a type and we can break them up over multiple lines which is more readable in most cases:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">trait</span> GetIdentifier<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
    <span style="color:#66d9ef">where</span> T: <span style="color:#a6e22e">Identifier</span> 
{
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_identifier</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">T</span>;
}</code></pre></div>
<p>However we also have the ability to define these trait bounds inline, which for fewer trait bounds could be neater:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">trait</span> GetIdentifier<span style="color:#f92672">&lt;</span>T: <span style="color:#a6e22e">Identifier</span><span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_identifier</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">T</span>;
}</code></pre></div>
<h3 id="default-implementations">Default implementations<a hidden class="anchor" aria-hidden="true" href="#default-implementations">#</a></h3>
<p>Since C#8 we have the ability to provide default implementations for methods, to be used if the implementor doesn&rsquo;t provide their own implementation. This lets us define some required methods that must be implemented, by not defining a default implementation, and provided methods (which can still be overridden, but don&rsquo;t need to be) by giving a default.</p>
<p>For example in C#, if we assume that the definition of the &ldquo;IIdentifier&rdquo; interface is as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#66d9ef">interface</span> Identifier
{
    <span style="color:#66d9ef">string</span> GetString();
}</code></pre></div>
<p>Then we can add a provided method to the GetIdentifier interface which will print out the string identifier (note that we still require the GetIdentifier function to be implemented since there&rsquo;s no possible way we can know how to get one). We get the resulting code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#66d9ef">interface</span> IGetIdentifier&lt;T&gt; <span style="color:#66d9ef">where</span> T: IIdentifier 
{
    T GetIdentifier();
    <span style="color:#66d9ef">void</span> PrintIdentifier()
    {
        System.Console.WriteLine(<span style="color:#e6db74">$&#34;{GetIdentifier().GetString()}&#34;</span>);
    }
}</code></pre></div>
<p>We can do the same in Rust too in the same way as the following code snippet shows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">trait</span> GetIdentifier<span style="color:#f92672">&lt;</span>T: <span style="color:#a6e22e">Identifier</span><span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_identifier</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">T</span>;
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">print_identifier</span>(<span style="color:#f92672">&amp;</span>self) {
        println!(<span style="color:#e6db74">&#34;{}&#34;</span>, self.get_identifier().get_string());
    }
}</code></pre></div>
<h3 id="implementing">Implementing<a hidden class="anchor" aria-hidden="true" href="#implementing">#</a></h3>
<p>We can of course implement an interface or trait in both C# and Rust (what use would an interface be if we couldn&rsquo;t!?). However the syntax is different, and this is where we start to see C# and Rust diverge quite dramatically.</p>
<p>In C# we have to provide the implementation of the interface at the same point as we define the implementing class/struct itself. For example, implementing the IIdentifier interface for a struct Foo:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Foo</span> : IIdentifier
{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> identifier;
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> GetString() =&gt; <span style="color:#e6db74">$&#34;{identifier}&#34;</span>;
}</code></pre></div>
<p>And implementing the IGetIdentifier<!-- raw HTML omitted --> trait for a second struct FooGetter:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">FooGetter</span> : IGetIdentifier&lt;Foo&gt; 
{
    <span style="color:#66d9ef">public</span> Foo identifier;
    <span style="color:#66d9ef">public</span> Foo GetIdentifier() =&gt; identifier;
}</code></pre></div>
<p>In Rust however, the difference is that we define implementation blocks separate to the variables inside the struct itself. This allows us to break up behaviour/functions from the pure data contained in the structure. Each trait has its own implementation block so the implementation of the above structures and trait implementations will look as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[derive(Clone)]</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Foo</span> {
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">i32</span> identifier;
}

<span style="color:#66d9ef">impl</span> Identifier <span style="color:#66d9ef">for</span> Foo {
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_string</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String {
        format!(<span style="color:#e6db74">&#34;{}&#34;</span>, self.identifier)
    }
}

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">FooGetter</span> {
    <span style="color:#66d9ef">pub</span> Foo identifier;
}

<span style="color:#66d9ef">impl</span> GetIdentifier<span style="color:#f92672">&lt;</span>Foo<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> FooGetter {
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_identifier</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">Foo</span> {
        self.identifier.clone()
    }
}</code></pre></div>
<p>Note the Clone implementation required on Foo, and the clone function call in get_identifier. This is required because in Rust every type is movable, and clones are explicit. Adding the #[derive(Clone)] attribute to the struct allows us to automatically derive a deep clone implementation as long as all the struct fields implement Clone.</p>
<p>Note that this is <strong>not</strong> idiomatic Rust, clones are rarely used as we can pass references around safely and the compiler will check the ownership and lifetime rules for us.</p>
<h3 id="is-that-it">Is that it?<a hidden class="anchor" aria-hidden="true" href="#is-that-it">#</a></h3>
<p>So you might look at the previous content and think that Rust traits <strong>are</strong> just C# interfaces with a different syntax. They can do everything C# interfaces can do right?. Well, yes, except that there are more capabilities that Rust gives us that just aren&rsquo;t possible in C#</p>
<p>The following few sections then will only contain Rust snippets as there&rsquo;s no valid way to represent them in C# (or C++, or most languages I&rsquo;ve used - except Haskell, which makes traits similar to typeclasses).</p>
<h3 id="associated-types">Associated Types<a hidden class="anchor" aria-hidden="true" href="#associated-types">#</a></h3>
<p>In the above code snippets, we had a generic trait GetIdentifier which was implemented on FooGetter with the generic parameter Foo. However this opens the way for us to have multiple implementations on FooGetter with different types. However what if we want to force the user to define a maximum of 1 implementation of GetIdentifier?</p>
<p>Well, we have to remove the generics, and we end up with a trait as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">trait</span> GetIdentifier {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_identifier</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#f92672">???</span> <span style="color:#75715e">// what type goes here?
</span><span style="color:#75715e"></span>}</code></pre></div>
<p>However, we have a problem here since we don&rsquo;t know what the actual identifier type is now for any given implementation. We&rsquo;ve removed the ability to specify it in a generic parameter, so in C# the only way to do this would be to fix the concrete type we return. That means all implementors of GetIdentifier returns the same type.</p>
<p>Technically in C# we can do it by returning the IIdenfier interface itself:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#66d9ef">interface</span> IGetIdentifier 
{
    IIdentifier GetIdentifier();
}</code></pre></div>
<p>Which indeed will allow each implementor to determine what the actual type they&rsquo;re returning is, as long as it implements the IIdenfier interface.</p>
<p>The downside here is that we are forced to box the result which means a heap allocation, which means garbage collector tracking overhead.</p>
<p>We can do the same thing in Rust, we have to be explicit about returning a dynamic trait object in a box though:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">trait</span> GetIdentifier {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_identifier</span>(<span style="color:#f92672">&amp;</span>self) -&gt; Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> Identifier<span style="color:#f92672">&gt;</span>;
}</code></pre></div>
<p>However this still requires allocating heap storage and returning. An additional downside is type erasure. We&rsquo;ve lost all information about the actual concrete type, all we know is the Box has an Identifier in it, so can only access the methods of the Identifier trait and nothing more.</p>
<p>There must be a better way!?. Enter associated types:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">trait</span> GetIdentifier {
    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">IdentifierType</span>: <span style="color:#a6e22e">Identifier</span>;
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_identifier</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">Self</span>::IdentifierType;
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">print_identifier</span>(<span style="color:#f92672">&amp;</span>self) {
        println!(<span style="color:#e6db74">&#34;{}&#34;</span>, self.get_identifier().get_string());
    }
}</code></pre></div>
<p>Problems solved!. There&rsquo;s a bit of new syntax here, but the main points are:</p>
<ol>
<li>We define an associated type on the trait with the <strong>type T</strong> syntax, allowing each implementor to specify a different <strong>concrete</strong> type</li>
<li>We place a trait bound on it so that only concrete types implementing the Identifier trait can be used</li>
<li>We return Self::IdentifierType from the get_identifier function. Importantly this is the <strong>concrete</strong> type, meaning no heap allocations and no type erasure</li>
</ol>
<p>One further thing with associated types is that we can add trait bounds that force them to a specific concrete type. For example, say that we want to create a function that will take any GetIdentifier and print it, but only if the identifier type is an i32. We can do this as a trait bound with the following syntax:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">call_print_identifier_if_i32</span><span style="color:#f92672">&lt;</span>T: <span style="color:#a6e22e">GetIdentifier</span><span style="color:#f92672">&lt;</span>IdentifierType <span style="color:#f92672">=</span> <span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;&gt;</span>(t: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">T</span>) {
    t.print_identifier();
}</code></pre></div>
<p>We can also even place trait bounds on associated types within trait bounds!. For example if we want a function that will accept any GetIdentifier, but only if the IdentifierType implements Clone, we can do so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">do_something</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(t: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">T</span>) 
<span style="color:#66d9ef">where</span> 
    T: <span style="color:#a6e22e">GetIdentifier</span>,
    <span style="color:#f92672">&lt;</span>T <span style="color:#66d9ef">as</span> GetIdentifier<span style="color:#f92672">&gt;</span>::IdentifierType: Clone
{
    <span style="color:#66d9ef">let</span> c <span style="color:#f92672">=</span> t.get_identifier().clone();
    <span style="color:#75715e">// do something with cloned instance
</span><span style="color:#75715e"></span>}</code></pre></div>
<h3 id="associated-methods">Associated methods<a hidden class="anchor" aria-hidden="true" href="#associated-methods">#</a></h3>
<p>Unlike C# (and most other languages) interfaces which can only define methods tied to the specific instance of the implementing type, due to requiring dynamic dispatch and using a vtable, in Rust we can also define methods at the type level. These would be called static methods in other languages but in Rust, they are known as associated methods.</p>
<p>A simple example of a trait making use of this functionality is the Default trait in the standard library. If we were to define it ourselves, we can do it like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">trait</span> Default {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">default</span>() -&gt; <span style="color:#a6e22e">Self</span>;
}</code></pre></div>
<p>Self here is the implementing type, and notice how an associated method is indicated not by a keyword, but by the lack of self, &amp;self, or &amp;mut self in the first argument position.</p>
<p>These associated methods can be called with :: syntax, for example if our type Foo implements Default, we can call it as:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> default_foo <span style="color:#f92672">=</span> Foo::default();</code></pre></div>
<h3 id="extension-traits">Extension traits<a hidden class="anchor" aria-hidden="true" href="#extension-traits">#</a></h3>
<p>The next feature Rust provides us with respect to traits is as a side effect of having to implement them separate to the type we&rsquo;re implementing on. This implies we can implement traits for types that we don&rsquo;t actually own. This isn&rsquo;t possible in C# or C++ where the implementation of a type is defined at the same time as the type itself.</p>
<p>This means that we are able to add functionality to existing types, even standard library types or primitive types by creating a trait and implementing it.</p>
<p>For example, say that we want to add a AsBytes trait which specifies that the type has a method called as_bytes which returns a vector of u8&rsquo;s representing the bytes of the type.</p>
<p>Such a trait can be defined like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">trait</span> AsBytes {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">as_bytes</span>(<span style="color:#f92672">&amp;</span>self) -&gt; Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span>;
}</code></pre></div>
<p>And we can implement that for our own types, however, unlike in most other languages, we can implement this for existing types even primitives. For example on a u32:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">impl</span> AsBytes <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">u32</span> {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">as_bytes</span>(<span style="color:#f92672">&amp;</span>self) -&gt; Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span> {
        self.to_le_bytes().to_vec()
    }
}</code></pre></div>
<p>to_le_bytes is a function that the standard library provides for us, that will give us an array of u8&rsquo;s of length 4 with the bytes of the u32 in it. We can call to_vec on this to turn it into a dynamically sized vector instead to return.</p>
<h3 id="blanket-implementations">Blanket implementations<a hidden class="anchor" aria-hidden="true" href="#blanket-implementations">#</a></h3>
<p>The final feature for traits that we have with Rust is the ability to implement a trait for all types, optionally bounded with trait bounds.</p>
<p>Let&rsquo;s say we want to add a method to <strong>all</strong> iterators which will result in a new iterator that prints out the item (for all items that are displayable) as it iterates them.</p>
<p>Note that we can do this with a map call to decorate a function, taking the input, printing it and returning it again to make a new iterator. This would look something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> iter <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">10</span>).map(<span style="color:#f92672">|</span>elem<span style="color:#f92672">|</span> {
    println!(<span style="color:#e6db74">&#34;{}&#34;</span>, elem);
    elem
});</code></pre></div>
<p>However this requires the user to roll the function themselves to print and return, and is a bit unwieldy. What we&rsquo;d like is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> iter <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>).print();</code></pre></div>
<p>We can do this with a blanket implementation that adds this print function to all iterators. First we need a structure to wrap the iterator that will step through and do the printing:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Print</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
    iterator: <span style="color:#a6e22e">T</span>
}</code></pre></div>
<p>We will need to implement the Iterator trait here for the new structure, so that we can step over and print the elements. However we can only do this if the elements implement the Display trait. We can use trait bounds to ensure that:</p>
<ol>
<li>T is an Iterator</li>
<li>The elements from T implement Display</li>
</ol>
<p>This will look as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T: Iterator<span style="color:#f92672">&gt;</span> Iterator <span style="color:#66d9ef">for</span> Print<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">where</span>
    <span style="color:#f92672">&lt;</span>T <span style="color:#66d9ef">as</span> Iterator<span style="color:#f92672">&gt;</span>::Item: <span style="color:#a6e22e">Display</span>
{
    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Item</span> <span style="color:#f92672">=</span> <span style="color:#f92672">&lt;</span>T <span style="color:#66d9ef">as</span> Iterator<span style="color:#f92672">&gt;</span>::Item; <span style="color:#75715e">// just passing the items through
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">next</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; Option<span style="color:#f92672">&lt;</span>Self::Item<span style="color:#f92672">&gt;</span> {
        <span style="color:#66d9ef">let</span> item <span style="color:#f92672">=</span> self.iterator.next()<span style="color:#f92672">?</span>;
        println!(<span style="color:#e6db74">&#34;{}&#34;</span>, item);
        Some(item)
    }
}</code></pre></div>
<p>The little ? syntax when we call the next function of the iterator we&rsquo;re wrapping is a little outside of the scope of the article, but the easiest way to think of it is if that call returns None, then we return None immediately. Otherwise item is set to the value inside the Some (which we then print and return).</p>
<p>Finally we need to actually add the convenience function to all iterators. We can do this by creating an extension trait called IteratorPrint with the print function we want:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">trait</span> IteratorPrint
<span style="color:#66d9ef">where</span> 
    Self: Sized 
{
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">print</span>(self) -&gt; <span style="color:#a6e22e">Print</span><span style="color:#f92672">&lt;</span>Self<span style="color:#f92672">&gt;</span> {
        Print {
            iterator: <span style="color:#a6e22e">self</span>
        }
    }
}</code></pre></div>
<p>We need to specify Self: Sized because traits in Rust can be implemented even for dynamically sized types which can&rsquo;t exist on their own and must be boxed or put behind a reference.</p>
<p>Since we need to put self into the Print structure, it will need to have a compile time known size, so we specify we can only use it with such types.</p>
<p>Now we have all the boilerplate setup, we can actually do the blanket implementation. We&rsquo;ll add it only to compatible iterators, otherwise we end up with a more cryptic compile error. The actual final code for this is as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T: Iterator<span style="color:#f92672">&gt;</span> IteratorPrint <span style="color:#66d9ef">for</span> T
<span style="color:#66d9ef">where</span>
    <span style="color:#f92672">&lt;</span>T <span style="color:#66d9ef">as</span> Iterator<span style="color:#f92672">&gt;</span>::Item: <span style="color:#a6e22e">Display</span>
{
}</code></pre></div>
<p>Then we can take <strong>any</strong> iterator that has elements that are displayable, and use this print function on it, even if we didn&rsquo;t write the iterator type ourselves!. For example the following is valid:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">(<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">10</span>).print().for_each(<span style="color:#f92672">|</span>_<span style="color:#f92672">|</span> {});</code></pre></div>
<p>The for_each call will just apply the closure to each element, in our case we just want to do nothing, but it will trigger the prints as it iterates.</p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://forgottenmaster.github.io/">Robin Firth</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
