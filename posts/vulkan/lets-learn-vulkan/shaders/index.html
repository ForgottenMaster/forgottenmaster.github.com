<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>6. Shaders | Robin Firth</title>
<meta name="keywords" content="" />
<meta name="description" content="Before we can set up the graphics pipeline we need to be able to render things to the surface, we need to be able to create shader modules, since shaders are going to do the work in a Vulkan application.
Shaders in Vulkan Unlike OpenGL which accepts shaders in source code form, a Vulkan application does not accept shader code in source code form but in a binary format known as SPIR-V.">
<meta name="author" content="">
<link rel="canonical" href="https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/shaders/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.6f60056d44d3f7eb69a4bc6c332b59960f3a995802bded244750232f33713c49.css" integrity="sha256-b2AFbUTT9&#43;tppLxsMytZlg86mVgCve0kR1AjLzNxPEk=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js" integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://forgottenmaster.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://forgottenmaster.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://forgottenmaster.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://forgottenmaster.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://forgottenmaster.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.96.0" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta property="og:title" content="6. Shaders" />
<meta property="og:description" content="Before we can set up the graphics pipeline we need to be able to render things to the surface, we need to be able to create shader modules, since shaders are going to do the work in a Vulkan application.
Shaders in Vulkan Unlike OpenGL which accepts shaders in source code form, a Vulkan application does not accept shader code in source code form but in a binary format known as SPIR-V." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/shaders/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-21T23:26:25&#43;00:00" />
<meta property="article:modified_time" content="2023-02-21T23:26:25&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="6. Shaders"/>
<meta name="twitter:description" content="Before we can set up the graphics pipeline we need to be able to render things to the surface, we need to be able to create shader modules, since shaders are going to do the work in a Vulkan application.
Shaders in Vulkan Unlike OpenGL which accepts shaders in source code form, a Vulkan application does not accept shader code in source code form but in a binary format known as SPIR-V."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://forgottenmaster.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Vulkan",
      "item": "https://forgottenmaster.github.io/posts/vulkan/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Let's Learn Vulkan",
      "item": "https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "6. Shaders",
      "item": "https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/shaders/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "6. Shaders",
  "name": "6. Shaders",
  "description": "Before we can set up the graphics pipeline we need to be able to render things to the surface, we need to be able to create shader modules, since shaders are going to do the work in a Vulkan application.\nShaders in Vulkan Unlike OpenGL which accepts shaders in source code form, a Vulkan application does not accept shader code in source code form but in a binary format known as SPIR-V.",
  "keywords": [
    
  ],
  "articleBody": "Before we can set up the graphics pipeline we need to be able to render things to the surface, we need to be able to create shader modules, since shaders are going to do the work in a Vulkan application.\nShaders in Vulkan Unlike OpenGL which accepts shaders in source code form, a Vulkan application does not accept shader code in source code form but in a binary format known as SPIR-V.\nThe Vulkan SDK contains a program which can be run to convert GLSL to SPIR-V however there are alternative programs that are able to convert GLSL and other languages to SPIR-V.\nThe advantages of Vulkan dealing directly with a binary format is that there is no parsing of source code text to be done at runtime, instead the Vulkan drivers can simply process the binary data which is much much faster.\nVertex shader We’ll write a basic vertex shader first of all, and place it at the path assets/shaders/triangle.vert.\nWe’ll write the source code in GLSL and then convert to SPIR-V. The first thing we need to do is identify the shader version we’re using, we’ll use shader version 4.5\n#version 450 We need to pass along a vertex color to the fragment shader, which we will do by specifying an “out parameter”. However, we are required to specify a numerical location for it, which is used to match up the out parameters with the identically named in parameters of the next shader in the pipeline.\nIn our case we’ll specify that we want a 3 component vector (for RGB) and it should have binding location 0\nlayout(location = 0) out vec3 fragColour; In a proper shader we’ll get the vertex positions and colors from attached buffers. However in order to get something rendering faster, we just hard code the vertex positions and colors into the shader\nvec3 positions[3] = vec3[](  vec3(0.0, -0.4, 0.0),  vec3(0.4, 0.4, 0.0),  vec3(-0.4, 0.4, 0.0) );  vec3 colours[3] = vec3[](  vec3(1.0, 0.0, 0.0),  vec3(0.0, 1.0, 0.0),  vec3(0.0, 0.0, 1.0) ); Finally we can define the main function which will do two things:\n Set the gl_Position property to the position for the vertex identified by gl_VertexIndex Set the out parameter fragColour with the color of the vertex identified by gl_VertexIndex  void main() {  gl_Position = vec4(positions[gl_VertexIndex], 1.0);  fragColour = colours[gl_VertexIndex]; } Fragment shader The fragment shader will be pretty simple, and will be located at assets/shaders/triangle.frag.\nAgain we define that we want shader version 4.5, but we won’t show that here for brevity.\nThe first thing we need is to make an in parameter with the same binding location as the out parameter from the vertex shader. To make things easier we’ll use the same name as well as was passed from the vertex shader\nlayout(location = 0) in vec3 fragColour; We also need to define an out parameter for the final fragment color, note that we can use the same binding location because the binding location is only used to pair up an out parameter from a shader to the in parameter with the same location in the next shader. In this case the in and out are in the same shader so they don’t conflict or pair up with each other\nlayout(location = 0) out vec4 outColour; Finally we can define the main function which is just gonna assign the fragment color from the in parameter to out parameter (adding in an alpha of 1)\nvoid main() {  outColour = vec4(fragColour, 1.0); } Compiling shaders with Naga As mentioned previously, the Vulkan SDK ships with a program to compile GLSL to SPIR-V, however it requires the developer to have the SDK installed. Additionally, if we ever wanted the end user to be able to modify and recompile the shaders on the target machine, we don’t want to force the Vulkan SDK to be installed.\nInstead, we can use the handy crate Naga which is able to take a few different input shader formats, and output a few different formats.\nIn our case we want to accept GLSL in, and output SPIR-V.\nFirst we can add the naga crate to our Cargo.toml. In our case, we will be compiling these shaders at build time with a build script, so we add it as a dev dependency\n[build-dependencies] naga = { version = \"0.11.0\", features = [\"glsl-in\", \"spv-out\"] } Naga requires that we enable the features for whichever source code we’re taking in, and whichever formats we’re producing (in our case we enable glsl-in, and spv-out).\nUsing Naga is actually quite easy, first of all we need to specify which type of shader we are parsing as options, which we can do, for example in the case of a vertex shader with the following\nlet options = Options::from(ShaderStage::Vertex); We then parse the source code into a module which is an intermediate format that can then be output to the various formats. This is just a case of passing the source along with the options\nlet module = parser.parse(\u0026options, \u0026source).unwrap(); We then need to validate the module is correct, which we can do with the validator type. This process also produces some information which we need for the compiling to SPIR-V\nlet info = Validator::new(ValidationFlags::all(), Capabilities::all())  .validate(\u0026module)  .unwrap(); We need to create storage for the SPIR-V output which outputs into a vector of u32’s…..so we’ll create this vector, along with the writer which will write the module out as SPIR-V\nlet mut words = vec![]; let mut writer = Writer::new(\u0026spv::Options::default()).unwrap(); Finally we just call the write method on the writer which will write the SPIR-V words out to the words vec\nwriter.write(\u0026module, \u0026info, None, \u0026mut words).unwrap(); Templating with tinytemplate Another tool we’ll make use of is the tinytemplate library which allows us to define a text template and then make substitutions of some context into it resulting in a final string.\nWe need the following crates:\n tinytemplate: This is the main crate that will perform the substitutions and render the final string serde: tinytemplate requires serde for serialization since it uses the serialized data for making substitutions serde_derive: Provides the Serialize derive we’ll use  We can add these into our Cargo.toml - again we’ll put these into build-dependencies as we won’t use them at runtime and are compiling our shaders at build time.\ntinytemplate = \"1.2.1\" serde_derive = \"1.0.152\" serde = \"1.0.152\" In order to use tinytemplate, we simply make a TinyTemplate object\nlet mut tt = TinyTemplate::new(); We then add a template string under a certain name\ntt.add_template(\"shaders\", TEMPLATE).unwrap(); We create a context structure, with contents applicable to the template we’re rendering, and for the actual rendering we just pass the context in, along with the name of the template we’re rendering\nlet code = tt.render(\"shaders\", \u0026context).unwrap(); Compiling the shaders Cargo, which is the official project tooling for Rust, supports having a build script that is run before the program itself is compiled.\nThese are often used to generate additional Rust code at build time that can be incorporated into regular Rust code during the build, or to compile C libraries that can be linked in.\nWe will use a build script to find all of the shaders (vertex and fragment only at the moment) in the assets/shaders directory, and compile them into SPIR-V. We’ll then bake the generated code into our build.\nMaking the build script The first step is to make a script named build.rs in the root of the Cargo project, which will be picked up automatically by Rust\nThe build script has a main function, same as a regular binary main file, however it’s run by Cargo at build time, and can issue directives to Cargo through printing to stdout.\nThe build script will be re-run when it’s changed but we can also tell it to re-run when other files have changed. In our case we want to re-run it whenever any of the shader files under our search path changes. We can do this with the following line\nprintln!(\"cargo:rerun-if-changed=\\\"assets/shaders\\\"\"); This has a few parts to it\n cargo: identifies this output as being a directive for Cargo rerun-if-changed is the directive which says to re-run the build script if the referenced file or files change =\"assets/shaders\" is our path. We have to escape the quote marks due to them being within a string already  Recursing the shader directory The first thing we’ll do inside this build script is initialise a stack for our recursion. Initially it’ll only have the assets/shaders path in it but as we find more directories to recurse into, we’ll push onto this\nlet prefix: PathBuf = \"assets/shaders\".into(); let mut paths: Vec_ = vec![prefix.clone()]; Secondly we’ll need a parser for Naga to use when we’re parsing our shader sources. We can re-use this parser between shaders for efficiency though. We’ll also allocate storage for the shader name/data\nlet mut parser = Parser::default(); let mut shaders = vec![]; For a recursive directory search, we’ll keep going while there’s more paths in our “paths” stack, and use fs::read_dir to get the information for files and subdirectories within that directory. This function gets us an iterator over all the files/directories there, so we iterate it\nwhile let Some(path) = paths.pop() {  if let Ok(files) = fs::read_dir(path) {  for file in files {  let file = file.unwrap();  // more code here  }  } } We can get the file type (directory, file, etc.), and the file path from this entry\nlet file_type = file.file_type().unwrap(); let file_path = file.path(); Now we check the file type. If it’s a directory, then we simply push it onto the stack for processing, if it’s a file though we’ll need to do more work\nif file_type.is_dir() {  paths.push(file_path); } else if file_type.is_file() {  if let Some(source) = read_and_compile_shader(file_path.clone(), \u0026mut parser) {  let shader_name = file_path  .strip_prefix(prefix.clone())  .unwrap()  .to_str()  .unwrap()  .replace('\\\\', \"/\");  let source = format!(\"{source:?}\");  shaders.push((shader_name, source));  } } What we do if it’s a file, is we pass it to our helper function read_and_compile_shader which attempts to parse the file as shader source and return the SPIR-V data. This function is optional, because the file could be not a shader, in which case it’s ignored.\nIf the conversion is successful then we take the file path, and rmeove the “assets/shaders” portion, so we get a relative path to that folder. We then replace any backslashes with forward slashes to standardise the path for our application code to correctly look up a shader.\nThe source is formatted as a string which will format it as a string like: \"[12, 13, 14, 42]\"\nFinally we push the shader name and source code string into the shaders list.\nBuilding the source code Once we’ve found all the shaders in our assets folder, and have our list of pairs, we can generate a Rust source file that will then be included into and built into our application.\nFor this we use tinytemplate as briefly mentioned in a previous section. However tinytemplate uses the { and } characters to identify substitutions into the template. This means we can’t use them to define our Rust function (I couldn’t find a way anyway), and instead have to substitute in those characters themselves.\nIn our template we call those open_brace and close_brace. Template is as follows\nconst TEMPLATE: \u0026str = \" fn get_compiled_shader_mapping() - ::std::collections::HashMap{open_brace} let mut hash_map = ::std::collections::HashMap::new(); {{ for shader in shaders }} {open_brace} const ARR: \u0026[u32] = \u0026{shader.1}; hash_map.insert(\\\"{shader.0}\\\", ARR); {close_brace} {{ endfor }} hash_map {close_brace} \"; This is generating a function called get_compiled_shader_mapping which builds and returns a HashMap linking the shader path (relative to assets/shaders) to the bytes of that shader.\nWe can see the following special commands in the template:\n {open_brace}: substitutes the “{” character {close_brace}: substitutes the “}” character {{for shader in shaders}}: A loop which runs the code until endfor, for every element of shaders (every pair) {{endfor}}: delimits the end of the section that is repeated in the for loop {shader.0}: this is the shader path {shader.1}: this is the stringified version of the SPIR-V array generated for that shader  We then go ahead and use tinytemplate to generate the final code\nlet mut tt = TinyTemplate::new(); tt.add_template(\"shaders\", TEMPLATE).unwrap(); let context = Context {  shaders,  open_brace: '{',  close_brace: '}', }; let code = tt.render(\"shaders\", \u0026context).unwrap(); The code generated with this template looks something like\nfn get_compiled_shader_mapping() - ::std::collections::HashMapstatic str, \u0026'static [u32] {  let mut hash_map = ::std::collections::HashMap::new();   {  const ARR: \u0026[u32] = \u0026[119734787, 65536, 28, 37, 0, 131089, 1, 393227, 1, 1280527431, 1685353262, 808793134, 0, 196622, 0, 1, 458767, 4, 31, 1852399981, 0, 26, 29, 196624, 31, 7, 327752, 9, 0, 35, 0, 262215, 26, 30, 0, 262215, 29, 30, 0, 131091, 2, 262165, 4, 32, 1, 262187, 4, 3, 0, 196630, 6, 32, 262187, 6, 5, 1065353216, 262167, 7, 6, 3, 262167, 8, 6, 4, 196638, 9, 8, 262176, 11, 6, 7, 196654, 7, 12, 327739, 11, 10, 6, 12, 262176, 14, 6, 8, 196654, 8, 15, 327739, 14, 13, 6, 15, 196641, 18, 2, 262176, 27, 1, 7, 262203, 27, 26, 1, 262176, 30, 3, 8, 262203, 30, 29, 3, 327734, 2, 17, 0, 18, 131320, 16, 131321, 19, 131320, 19, 262205, 7, 20, 10, 327761, 6, 21, 20, 0, 327761, 6, 22, 20, 1, 327761, 6, 23, 20, 2, 458832, 8, 24, 21, 22, 23, 5, 196670, 13, 24, 65789, 65592, 327734, 2, 31, 0, 18, 131320, 25, 262205, 7, 28, 26, 131321, 32, 131320, 32, 196670, 10, 28, 262201, 2, 33, 17, 262205, 8, 34, 13, 262224, 9, 35, 34, 327761, 8, 36, 35, 0, 196670, 29, 36, 65789, 65592];  hash_map.insert(\"triangle.frag\", ARR);  }   {  const ARR: \u0026[u32] = \u0026[119734787, 65536, 28, 83, 0, 131089, 1, 393227, 1, 1280527431, 1685353262, 808793134, 0, 196622, 0, 1, 524303, 0, 60, 1852399981, 0, 53, 56, 58, 262215, 14, 6, 16, 262215, 15, 6, 16, 327752, 17, 0, 35, 0, 327752, 17, 1, 35, 12, 262215, 53, 11, 42, 262215, 56, 30, 0, 262215, 58, 11, 0, 131091, 2, 262165, 4, 32, 1, 262187, 4, 3, 0, 262187, 4, 5, 3, 262165, 7, 32, 0, 262187, 7, 6, 3, 196630, 9, 32, 262187, 9, 8, 0, 262187, 9, 10, 1053609165, 262187, 9, 11, 3201092813, 262187, 9, 12, 1065353216, 262167, 13, 9, 3, 262172, 14, 13, 6, 196637, 15, 13, 262167, 16, 9, 4, 262174, 17, 13, 16, 393260, 13, 18, 8, 11, 8, 393260, 13, 19, 10, 10, 8, 393260, 13, 20, 11, 10, 8, 393260, 14, 21, 18, 19, 20, 393260, 13, 22, 12, 8, 8, 393260, 13, 23, 8, 12, 8, 393260, 13, 24, 8, 8, 12, 393260, 14, 25, 22, 23, 24, 262176, 27, 6, 13, 196654, 13, 28, 327739, 27, 26, 6, 28, 262176, 30, 6, 14, 327739, 30, 29, 6, 21, 327739, 30, 31, 6, 25, 262176, 33, 6, 16, 196654, 16, 34, 327739, 33, 32, 6, 34, 262176, 36, 6, 7, 196654, 7, 37, 327739, 36, 35, 6, 37, 196641, 40, 2, 262176, 54, 1, 7, 262203, 54, 53, 1, 262176, 57, 3, 13, 262203, 57, 56, 3, 262176, 59, 3, 16, 262203, 59, 58, 3, 262176, 78, 3, 9, 262187, 7, 79, 1, 327734, 2, 39, 0, 40, 131320, 38, 131321, 41, 131320, 41, 262205, 7, 42, 35, 327745, 27, 43, 29, 42, 262205, 13, 44, 43, 327761, 9, 45, 44, 0, 327761, 9, 46, 44, 1, 327761, 9, 47, 44, 2, 458832, 16, 48, 45, 46, 47, 12, 196670, 32, 48, 262205, 7, 49, 35, 327745, 27, 50, 31, 49, 262205, 13, 51, 50, 196670, 26, 51, 65789, 65592, 327734, 2, 60, 0, 40, 131320, 52, 262205, 7, 55, 53, 131321, 61, 131320, 61, 196670, 35, 55, 262271, 9, 62, 10, 393296, 13, 63, 8, 62, 8, 393296, 13, 64, 10, 10, 8, 262271, 9, 65, 10, 393296, 13, 66, 65, 10, 8, 393296, 14, 67, 63, 64, 66, 393296, 13, 68, 12, 8, 8, 393296, 13, 69, 8, 12, 8, 393296, 13, 70, 8, 8, 12, 393296, 14, 71, 68, 69, 70, 262201, 2, 72, 39, 262205, 13, 73, 26, 262205, 16, 74, 32, 327760, 17, 75, 73, 74, 327761, 13, 76, 75, 0, 196670, 56, 76, 327761, 16, 77, 75, 1, 196670, 58, 77, 327745, 78, 80, 58, 79, 262205, 9, 81, 80, 262271, 9, 82, 81, 196670, 80, 82, 65789, 65592];  hash_map.insert(\"triangle.vert\", ARR);  }   hash_map } Finally, we’ll write it out to file so it can be included later. Rust only supports writing build script output to the directory specified by the OUT_DIR environment variable. Rust gives us a way to get this through std::env::var, passing a key.\nWe can therefore write out this source code to a file called shaders.rs under that folder\nlet path = format!(\"{}/shaders.rs\", env::var(\"OUT_DIR\").unwrap()); fs::write(path, code).unwrap(); Compiling shader source As mentioned above, we use a file read_and_compile_shader to take a file path, and a Naga parser and read the source code as GLSL source if it can, outputting and returning the SPIR-V data.\nThe first steps are to get the file extension which will tell us whether it’s a vertex (.vert) or fragment shader (.frag), and also to read the text of the file\nlet extension = input_path.extension()?.to_str()?; let source = fs::read_to_string(\u0026input_path).ok()?; let options = match extension {  \"frag\" = Options::from(ShaderStage::Fragment),  \"vert\" = Options::from(ShaderStage::Vertex),  _ = return None, }; We then use the process of parsing the shader as GLSL into a Naga module, and then writing out to SPIR-V. We return the generated bytes\nlet module = parser.parse(\u0026options, \u0026source).ok()?; let info = Validator::new(ValidationFlags::all(), Capabilities::all())  .validate(\u0026module)  .ok()?; let mut words = vec![]; let mut writer = Writer::new(\u0026spv::Options::default()).ok()?; writer.write(\u0026module, \u0026info, None, \u0026mut words).ok()?; Some(words) Including shaders into application Our build script has now generated a Rust source code file with a function in it that when it’s called returns a HashMap of the shader names to code.\nWe can include this generated file into our build by adding the following to our main.rs file\ninclude!(concat!(env!(\"OUT_DIR\"), \"/shaders.rs\")); So this takes the environment variable corresponding to the OUT_DIR key, and appends the “/shaders.rs” to load the file at that path (concat! stitches the two strings together). include! then includes the contents of that file as Rust source code.\nMaking shader modules Now we have the SPIR-V data in our application, we can pass it to Vulkan to make a shader module that can be used.\nWe’ll make a simple wrapper function called create_shader_module and it’s called as such\nlet vertex_shader = create_shader_module(\u0026logical_device, shader_mapping[\"triangle.vert\"])?; let fragment_shader =  create_shader_module(\u0026logical_device, shader_mapping[\"triangle.frag\"])?; The function itself is pretty simple - there’s a create_shader_module on the logical device. The creation parameters only require the code slice to be constructed\nfn create_shader_module(device: \u0026Device, code: \u0026[u32]) - ResultShaderModule {  unsafe { device.create_shader_module(\u0026ShaderModuleCreateInfo::builder().code(code), None) }  .context(\"Error while creating a shader module.\") } We’ll change cleanup to take a slice of shader modules to destroy - and ensure they’re destroyed before the logical device\nfn cleanup(  instance: Instance,  device: Device,  debug_utils: DebugUtils,  messenger: DebugUtilsMessengerEXT,  surface_ext: Surface,  surface: SurfaceKHR,  swapchain_ext: Swapchain,  swapchain: SwapchainKHR,  swapchain_images: VecSwapchainImage,  shader_modules: \u0026[ShaderModule], ) {  unsafe {  for shader_module in shader_modules {  device.destroy_shader_module(*shader_module, None);  }  for swapchain_image in swapchain_images {  device.destroy_image_view(swapchain_image.image_view, None);  }  swapchain_ext.destroy_swapchain(swapchain, None);  device.destroy_device(None);  debug_utils.destroy_debug_utils_messenger(messenger, None);  surface_ext.destroy_surface(surface, None);  instance.destroy_instance(None);  } } ",
  "wordCount" : "3189",
  "inLanguage": "en",
  "datePublished": "2023-02-21T23:26:25Z",
  "dateModified": "2023-02-21T23:26:25Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/shaders/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Robin Firth",
    "logo": {
      "@type": "ImageObject",
      "url": "https://forgottenmaster.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://forgottenmaster.github.io/" accesskey="h" title="Robin Firth (Alt + H)">Robin Firth</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://forgottenmaster.github.io/resume/" title="Résumé">
                    <span>Résumé</span>
                </a>
            </li>
            <li>
                <a href="https://forgottenmaster.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://forgottenmaster.github.io/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://forgottenmaster.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/vulkan/">Vulkan</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/">Let&#39;s Learn Vulkan</a></div>
    <h1 class="post-title">
      6. Shaders
    </h1>
    <div class="post-meta"><span title='2023-02-21 23:26:25 +0000 UTC'>February 21, 2023</span>&nbsp;·&nbsp;15 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#shaders-in-vulkan" aria-label="Shaders in Vulkan">Shaders in Vulkan</a></li>
                <li>
                    <a href="#vertex-shader" aria-label="Vertex shader">Vertex shader</a></li>
                <li>
                    <a href="#fragment-shader" aria-label="Fragment shader">Fragment shader</a></li>
                <li>
                    <a href="#compiling-shaders-with-naga" aria-label="Compiling shaders with Naga">Compiling shaders with Naga</a></li>
                <li>
                    <a href="#templating-with-tinytemplate" aria-label="Templating with tinytemplate">Templating with tinytemplate</a></li>
                <li>
                    <a href="#compiling-the-shaders" aria-label="Compiling the shaders">Compiling the shaders</a><ul>
                        
                <li>
                    <a href="#making-the-build-script" aria-label="Making the build script">Making the build script</a></li>
                <li>
                    <a href="#recursing-the-shader-directory" aria-label="Recursing the shader directory">Recursing the shader directory</a></li>
                <li>
                    <a href="#building-the-source-code" aria-label="Building the source code">Building the source code</a></li>
                <li>
                    <a href="#compiling-shader-source" aria-label="Compiling shader source">Compiling shader source</a></li></ul>
                </li>
                <li>
                    <a href="#including-shaders-into-application" aria-label="Including shaders into application">Including shaders into application</a></li>
                <li>
                    <a href="#making-shader-modules" aria-label="Making shader modules">Making shader modules</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Before we can set up the graphics pipeline we need to be able to render things to the surface, we need to be able to create shader modules, since shaders are going to do the work in a Vulkan application.</p>
<h1 id="shaders-in-vulkan">Shaders in Vulkan<a hidden class="anchor" aria-hidden="true" href="#shaders-in-vulkan">#</a></h1>
<p>Unlike OpenGL which accepts shaders in source code form, a Vulkan application does not accept shader code in source code form but in a binary format known as <strong>SPIR-V</strong>.</p>
<p>The Vulkan SDK contains a program which can be run to convert GLSL to SPIR-V however there are alternative programs that are able to convert GLSL and other languages to SPIR-V.</p>
<p>The advantages of Vulkan dealing directly with a binary format is that there is no parsing of source code text to be done at runtime, instead the Vulkan drivers can simply process the binary data which is much much faster.</p>
<h1 id="vertex-shader">Vertex shader<a hidden class="anchor" aria-hidden="true" href="#vertex-shader">#</a></h1>
<p>We&rsquo;ll write a basic vertex shader first of all, and place it at the path <strong>assets/shaders/triangle.vert</strong>.</p>
<p>We&rsquo;ll write the source code in GLSL and then convert to SPIR-V. The first thing we need to do is identify the shader version we&rsquo;re using, we&rsquo;ll use shader version 4.5</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-glsl" data-lang="glsl"><span style="display:flex;"><span><span style="color:#75715e">#version 450</span></span></span></code></pre></div>
<p>We need to pass along a vertex color to the fragment shader, which we will do by specifying an &ldquo;out parameter&rdquo;. However, we are required to specify a numerical location for it, which is used to match up the out parameters with the identically named in parameters of the next shader in the pipeline.</p>
<p>In our case we&rsquo;ll specify that we want a 3 component vector (for RGB) and it should have binding location 0</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-glsl" data-lang="glsl"><span style="display:flex;"><span>layout(location <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">out</span> <span style="color:#66d9ef">vec3</span> fragColour;</span></span></code></pre></div>
<p>In a proper shader we&rsquo;ll get the vertex positions and colors from attached buffers. However in order to get something rendering faster, we just hard code the vertex positions and colors into the shader</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-glsl" data-lang="glsl"><span style="display:flex;"><span><span style="color:#66d9ef">vec3</span> positions[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> <span style="color:#66d9ef">vec3</span>[](
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">vec3</span>(<span style="color:#ae81ff">0.0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">0.4</span>, <span style="color:#ae81ff">0.0</span>),
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">vec3</span>(<span style="color:#ae81ff">0.4</span>, <span style="color:#ae81ff">0.4</span>, <span style="color:#ae81ff">0.0</span>),
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">vec3</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">0.4</span>, <span style="color:#ae81ff">0.4</span>, <span style="color:#ae81ff">0.0</span>)
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">vec3</span> colours[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> <span style="color:#66d9ef">vec3</span>[](
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">vec3</span>(<span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>),
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">vec3</span>(<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">0.0</span>),
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">vec3</span>(<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">1.0</span>)
</span></span><span style="display:flex;"><span>);</span></span></code></pre></div>
<p>Finally we can define the main function which will do two things:</p>
<ol>
<li>Set the gl_Position property to the position for the vertex identified by gl_VertexIndex</li>
<li>Set the out parameter fragColour with the color of the vertex identified by gl_VertexIndex</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-glsl" data-lang="glsl"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> main() {
</span></span><span style="display:flex;"><span>    gl_Position <span style="color:#f92672">=</span> <span style="color:#66d9ef">vec4</span>(positions[gl_VertexIndex], <span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>    fragColour <span style="color:#f92672">=</span> colours[gl_VertexIndex];
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h1 id="fragment-shader">Fragment shader<a hidden class="anchor" aria-hidden="true" href="#fragment-shader">#</a></h1>
<p>The fragment shader will be pretty simple, and will be located at <strong>assets/shaders/triangle.frag</strong>.</p>
<p>Again we define that we want shader version 4.5, but we won&rsquo;t show that here for brevity.</p>
<p>The first thing we need is to make an <strong>in</strong> parameter with the same binding location as the out parameter from the vertex shader. To make things easier we&rsquo;ll use the same name as well as was passed from the vertex shader</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-glsl" data-lang="glsl"><span style="display:flex;"><span>layout(location <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">vec3</span> fragColour;</span></span></code></pre></div>
<p>We also need to define an out parameter for the final fragment color, note that we can use the same binding location because the binding location is only used to pair up an out parameter from a shader to the in parameter with the same location in the next shader. In this case the in and out are in the same shader so they don&rsquo;t conflict or pair up with each other</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-glsl" data-lang="glsl"><span style="display:flex;"><span>layout(location <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">out</span> <span style="color:#66d9ef">vec4</span> outColour;</span></span></code></pre></div>
<p>Finally we can define the main function which is just gonna assign the fragment color from the in parameter to out parameter (adding in an alpha of 1)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-glsl" data-lang="glsl"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> main() {
</span></span><span style="display:flex;"><span>    outColour <span style="color:#f92672">=</span> <span style="color:#66d9ef">vec4</span>(fragColour, <span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h1 id="compiling-shaders-with-naga">Compiling shaders with Naga<a hidden class="anchor" aria-hidden="true" href="#compiling-shaders-with-naga">#</a></h1>
<p>As mentioned previously, the Vulkan SDK ships with a program to compile GLSL to SPIR-V, however it requires the developer to have the SDK installed. Additionally, if we ever wanted the end user to be able to modify and recompile the shaders on the target machine, we don&rsquo;t want to force the Vulkan SDK to be installed.</p>
<p>Instead, we can use the handy crate <a href="https://crates.io/crates/naga">Naga</a> which is able to take a few different input shader formats, and output a few different formats.</p>
<p>In our case we want to accept GLSL in, and output SPIR-V.</p>
<p>First we can add the naga crate to our Cargo.toml. In our case, we will be compiling these shaders at build time with a build script, so we add it as a dev dependency</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-toml" data-lang="toml"><span style="display:flex;"><span>[<span style="color:#a6e22e">build-dependencies</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">naga</span> = { <span style="color:#a6e22e">version</span> = <span style="color:#e6db74">&#34;0.11.0&#34;</span>, <span style="color:#a6e22e">features</span> = [<span style="color:#e6db74">&#34;glsl-in&#34;</span>, <span style="color:#e6db74">&#34;spv-out&#34;</span>] }</span></span></code></pre></div>
<p>Naga requires that we enable the features for whichever source code we&rsquo;re taking in, and whichever formats we&rsquo;re producing (in our case we enable glsl-in, and spv-out).</p>
<p>Using Naga is actually quite easy, first of all we need to specify which type of shader we are parsing as options, which we can do, for example in the case of a vertex shader with the following</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> options <span style="color:#f92672">=</span> Options::from(ShaderStage::Vertex);</span></span></code></pre></div>
<p>We then parse the source code into a <strong>module</strong> which is an intermediate format that can then be output to the various formats. This is just a case of passing the source along with the options</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> module <span style="color:#f92672">=</span> parser.parse(<span style="color:#f92672">&amp;</span>options, <span style="color:#f92672">&amp;</span>source).unwrap();</span></span></code></pre></div>
<p>We then need to validate the module is correct, which we can do with the validator type. This process also produces some information which we need for the compiling to SPIR-V</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> info <span style="color:#f92672">=</span> Validator::new(ValidationFlags::all(), Capabilities::all())
</span></span><span style="display:flex;"><span>    .validate(<span style="color:#f92672">&amp;</span>module)
</span></span><span style="display:flex;"><span>    .unwrap();</span></span></code></pre></div>
<p>We need to create storage for the SPIR-V output which outputs into a vector of u32&rsquo;s&hellip;..so we&rsquo;ll create this vector, along with the writer which will write the module out as SPIR-V</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> words <span style="color:#f92672">=</span> vec![];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> writer <span style="color:#f92672">=</span> Writer::new(<span style="color:#f92672">&amp;</span>spv::Options::default()).unwrap();</span></span></code></pre></div>
<p>Finally we just call the write method on the writer which will write the SPIR-V words out to the words vec</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>writer.write(<span style="color:#f92672">&amp;</span>module, <span style="color:#f92672">&amp;</span>info, None, <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> words).unwrap();</span></span></code></pre></div>
<h1 id="templating-with-tinytemplate">Templating with tinytemplate<a hidden class="anchor" aria-hidden="true" href="#templating-with-tinytemplate">#</a></h1>
<p>Another tool we&rsquo;ll make use of is the tinytemplate library which allows us to define a text template and then make substitutions of some context into it resulting in a final string.</p>
<p>We need the following crates:</p>
<ul>
<li><strong>tinytemplate</strong>: This is the main crate that will perform the substitutions and render the final string</li>
<li><strong>serde</strong>: tinytemplate requires serde for serialization since it uses the serialized data for making substitutions</li>
<li><strong>serde_derive</strong>: Provides the Serialize derive we&rsquo;ll use</li>
</ul>
<p>We can add these into our Cargo.toml - again we&rsquo;ll put these into build-dependencies as we won&rsquo;t use them at runtime and are compiling our shaders at build time.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-toml" data-lang="toml"><span style="display:flex;"><span><span style="color:#a6e22e">tinytemplate</span> = <span style="color:#e6db74">&#34;1.2.1&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">serde_derive</span> = <span style="color:#e6db74">&#34;1.0.152&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">serde</span> = <span style="color:#e6db74">&#34;1.0.152&#34;</span></span></span></code></pre></div>
<p>In order to use tinytemplate, we simply make a TinyTemplate object</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> tt <span style="color:#f92672">=</span> TinyTemplate::new();</span></span></code></pre></div>
<p>We then add a template string under a certain name</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>tt.add_template(<span style="color:#e6db74">&#34;shaders&#34;</span>, TEMPLATE).unwrap();</span></span></code></pre></div>
<p>We create a context structure, with contents applicable to the template we&rsquo;re rendering, and for the actual rendering we just pass the context in, along with the name of the template we&rsquo;re rendering</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> code <span style="color:#f92672">=</span> tt.render(<span style="color:#e6db74">&#34;shaders&#34;</span>, <span style="color:#f92672">&amp;</span>context).unwrap();</span></span></code></pre></div>
<h1 id="compiling-the-shaders">Compiling the shaders<a hidden class="anchor" aria-hidden="true" href="#compiling-the-shaders">#</a></h1>
<p>Cargo, which is the official project tooling for Rust, supports having a build script that is run <em>before</em> the program itself is compiled.</p>
<p>These are often used to generate additional Rust code at build time that can be incorporated into regular Rust code during the build, or to compile C libraries that can be linked in.</p>
<p>We will use a build script to find all of the shaders (vertex and fragment only at the moment) in the <strong>assets/shaders</strong> directory, and compile them into SPIR-V. We&rsquo;ll then bake the generated code into our build.</p>
<h2 id="making-the-build-script">Making the build script<a hidden class="anchor" aria-hidden="true" href="#making-the-build-script">#</a></h2>
<p>The first step is to make a script named <strong>build.rs</strong> in the <strong>root</strong> of the Cargo project, which will be picked up automatically by Rust</p>
<p><img loading="lazy" src="hierarchy.PNG" alt="Project Hierarchy"  />
</p>
<p>The build script has a main function, same as a regular binary main file, however it&rsquo;s run by Cargo at build time, and can issue directives to Cargo through printing to stdout.</p>
<p>The build script will be re-run when it&rsquo;s changed but we can also tell it to re-run when other files have changed. In our case we want to re-run it whenever any of the shader files under our search path changes. We can do this with the following line</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>println!(<span style="color:#e6db74">&#34;cargo:rerun-if-changed=\&#34;assets/shaders\&#34;&#34;</span>);</span></span></code></pre></div>
<p>This has a few parts to it</p>
<ol>
<li><strong>cargo:</strong> identifies this output as being a directive for Cargo</li>
<li><strong>rerun-if-changed</strong> is the directive which says to re-run the build script if the referenced file or files change</li>
<li><strong>=&quot;assets/shaders&quot;</strong> is our path. We have to escape the quote marks due to them being within a string already</li>
</ol>
<h2 id="recursing-the-shader-directory">Recursing the shader directory<a hidden class="anchor" aria-hidden="true" href="#recursing-the-shader-directory">#</a></h2>
<p>The first thing we&rsquo;ll do inside this build script is initialise a stack for our recursion. Initially it&rsquo;ll only have the <strong>assets/shaders</strong> path in it but as we find more directories to recurse into, we&rsquo;ll push onto this</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> prefix: <span style="color:#a6e22e">PathBuf</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;assets/shaders&#34;</span>.into();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> paths: Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> vec![prefix.clone()];</span></span></code></pre></div>
<p>Secondly we&rsquo;ll need a parser for Naga to use when we&rsquo;re parsing our shader sources. We can re-use this parser between shaders for efficiency though. We&rsquo;ll also allocate storage for the shader name/data</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> parser <span style="color:#f92672">=</span> Parser::default();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> shaders <span style="color:#f92672">=</span> vec![];</span></span></code></pre></div>
<p>For a recursive directory search, we&rsquo;ll keep going while there&rsquo;s more paths in our &ldquo;paths&rdquo; stack, and use <strong>fs::read_dir</strong> to get the information for files and subdirectories within that directory. This function gets us an iterator over all the files/directories there, so we iterate it</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#66d9ef">let</span> Some(path) <span style="color:#f92672">=</span> paths.pop() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Ok(files) <span style="color:#f92672">=</span> fs::read_dir(path) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> file <span style="color:#66d9ef">in</span> files {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> file <span style="color:#f92672">=</span> file.unwrap();
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// more code here
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>We can get the file type (directory, file, etc.), and the file path from this entry</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> file_type <span style="color:#f92672">=</span> file.file_type().unwrap();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> file_path <span style="color:#f92672">=</span> file.path();</span></span></code></pre></div>
<p>Now we check the file type. If it&rsquo;s a directory, then we simply push it onto the stack for processing, if it&rsquo;s a file though we&rsquo;ll need to do more work</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> file_type.is_dir() {
</span></span><span style="display:flex;"><span>    paths.push(file_path);
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> file_type.is_file() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(source) <span style="color:#f92672">=</span> read_and_compile_shader(file_path.clone(), <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> parser) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> shader_name <span style="color:#f92672">=</span> file_path
</span></span><span style="display:flex;"><span>            .strip_prefix(prefix.clone())
</span></span><span style="display:flex;"><span>            .unwrap()
</span></span><span style="display:flex;"><span>            .to_str()
</span></span><span style="display:flex;"><span>            .unwrap()
</span></span><span style="display:flex;"><span>            .replace(<span style="color:#e6db74">&#39;\\&#39;</span>, <span style="color:#e6db74">&#34;/&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> source <span style="color:#f92672">=</span> format!(<span style="color:#e6db74">&#34;{source:?}&#34;</span>);
</span></span><span style="display:flex;"><span>        shaders.push((shader_name, source));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>What we do if it&rsquo;s a file, is we pass it to our helper function <strong>read_and_compile_shader</strong> which attempts to parse the file as shader source and return the SPIR-V data. This function is optional, because the file could be not a shader, in which case it&rsquo;s ignored.</p>
<p>If the conversion is successful then we take the file path, and rmeove the &ldquo;assets/shaders&rdquo; portion, so we get a relative path to that folder. We then replace any backslashes with forward slashes to standardise the path for our application code to correctly look up a shader.</p>
<p>The source is formatted as a string which will format it as a string like: <strong>&quot;[12, 13, 14, 42]&quot;</strong></p>
<p>Finally we push the shader name and source code string into the shaders list.</p>
<h2 id="building-the-source-code">Building the source code<a hidden class="anchor" aria-hidden="true" href="#building-the-source-code">#</a></h2>
<p>Once we&rsquo;ve found all the shaders in our assets folder, and have our list of pairs, we can generate a Rust source file that will then be included into and built into our application.</p>
<p>For this we use tinytemplate as briefly mentioned in a previous section. However tinytemplate uses the <strong>{</strong> and <strong>}</strong> characters to identify substitutions into the template. This means we can&rsquo;t use them to define our Rust function (I couldn&rsquo;t find a way anyway), and instead have to substitute in those characters themselves.</p>
<p>In our template we call those open_brace and close_brace. Template is as follows</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> TEMPLATE: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">fn get_compiled_shader_mapping() -&gt; ::std::collections::HashMap&lt;&amp;&#39;static str, &amp;&#39;static [u32]&gt; {open_brace}     
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    let mut hash_map = ::std::collections::HashMap::new();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {{ for shader in shaders }}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {open_brace}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        const ARR: &amp;[u32] = &amp;{shader.1};
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        hash_map.insert(\&#34;{shader.0}\&#34;, ARR);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {close_brace}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {{ endfor }}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    hash_map
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{close_brace}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>;</span></span></code></pre></div>
<p>This is generating a function called <strong>get_compiled_shader_mapping</strong> which builds and returns a HashMap linking the shader path (relative to assets/shaders) to the bytes of that shader.</p>
<p>We can see the following special commands in the template:</p>
<ul>
<li><strong>{open_brace}</strong>: substitutes the &ldquo;{&rdquo; character</li>
<li><strong>{close_brace}</strong>: substitutes the &ldquo;}&rdquo; character</li>
<li><strong>{{for shader in shaders}}</strong>: A loop which runs the code until endfor, for every element of shaders (every pair)</li>
<li><strong>{{endfor}}</strong>: delimits the end of the section that is repeated in the for loop</li>
<li><strong>{shader.0}</strong>: this is the shader path</li>
<li><strong>{shader.1}</strong>: this is the stringified version of the SPIR-V array generated for that shader</li>
</ul>
<p>We then go ahead and use tinytemplate to generate the final code</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> tt <span style="color:#f92672">=</span> TinyTemplate::new();
</span></span><span style="display:flex;"><span>tt.add_template(<span style="color:#e6db74">&#34;shaders&#34;</span>, TEMPLATE).unwrap();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> context <span style="color:#f92672">=</span> Context {
</span></span><span style="display:flex;"><span>    shaders,
</span></span><span style="display:flex;"><span>    open_brace: <span style="color:#f92672">&#39;</span>{<span style="color:#f92672">&#39;</span>,
</span></span><span style="display:flex;"><span>    close_brace: <span style="color:#f92672">&#39;</span>}<span style="color:#f92672">&#39;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> code <span style="color:#f92672">=</span> tt.render(<span style="color:#e6db74">&#34;shaders&#34;</span>, <span style="color:#f92672">&amp;</span>context).unwrap();</span></span></code></pre></div>
<p>The code generated with this template looks something like</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_compiled_shader_mapping</span>() -&gt; ::std::collections::HashMap<span style="color:#f92672">&lt;&amp;&#39;</span>static <span style="color:#66d9ef">str</span>, <span style="color:#f92672">&amp;&#39;</span>static [<span style="color:#66d9ef">u32</span>]<span style="color:#f92672">&gt;</span> {     
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> hash_map <span style="color:#f92672">=</span> ::std::collections::HashMap::new();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> ARR: <span style="color:#66d9ef">&amp;</span>[<span style="color:#66d9ef">u32</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>[<span style="color:#ae81ff">119734787</span>, <span style="color:#ae81ff">65536</span>, <span style="color:#ae81ff">28</span>, <span style="color:#ae81ff">37</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">131089</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">393227</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1280527431</span>, <span style="color:#ae81ff">1685353262</span>, <span style="color:#ae81ff">808793134</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">196622</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">458767</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">1852399981</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">26</span>, <span style="color:#ae81ff">29</span>, <span style="color:#ae81ff">196624</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">327752</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">35</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">262215</span>, <span style="color:#ae81ff">26</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">262215</span>, <span style="color:#ae81ff">29</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">131091</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">262165</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">262187</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">196630</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">262187</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">1065353216</span>, <span style="color:#ae81ff">262167</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">262167</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">196638</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">262176</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">196654</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">327739</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">262176</span>, <span style="color:#ae81ff">14</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">196654</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">327739</span>, <span style="color:#ae81ff">14</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">196641</span>, <span style="color:#ae81ff">18</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">262176</span>, <span style="color:#ae81ff">27</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">262203</span>, <span style="color:#ae81ff">27</span>, <span style="color:#ae81ff">26</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">262176</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">262203</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">29</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">327734</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">17</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">18</span>, <span style="color:#ae81ff">131320</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">131321</span>, <span style="color:#ae81ff">19</span>, <span style="color:#ae81ff">131320</span>, <span style="color:#ae81ff">19</span>, <span style="color:#ae81ff">262205</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">327761</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">21</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">327761</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">22</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">327761</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">23</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">458832</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">24</span>, <span style="color:#ae81ff">21</span>, <span style="color:#ae81ff">22</span>, <span style="color:#ae81ff">23</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">196670</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">24</span>, <span style="color:#ae81ff">65789</span>, <span style="color:#ae81ff">65592</span>, <span style="color:#ae81ff">327734</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">18</span>, <span style="color:#ae81ff">131320</span>, <span style="color:#ae81ff">25</span>, <span style="color:#ae81ff">262205</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">28</span>, <span style="color:#ae81ff">26</span>, <span style="color:#ae81ff">131321</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">131320</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">196670</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">28</span>, <span style="color:#ae81ff">262201</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">33</span>, <span style="color:#ae81ff">17</span>, <span style="color:#ae81ff">262205</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">34</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">262224</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">35</span>, <span style="color:#ae81ff">34</span>, <span style="color:#ae81ff">327761</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">36</span>, <span style="color:#ae81ff">35</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">196670</span>, <span style="color:#ae81ff">29</span>, <span style="color:#ae81ff">36</span>, <span style="color:#ae81ff">65789</span>, <span style="color:#ae81ff">65592</span>];
</span></span><span style="display:flex;"><span>        hash_map.insert(<span style="color:#e6db74">&#34;triangle.frag&#34;</span>, ARR);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> ARR: <span style="color:#66d9ef">&amp;</span>[<span style="color:#66d9ef">u32</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>[<span style="color:#ae81ff">119734787</span>, <span style="color:#ae81ff">65536</span>, <span style="color:#ae81ff">28</span>, <span style="color:#ae81ff">83</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">131089</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">393227</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1280527431</span>, <span style="color:#ae81ff">1685353262</span>, <span style="color:#ae81ff">808793134</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">196622</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">524303</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">60</span>, <span style="color:#ae81ff">1852399981</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">53</span>, <span style="color:#ae81ff">56</span>, <span style="color:#ae81ff">58</span>, <span style="color:#ae81ff">262215</span>, <span style="color:#ae81ff">14</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">262215</span>, <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">327752</span>, <span style="color:#ae81ff">17</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">35</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">327752</span>, <span style="color:#ae81ff">17</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">35</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">262215</span>, <span style="color:#ae81ff">53</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">42</span>, <span style="color:#ae81ff">262215</span>, <span style="color:#ae81ff">56</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">262215</span>, <span style="color:#ae81ff">58</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">131091</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">262165</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">262187</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">262187</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">262165</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">262187</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">196630</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">262187</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">262187</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">1053609165</span>, <span style="color:#ae81ff">262187</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">3201092813</span>, <span style="color:#ae81ff">262187</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">1065353216</span>, <span style="color:#ae81ff">262167</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">262172</span>, <span style="color:#ae81ff">14</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">196637</span>, <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">262167</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">262174</span>, <span style="color:#ae81ff">17</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">393260</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">18</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">393260</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">19</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">393260</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">393260</span>, <span style="color:#ae81ff">14</span>, <span style="color:#ae81ff">21</span>, <span style="color:#ae81ff">18</span>, <span style="color:#ae81ff">19</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">393260</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">22</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">393260</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">23</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">393260</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">24</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">393260</span>, <span style="color:#ae81ff">14</span>, <span style="color:#ae81ff">25</span>, <span style="color:#ae81ff">22</span>, <span style="color:#ae81ff">23</span>, <span style="color:#ae81ff">24</span>, <span style="color:#ae81ff">262176</span>, <span style="color:#ae81ff">27</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">196654</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">28</span>, <span style="color:#ae81ff">327739</span>, <span style="color:#ae81ff">27</span>, <span style="color:#ae81ff">26</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">28</span>, <span style="color:#ae81ff">262176</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">14</span>, <span style="color:#ae81ff">327739</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">29</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">21</span>, <span style="color:#ae81ff">327739</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">25</span>, <span style="color:#ae81ff">262176</span>, <span style="color:#ae81ff">33</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">196654</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">34</span>, <span style="color:#ae81ff">327739</span>, <span style="color:#ae81ff">33</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">34</span>, <span style="color:#ae81ff">262176</span>, <span style="color:#ae81ff">36</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">196654</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">37</span>, <span style="color:#ae81ff">327739</span>, <span style="color:#ae81ff">36</span>, <span style="color:#ae81ff">35</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">37</span>, <span style="color:#ae81ff">196641</span>, <span style="color:#ae81ff">40</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">262176</span>, <span style="color:#ae81ff">54</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">262203</span>, <span style="color:#ae81ff">54</span>, <span style="color:#ae81ff">53</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">262176</span>, <span style="color:#ae81ff">57</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">262203</span>, <span style="color:#ae81ff">57</span>, <span style="color:#ae81ff">56</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">262176</span>, <span style="color:#ae81ff">59</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">262203</span>, <span style="color:#ae81ff">59</span>, <span style="color:#ae81ff">58</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">262176</span>, <span style="color:#ae81ff">78</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">262187</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">79</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">327734</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">39</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">40</span>, <span style="color:#ae81ff">131320</span>, <span style="color:#ae81ff">38</span>, <span style="color:#ae81ff">131321</span>, <span style="color:#ae81ff">41</span>, <span style="color:#ae81ff">131320</span>, <span style="color:#ae81ff">41</span>, <span style="color:#ae81ff">262205</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">42</span>, <span style="color:#ae81ff">35</span>, <span style="color:#ae81ff">327745</span>, <span style="color:#ae81ff">27</span>, <span style="color:#ae81ff">43</span>, <span style="color:#ae81ff">29</span>, <span style="color:#ae81ff">42</span>, <span style="color:#ae81ff">262205</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">44</span>, <span style="color:#ae81ff">43</span>, <span style="color:#ae81ff">327761</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">45</span>, <span style="color:#ae81ff">44</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">327761</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">46</span>, <span style="color:#ae81ff">44</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">327761</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">47</span>, <span style="color:#ae81ff">44</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">458832</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">48</span>, <span style="color:#ae81ff">45</span>, <span style="color:#ae81ff">46</span>, <span style="color:#ae81ff">47</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">196670</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">48</span>, <span style="color:#ae81ff">262205</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">49</span>, <span style="color:#ae81ff">35</span>, <span style="color:#ae81ff">327745</span>, <span style="color:#ae81ff">27</span>, <span style="color:#ae81ff">50</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">49</span>, <span style="color:#ae81ff">262205</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">51</span>, <span style="color:#ae81ff">50</span>, <span style="color:#ae81ff">196670</span>, <span style="color:#ae81ff">26</span>, <span style="color:#ae81ff">51</span>, <span style="color:#ae81ff">65789</span>, <span style="color:#ae81ff">65592</span>, <span style="color:#ae81ff">327734</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">60</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">40</span>, <span style="color:#ae81ff">131320</span>, <span style="color:#ae81ff">52</span>, <span style="color:#ae81ff">262205</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">55</span>, <span style="color:#ae81ff">53</span>, <span style="color:#ae81ff">131321</span>, <span style="color:#ae81ff">61</span>, <span style="color:#ae81ff">131320</span>, <span style="color:#ae81ff">61</span>, <span style="color:#ae81ff">196670</span>, <span style="color:#ae81ff">35</span>, <span style="color:#ae81ff">55</span>, <span style="color:#ae81ff">262271</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">62</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">393296</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">63</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">62</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">393296</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">64</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">262271</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">65</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">393296</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">66</span>, <span style="color:#ae81ff">65</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">393296</span>, <span style="color:#ae81ff">14</span>, <span style="color:#ae81ff">67</span>, <span style="color:#ae81ff">63</span>, <span style="color:#ae81ff">64</span>, <span style="color:#ae81ff">66</span>, <span style="color:#ae81ff">393296</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">68</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">393296</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">69</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">393296</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">70</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">393296</span>, <span style="color:#ae81ff">14</span>, <span style="color:#ae81ff">71</span>, <span style="color:#ae81ff">68</span>, <span style="color:#ae81ff">69</span>, <span style="color:#ae81ff">70</span>, <span style="color:#ae81ff">262201</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">72</span>, <span style="color:#ae81ff">39</span>, <span style="color:#ae81ff">262205</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">73</span>, <span style="color:#ae81ff">26</span>, <span style="color:#ae81ff">262205</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">74</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">327760</span>, <span style="color:#ae81ff">17</span>, <span style="color:#ae81ff">75</span>, <span style="color:#ae81ff">73</span>, <span style="color:#ae81ff">74</span>, <span style="color:#ae81ff">327761</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">76</span>, <span style="color:#ae81ff">75</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">196670</span>, <span style="color:#ae81ff">56</span>, <span style="color:#ae81ff">76</span>, <span style="color:#ae81ff">327761</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">77</span>, <span style="color:#ae81ff">75</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">196670</span>, <span style="color:#ae81ff">58</span>, <span style="color:#ae81ff">77</span>, <span style="color:#ae81ff">327745</span>, <span style="color:#ae81ff">78</span>, <span style="color:#ae81ff">80</span>, <span style="color:#ae81ff">58</span>, <span style="color:#ae81ff">79</span>, <span style="color:#ae81ff">262205</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">81</span>, <span style="color:#ae81ff">80</span>, <span style="color:#ae81ff">262271</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">82</span>, <span style="color:#ae81ff">81</span>, <span style="color:#ae81ff">196670</span>, <span style="color:#ae81ff">80</span>, <span style="color:#ae81ff">82</span>, <span style="color:#ae81ff">65789</span>, <span style="color:#ae81ff">65592</span>];
</span></span><span style="display:flex;"><span>        hash_map.insert(<span style="color:#e6db74">&#34;triangle.vert&#34;</span>, ARR);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    hash_map
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Finally, we&rsquo;ll write it out to file so it can be included later. Rust only supports writing build script output to the directory specified by the <strong>OUT_DIR</strong> environment variable. Rust gives us a way to get this through std::env::var, passing a key.</p>
<p>We can therefore write out this source code to a file called shaders.rs under that folder</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> path <span style="color:#f92672">=</span> format!(<span style="color:#e6db74">&#34;{}/shaders.rs&#34;</span>, env::var(<span style="color:#e6db74">&#34;OUT_DIR&#34;</span>).unwrap());
</span></span><span style="display:flex;"><span>fs::write(path, code).unwrap();</span></span></code></pre></div>
<h2 id="compiling-shader-source">Compiling shader source<a hidden class="anchor" aria-hidden="true" href="#compiling-shader-source">#</a></h2>
<p>As mentioned above, we use a file read_and_compile_shader to take a file path, and a Naga parser and read the source code as GLSL source if it can, outputting and returning the SPIR-V data.</p>
<p>The first steps are to get the file extension which will tell us whether it&rsquo;s a vertex (.vert) or fragment shader (.frag), and also to read the text of the file</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> extension <span style="color:#f92672">=</span> input_path.extension()<span style="color:#f92672">?</span>.to_str()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> source <span style="color:#f92672">=</span> fs::read_to_string(<span style="color:#f92672">&amp;</span>input_path).ok()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> options <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> extension {
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;frag&#34;</span> <span style="color:#f92672">=&gt;</span> Options::from(ShaderStage::Fragment),
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;vert&#34;</span> <span style="color:#f92672">=&gt;</span> Options::from(ShaderStage::Vertex),
</span></span><span style="display:flex;"><span>    _ <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> None,
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p>We then use the process of parsing the shader as GLSL into a Naga module, and then writing out to SPIR-V. We return the generated bytes</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> module <span style="color:#f92672">=</span> parser.parse(<span style="color:#f92672">&amp;</span>options, <span style="color:#f92672">&amp;</span>source).ok()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> info <span style="color:#f92672">=</span> Validator::new(ValidationFlags::all(), Capabilities::all())
</span></span><span style="display:flex;"><span>    .validate(<span style="color:#f92672">&amp;</span>module)
</span></span><span style="display:flex;"><span>    .ok()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> words <span style="color:#f92672">=</span> vec![];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> writer <span style="color:#f92672">=</span> Writer::new(<span style="color:#f92672">&amp;</span>spv::Options::default()).ok()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>writer.write(<span style="color:#f92672">&amp;</span>module, <span style="color:#f92672">&amp;</span>info, None, <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> words).ok()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>Some(words)</span></span></code></pre></div>
<h1 id="including-shaders-into-application">Including shaders into application<a hidden class="anchor" aria-hidden="true" href="#including-shaders-into-application">#</a></h1>
<p>Our build script has now generated a Rust source code file with a function in it that when it&rsquo;s called returns a HashMap of the shader names to code.</p>
<p>We can include this generated file into our build by adding the following to our main.rs file</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>include!(concat!(env!(<span style="color:#e6db74">&#34;OUT_DIR&#34;</span>), <span style="color:#e6db74">&#34;/shaders.rs&#34;</span>));</span></span></code></pre></div>
<p>So this takes the environment variable corresponding to the OUT_DIR key, and appends the &ldquo;/shaders.rs&rdquo; to load the file at that path (concat! stitches the two strings together). include! then includes the contents of that file as Rust source code.</p>
<h1 id="making-shader-modules">Making shader modules<a hidden class="anchor" aria-hidden="true" href="#making-shader-modules">#</a></h1>
<p>Now we have the SPIR-V data in our application, we can pass it to Vulkan to make a shader module that can be used.</p>
<p>We&rsquo;ll make a simple wrapper function called create_shader_module and it&rsquo;s called as such</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> vertex_shader <span style="color:#f92672">=</span> create_shader_module(<span style="color:#f92672">&amp;</span>logical_device, shader_mapping[<span style="color:#e6db74">&#34;triangle.vert&#34;</span>])<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> fragment_shader <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    create_shader_module(<span style="color:#f92672">&amp;</span>logical_device, shader_mapping[<span style="color:#e6db74">&#34;triangle.frag&#34;</span>])<span style="color:#f92672">?</span>;</span></span></code></pre></div>
<p>The function itself is pretty simple - there&rsquo;s a create_shader_module on the logical device. The creation parameters only require the code slice to be constructed</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">create_shader_module</span>(device: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Device</span>, code: <span style="color:#66d9ef">&amp;</span>[<span style="color:#66d9ef">u32</span>]) -&gt; Result<span style="color:#f92672">&lt;</span>ShaderModule<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsafe</span> { device.create_shader_module(<span style="color:#f92672">&amp;</span>ShaderModuleCreateInfo::builder().code(code), None) }
</span></span><span style="display:flex;"><span>        .context(<span style="color:#e6db74">&#34;Error while creating a shader module.&#34;</span>)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>We&rsquo;ll change cleanup to take a slice of shader modules to destroy - and ensure they&rsquo;re destroyed before the logical device</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">cleanup</span>(
</span></span><span style="display:flex;"><span>    instance: <span style="color:#a6e22e">Instance</span>,
</span></span><span style="display:flex;"><span>    device: <span style="color:#a6e22e">Device</span>,
</span></span><span style="display:flex;"><span>    debug_utils: <span style="color:#a6e22e">DebugUtils</span>,
</span></span><span style="display:flex;"><span>    messenger: <span style="color:#a6e22e">DebugUtilsMessengerEXT</span>,
</span></span><span style="display:flex;"><span>    surface_ext: <span style="color:#a6e22e">Surface</span>,
</span></span><span style="display:flex;"><span>    surface: <span style="color:#a6e22e">SurfaceKHR</span>,
</span></span><span style="display:flex;"><span>    swapchain_ext: <span style="color:#a6e22e">Swapchain</span>,
</span></span><span style="display:flex;"><span>    swapchain: <span style="color:#a6e22e">SwapchainKHR</span>,
</span></span><span style="display:flex;"><span>    swapchain_images: Vec<span style="color:#f92672">&lt;</span>SwapchainImage<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    shader_modules: <span style="color:#66d9ef">&amp;</span>[ShaderModule],
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> shader_module <span style="color:#66d9ef">in</span> shader_modules {
</span></span><span style="display:flex;"><span>            device.destroy_shader_module(<span style="color:#f92672">*</span>shader_module, None);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> swapchain_image <span style="color:#66d9ef">in</span> swapchain_images {
</span></span><span style="display:flex;"><span>            device.destroy_image_view(swapchain_image.image_view, None);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        swapchain_ext.destroy_swapchain(swapchain, None);
</span></span><span style="display:flex;"><span>        device.destroy_device(None);
</span></span><span style="display:flex;"><span>        debug_utils.destroy_debug_utils_messenger(messenger, None);
</span></span><span style="display:flex;"><span>        surface_ext.destroy_surface(surface, None);
</span></span><span style="display:flex;"><span>        instance.destroy_instance(None);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://forgottenmaster.github.io/">Robin Firth</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
