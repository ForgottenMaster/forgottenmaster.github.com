<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>4. Surface | Robin Smith</title>
<meta name="keywords" content="">
<meta name="description" content="The next thing we need to set up is called a surface. Since Vulkan does not interact directly with the windowing system in use, due to OS differences etc.
Instead, Vulkan uses a common API to interact with a surface, and then uses extensions on a per platform basis to handle the differences of actually creating this surface type.
Surface extensions We could manually detect the platform we&rsquo;re compiling on, and then enable the appropriate extension through the Vulkan API, for example we could do:">
<meta name="author" content="">
<link rel="canonical" href="https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/surface/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.4599eadb9eb2ad3d0a8d6827b41a8fda8f2f4af226b63466c09c5fddbc8706b7.css" integrity="sha256-RZnq256yrT0KjWgntBqP2o8vSvImtjRmwJxf3byHBrc=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://forgottenmaster.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://forgottenmaster.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://forgottenmaster.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://forgottenmaster.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://forgottenmaster.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/surface/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="4. Surface" />
<meta property="og:description" content="The next thing we need to set up is called a surface. Since Vulkan does not interact directly with the windowing system in use, due to OS differences etc.
Instead, Vulkan uses a common API to interact with a surface, and then uses extensions on a per platform basis to handle the differences of actually creating this surface type.
Surface extensions We could manually detect the platform we&rsquo;re compiling on, and then enable the appropriate extension through the Vulkan API, for example we could do:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/surface/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-18T12:08:01+00:00" />
<meta property="article:modified_time" content="2023-02-18T12:08:01+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="4. Surface"/>
<meta name="twitter:description" content="The next thing we need to set up is called a surface. Since Vulkan does not interact directly with the windowing system in use, due to OS differences etc.
Instead, Vulkan uses a common API to interact with a surface, and then uses extensions on a per platform basis to handle the differences of actually creating this surface type.
Surface extensions We could manually detect the platform we&rsquo;re compiling on, and then enable the appropriate extension through the Vulkan API, for example we could do:"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://forgottenmaster.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Vulkan",
      "item": "https://forgottenmaster.github.io/posts/vulkan/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Let's Learn Vulkan",
      "item": "https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "4. Surface",
      "item": "https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/surface/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "4. Surface",
  "name": "4. Surface",
  "description": "The next thing we need to set up is called a surface. Since Vulkan does not interact directly with the windowing system in use, due to OS differences etc.\nInstead, Vulkan uses a common API to interact with a surface, and then uses extensions on a per platform basis to handle the differences of actually creating this surface type.\nSurface extensions We could manually detect the platform we\u0026rsquo;re compiling on, and then enable the appropriate extension through the Vulkan API, for example we could do:",
  "keywords": [
    
  ],
  "articleBody": "The next thing we need to set up is called a surface. Since Vulkan does not interact directly with the windowing system in use, due to OS differences etc.\nInstead, Vulkan uses a common API to interact with a surface, and then uses extensions on a per platform basis to handle the differences of actually creating this surface type.\nSurface extensions We could manually detect the platform we’re compiling on, and then enable the appropriate extension through the Vulkan API, for example we could do:\n#[cfg(target_os=\"windows\")] { Win32Surface::new(\u0026entry, \u0026instance).create_win32_surface(\u0026win_creation_info, None) } #[cfg(target_os=\"linux\")] { XlibSurface::new(\u0026entry, \u0026instance).create_xlib_surface(\u0026xlib_creation_info, None) } // and more However, this is tedious and cumbersome, so instead what we can use, as we’ll see soon is a function that does this for us in our ash_window glue crate…create_surface\nCreating our surface In order to create our surface, as mentioned above, we’ll use the function create_surface which handles the platform differences for us!.\nAll we need to do is call the function with a Vulkan entry point, Vulkan instance, and valid window and display handles which we can get from our winit::Window.\nWe’ll bundle this logic up into a little function of our own called create_surface which just lets the caller (main) pass slightly fewer parameters, and adds context/converts the return type to an anyhow::Result.\n/// # Safety /// This function is unsafe because we can't guarantee that the resulting surface doesn't outlive Instance /// which is a precondition violation - surface should be destroyed before the instance that created it. unsafe fn create_surface( entry: \u0026Entry, instance: \u0026Instance, window: \u0026Window, ) -\u003e Result\u003cSurfaceKHR\u003e { let display_handle = window.raw_display_handle(); let window_handle = window.raw_window_handle(); ash_window::create_surface(entry, instance, display_handle, window_handle, None) .context(\"Error while creating a surface to use.\") } As mentioned in the safety comment, this function is marked as unsafe because we require that the surface does not outlive the instance, which is something we can’t check, nor control in this function. The responsibility lies with main to ensure that the order of destruction is correct.\nIn order to call it, therefore we extend the “unsafe” block in main so that it covers the entire duration of the surface being called, to the cleanup having finished. The cleanup function is a safe function so destroys things in the correct order.\nDestroying the surface We then need to remember to pass the surface to the cleanup function to make sure it gets destroyed (before the instance). Cleanup function now looks like this (note we need to pass the Entry point so we can access the Surface extension methods/function pointers):\nfn cleanup( instance: Instance, device: Device, debug_utils: DebugUtils, messenger: DebugUtilsMessengerEXT, surface_ext: Surface, surface: SurfaceKHR, ) { unsafe { device.destroy_device(None); debug_utils.destroy_debug_utils_messenger(messenger, None); surface_ext.destroy_surface(surface, None); instance.destroy_instance(None); } } Checking for presentation queues We need to check that the physical device we’re selecting actually has support for presenting to a surface, as we’ll need to use a queue from a family with the presentation capabilities when we come to making our swapchain.\nNow that we’ve got to track two family indices and we want two queues for commands, we need to change the struct containing our family indices to hold Option’s instead. We’ll also add a method to check if the indices set is complete\nstruct QueueFamilyIndices { graphics_family: Option\u003cu32\u003e, presentation_family: Option\u003cu32\u003e, } impl QueueFamilyIndices { fn is_complete(\u0026self) -\u003e bool { self.graphics_family.is_some() \u0026\u0026 self.presentation_family.is_some() } } We do need to route through the Surface extension object to access the functions relating to this extension, because we’ll be using one of them to check if the physical device queue family supports presentation to our surface.\nWe change the get_queue_family_indices function to initialise the struct holding the indices such that it’s not holding anything initially:\nlet mut queue_family_indices = QueueFamilyIndices { graphics_family: None, presentation_family: None, }; As we’re iterating over the queue families on the device, we’ll set the appropriate index to Some if it matches. The graphics queue family index as before:\nif props.queue_count \u003e 0 \u0026\u0026 props.queue_flags.contains(vk::QueueFlags::GRAPHICS) { queue_family_indices.graphics_family = Some(idx as u32); } And then, for the presentation queue family index, we can use the extension method get_physical_device_surface_support which returns a VkResult if it fails. In the case of it failing we’ll count that as no support for that family. Therefore the check looks as follows:\nif let Ok(surface_supported) = unsafe { surface_ext.get_physical_device_surface_support(device, idx as u32, surface) } { if surface_supported { queue_family_indices.presentation_family = Some(idx as u32); } } After performing both checks and setting if applicable, it might be the case our set of indices is complete - in which case it’s fine for this physical device:\nif queue_family_indices.is_complete() { return Some(queue_family_indices); } Creating the second queue type Now we have the index of the family to use for presentation, we need to tell Vulkan to create us a queue from that family. However, it could be (and probably is) the case that the graphics queue family also supports presentation, so we need to handle duplicate families being used for the same role.\nFirst we add the second handle to our struct storing the queue handles:\nstruct QueueHandles { graphics_queue: vk::Queue, presentation_queue: vk::Queue, } We can look up the presentation queue after creation the same way as we did with the graphics queue with:\npresentation_queue: unsafe { device.get_device_queue(queue_family_indices.presentation_family.unwrap(), 0) } However for creating the logical device, and telling Vulkan to create us our queues we don’t want to request two different queues if the family happens to be the same. To handle this case, we can make a vector of queue families and deduplicate, then create a queue create info for whichever ones are left after deduplication.\nTherefore we do this:\nlet mut indices = vec![ queue_family_indices.graphics_family.unwrap(), queue_family_indices.presentation_family.unwrap(), ]; indices.dedup(); let infos = indices .into_iter() .map(|idx| { *vk::DeviceQueueCreateInfo::builder() .queue_family_index(idx) .queue_priorities(\u0026[1.0]) }) .collect::\u003cVec\u003c_\u003e\u003e(); And then pass them into the device creation info:\nlet device = unsafe { instance.create_device( physical_device, \u0026vk::DeviceCreateInfo::builder().queue_create_infos(\u0026infos), None, ) }?; Enabling device extensions We will require the VK_KHR_swapchain device extension to be enabled when we create the Vulkan device in order to be able to use swapchain functionality to present images to the surface.\nWe will need to take this into consideration when selecting a PhysicalDevice to work with, so that we only select from those devices that support the swapchain extension. Additionally, we will need to tell Vulkan to enable these when we create the logical device.\nThe first thing we need to do is to define them in an array, which we can do with the CStr type that is then safe to work with in the other functions. We’ll go ahead and use unsafe to safely construct a CStr from a null-terminated byte string:\nlet device_extensions = [unsafe { CStr::from_bytes_with_nul_unchecked(b\"VK_KHR_swapchain\\0\") }]; We need to pass this through to get_physical_device and create_logical_device.\nFor getting a physical device we need to ensure the physical device we choose actually supports the extension, so we change the code to add an additional check here:\nlet has_required_extensions = validate_required_device_extensions(instance, physical_device, required_extensions)?; if has_required_extensions { return Ok((physical_device, queue_family_indices)); } The validate_required_device_extensions function is the same as the other ones we’ve been writing except this time I decided to write it as a safe function that takes a slice of CStr references and handle the unsafety inside the function…..no particular reason, but having safe APIs is normally better.\nThe function itself just gets the supported device extensions for a physical device and checks to make sure our required ones are in there. The difference is that there can be multiple PhysicalDevices in a machine, and not having a required extension isn’t an immediate issue, we just pass over that physical device - so we don’t return Err explicitly this time, only when a Vulkan API call changes:\nfn validate_required_device_extensions( instance: \u0026Instance, physical_device: vk::PhysicalDevice, required_extensions: \u0026[\u0026CStr], ) -\u003e Result\u003cbool\u003e { { unsafe { let device_extension_properties = instance.enumerate_device_extension_properties(physical_device)?; let available_extensions = device_extension_properties .iter() .map(|prop| CStr::from_ptr(prop.extension_name.as_ptr())) .collect::\u003cHashSet\u003c_\u003e\u003e(); for required_extension in required_extensions { if !available_extensions.contains(required_extension) { return Ok::\u003c_, Error\u003e(false); } } } Ok::\u003c_, Error\u003e(true) } .context(\"Error in validate_required_device_extensions.\") } The second time we need the extensions are when creating the logical device. However in that case, we do need to extract the raw pointers from the CStrs since the builder for creating a new Vulkan device is taking a \u0026[*const i8] rather than a \u0026[\u0026CStr]. We can’t transmute the memory directly unfortunately so we need to create a secondary collection with the transformed pointers. Then we add them to the device create info:\nlet device = unsafe { let required_extensions = required_extensions .iter() .map(|cstr| cstr.as_ptr()) .collect::\u003cVec\u003c_\u003e\u003e(); instance.create_device( physical_device, \u0026vk::DeviceCreateInfo::builder() .queue_create_infos(\u0026infos) .enabled_extension_names(\u0026required_extensions), None, ) }?; Getting surface information Another thing we need to do is to get information about the surface capabilities of the physical device so that we can make use of that information when we need to set up a swap chain.\nWe’ll first create a struct to hold the information. The information we’ll keep hold of is:\nThe available formats for data on the surface (e.g. RGBA) The avalable presentation modes for strategies and timings of when the image swapping in a swapchain actually happens The assorted capabilities of the surface such as maximum number of images, minimum number, etc. The struct looks as follows. We also add an is_valid method that ensures there’s at least 1 supported format and presentation mode:\nstruct SurfaceInfo { present_modes: Vec\u003cPresentModeKHR\u003e, surface_formats: Vec\u003cSurfaceFormatKHR\u003e, surface_capabilities: SurfaceCapabilitiesKHR, } impl SurfaceInfo { fn is_valid(\u0026self) -\u003e bool { !self.present_modes.is_empty() \u0026\u0026 !self.surface_formats.is_empty() } } We’ll look up all of these things in a function called get_surface_info which calls the functions to retrieve the information through unsafe code. The function itself will return a Result because it’s fallible (each of the FFI calls returns a VkResult so they’re fallible). But there’s nothing surprising about it:\nfn get_surface_info( surface_ext: \u0026Surface, physical_device: vk::PhysicalDevice, surface: SurfaceKHR, ) -\u003e Result\u003cSurfaceInfo\u003e { { let present_modes = unsafe { surface_ext.get_physical_device_surface_present_modes(physical_device, surface) }?; let surface_capabilities = unsafe { surface_ext.get_physical_device_surface_capabilities(physical_device, surface) }?; let surface_formats = unsafe { surface_ext.get_physical_device_surface_formats(physical_device, surface) }?; Ok::\u003c_, Error\u003e(SurfaceInfo { present_modes, surface_capabilities, surface_formats, }) } .context(\"Error when trying to get surface information for a physical device.\") } ",
  "wordCount" : "1672",
  "inLanguage": "en",
  "datePublished": "2023-02-18T12:08:01Z",
  "dateModified": "2023-02-18T12:08:01Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/surface/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Robin Smith",
    "logo": {
      "@type": "ImageObject",
      "url": "https://forgottenmaster.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://forgottenmaster.github.io/" accesskey="h" title="Robin Smith (Alt + H)">Robin Smith</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://forgottenmaster.github.io/resume/" title="Résumé">
                    <span>Résumé</span>
                </a>
            </li>
            <li>
                <a href="https://forgottenmaster.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://forgottenmaster.github.io/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://forgottenmaster.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/vulkan/">Vulkan</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/">Let&#39;s Learn Vulkan</a></div>
    <h1 class="post-title entry-hint-parent">
      4. Surface
    </h1>
    <div class="post-meta"><span title='2023-02-18 12:08:01 +0000 UTC'>February 18, 2023</span>&nbsp;·&nbsp;8 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#surface-extensions" aria-label="Surface extensions">Surface extensions</a></li>
                <li>
                    <a href="#creating-our-surface" aria-label="Creating our surface">Creating our surface</a></li>
                <li>
                    <a href="#destroying-the-surface" aria-label="Destroying the surface">Destroying the surface</a></li>
                <li>
                    <a href="#checking-for-presentation-queues" aria-label="Checking for presentation queues">Checking for presentation queues</a></li>
                <li>
                    <a href="#creating-the-second-queue-type" aria-label="Creating the second queue type">Creating the second queue type</a></li>
                <li>
                    <a href="#enabling-device-extensions" aria-label="Enabling device extensions">Enabling device extensions</a></li>
                <li>
                    <a href="#getting-surface-information" aria-label="Getting surface information">Getting surface information</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>The next thing we need to set up is called a surface. Since Vulkan does not interact directly with the windowing system in use, due to OS differences etc.</p>
<p>Instead, Vulkan uses a common API to interact with a <strong>surface</strong>, and then uses extensions on a per platform basis to handle the differences of actually creating this surface type.</p>
<h1 id="surface-extensions">Surface extensions<a hidden class="anchor" aria-hidden="true" href="#surface-extensions">#</a></h1>
<p>We could manually detect the platform we&rsquo;re compiling on, and then enable the appropriate extension through the Vulkan API, for example we could do:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[cfg(target_os=</span><span style="color:#e6db74">&#34;windows&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Win32Surface::new(<span style="color:#f92672">&amp;</span>entry, <span style="color:#f92672">&amp;</span>instance).create_win32_surface(<span style="color:#f92672">&amp;</span>win_creation_info, None)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[cfg(target_os=</span><span style="color:#e6db74">&#34;linux&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    XlibSurface::new(<span style="color:#f92672">&amp;</span>entry, <span style="color:#f92672">&amp;</span>instance).create_xlib_surface(<span style="color:#f92672">&amp;</span>xlib_creation_info, None)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// and more
</span></span></span></code></pre></div>
<p>However, this is tedious and cumbersome, so instead what we can use, as we&rsquo;ll see soon is a function that does this for us in our ash_window glue crate&hellip;<strong>create_surface</strong></p>
<h1 id="creating-our-surface">Creating our surface<a hidden class="anchor" aria-hidden="true" href="#creating-our-surface">#</a></h1>
<p>In order to create our surface, as mentioned above, we&rsquo;ll use the function create_surface which handles the platform differences for us!.</p>
<p>All we need to do is call the function with a Vulkan entry point, Vulkan instance, and valid window and display handles which we can get from our winit::Window.</p>
<p>We&rsquo;ll bundle this logic up into a little function of our own called create_surface which just lets the caller (main) pass slightly fewer parameters, and adds context/converts the return type to an anyhow::Result.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#e6db74">/// # Safety
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/// This function is unsafe because we can&#39;t guarantee that the resulting surface doesn&#39;t outlive Instance
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/// which is a precondition violation - surface should be destroyed before the instance that created it.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">unsafe</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">create_surface</span>(
</span></span><span style="display:flex;"><span>    entry: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Entry</span>,
</span></span><span style="display:flex;"><span>    instance: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Instance</span>,
</span></span><span style="display:flex;"><span>    window: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Window</span>,
</span></span><span style="display:flex;"><span>) -&gt; Result<span style="color:#f92672">&lt;</span>SurfaceKHR<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> display_handle <span style="color:#f92672">=</span> window.raw_display_handle();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> window_handle <span style="color:#f92672">=</span> window.raw_window_handle();
</span></span><span style="display:flex;"><span>    ash_window::create_surface(entry, instance, display_handle, window_handle, None)
</span></span><span style="display:flex;"><span>        .context(<span style="color:#e6db74">&#34;Error while creating a surface to use.&#34;</span>)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>As mentioned in the safety comment, this function is marked as unsafe because we require that the surface does not outlive the instance, which is something we can&rsquo;t check, nor control in this function. The responsibility lies with main to ensure that the order of destruction is correct.</p>
<p>In order to call it, therefore we extend the &ldquo;unsafe&rdquo; block in main so that it covers the entire duration of the surface being called, to the cleanup having finished. The cleanup function is a safe function so destroys things in the correct order.</p>
<h1 id="destroying-the-surface">Destroying the surface<a hidden class="anchor" aria-hidden="true" href="#destroying-the-surface">#</a></h1>
<p>We then need to remember to pass the surface to the cleanup function to make sure it gets destroyed (<strong>before</strong> the instance). Cleanup function now looks like this (note we need to pass the Entry point so we can access the Surface extension methods/function pointers):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">cleanup</span>(
</span></span><span style="display:flex;"><span>    instance: <span style="color:#a6e22e">Instance</span>,
</span></span><span style="display:flex;"><span>    device: <span style="color:#a6e22e">Device</span>,
</span></span><span style="display:flex;"><span>    debug_utils: <span style="color:#a6e22e">DebugUtils</span>,
</span></span><span style="display:flex;"><span>    messenger: <span style="color:#a6e22e">DebugUtilsMessengerEXT</span>,
</span></span><span style="display:flex;"><span>    surface_ext: <span style="color:#a6e22e">Surface</span>,
</span></span><span style="display:flex;"><span>    surface: <span style="color:#a6e22e">SurfaceKHR</span>,
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>        device.destroy_device(None);
</span></span><span style="display:flex;"><span>        debug_utils.destroy_debug_utils_messenger(messenger, None);
</span></span><span style="display:flex;"><span>        surface_ext.destroy_surface(surface, None);
</span></span><span style="display:flex;"><span>        instance.destroy_instance(None);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h1 id="checking-for-presentation-queues">Checking for presentation queues<a hidden class="anchor" aria-hidden="true" href="#checking-for-presentation-queues">#</a></h1>
<p>We need to check that the physical device we&rsquo;re selecting actually has support for presenting to a surface, as we&rsquo;ll need to use a queue from a family with the presentation capabilities when we come to making our swapchain.</p>
<p>Now that we&rsquo;ve got to track two family indices and we want two queues for commands, we need to change the struct containing our family indices to hold Option<!-- raw HTML omitted -->&rsquo;s instead. We&rsquo;ll also add a method to check if the indices set is complete</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">QueueFamilyIndices</span> {
</span></span><span style="display:flex;"><span>    graphics_family: Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u32</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    presentation_family: Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u32</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> QueueFamilyIndices {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">is_complete</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>        self.graphics_family.is_some() <span style="color:#f92672">&amp;&amp;</span> self.presentation_family.is_some()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>We do need to route through the <strong>Surface</strong> extension object to access the functions relating to this extension, because we&rsquo;ll be using one of them to check if the physical device queue family supports presentation to our surface.</p>
<p>We change the get_queue_family_indices function to initialise the struct holding the indices such that it&rsquo;s not holding anything initially:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> queue_family_indices <span style="color:#f92672">=</span> QueueFamilyIndices {
</span></span><span style="display:flex;"><span>    graphics_family: None,
</span></span><span style="display:flex;"><span>    presentation_family: None,
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p>As we&rsquo;re iterating over the queue families on the device, we&rsquo;ll set the appropriate index to Some if it matches. The graphics queue family index as before:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> props.queue_count <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> props.queue_flags.contains(vk::QueueFlags::<span style="color:#66d9ef">GRAPHICS</span>) {
</span></span><span style="display:flex;"><span>    queue_family_indices.graphics_family <span style="color:#f92672">=</span> Some(idx <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u32</span>);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>And then, for the presentation queue family index, we can use the extension method <strong>get_physical_device_surface_support</strong> which returns a VkResult if it fails. In the case of it failing we&rsquo;ll count that as no support for that family. Therefore the check looks as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Ok(surface_supported) <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsafe</span> { surface_ext.get_physical_device_surface_support(device, idx <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u32</span>, surface) }
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> surface_supported {
</span></span><span style="display:flex;"><span>        queue_family_indices.presentation_family <span style="color:#f92672">=</span> Some(idx <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u32</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>After performing both checks and setting if applicable, it might be the case our set of indices is complete - in which case it&rsquo;s fine for this physical device:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> queue_family_indices.is_complete() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Some(queue_family_indices);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h1 id="creating-the-second-queue-type">Creating the second queue type<a hidden class="anchor" aria-hidden="true" href="#creating-the-second-queue-type">#</a></h1>
<p>Now we have the index of the family to use for presentation, we need to tell Vulkan to create us a queue from that family. However, it could be (and probably is) the case that the graphics queue family also supports presentation, so we need to handle duplicate families being used for the same role.</p>
<p>First we add the second handle to our struct storing the queue handles:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">QueueHandles</span> {
</span></span><span style="display:flex;"><span>    graphics_queue: <span style="color:#a6e22e">vk</span>::Queue,
</span></span><span style="display:flex;"><span>    presentation_queue: <span style="color:#a6e22e">vk</span>::Queue,
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>We can look up the presentation queue after creation the same way as we did with the graphics queue with:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>presentation_queue: <span style="color:#a6e22e">unsafe</span> {
</span></span><span style="display:flex;"><span>    device.get_device_queue(queue_family_indices.presentation_family.unwrap(), <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>However for creating the logical device, and telling Vulkan to create us our queues we don&rsquo;t want to request two different queues if the family happens to be the same. To handle this case, we can make a vector of queue families and deduplicate, then create a queue create info for whichever ones are left after deduplication.</p>
<p>Therefore we do this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> indices <span style="color:#f92672">=</span> vec![
</span></span><span style="display:flex;"><span>    queue_family_indices.graphics_family.unwrap(),
</span></span><span style="display:flex;"><span>    queue_family_indices.presentation_family.unwrap(),
</span></span><span style="display:flex;"><span>];
</span></span><span style="display:flex;"><span>indices.dedup();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> infos <span style="color:#f92672">=</span> indices
</span></span><span style="display:flex;"><span>    .into_iter()
</span></span><span style="display:flex;"><span>    .map(<span style="color:#f92672">|</span>idx<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>vk::DeviceQueueCreateInfo::builder()
</span></span><span style="display:flex;"><span>            .queue_family_index(idx)
</span></span><span style="display:flex;"><span>            .queue_priorities(<span style="color:#f92672">&amp;</span>[<span style="color:#ae81ff">1.0</span>])
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    .collect::<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;&gt;</span>();</span></span></code></pre></div>
<p>And then pass them into the device creation info:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> device <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>    instance.create_device(
</span></span><span style="display:flex;"><span>        physical_device,
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>vk::DeviceCreateInfo::builder().queue_create_infos(<span style="color:#f92672">&amp;</span>infos),
</span></span><span style="display:flex;"><span>        None,
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>}<span style="color:#f92672">?</span>;</span></span></code></pre></div>
<h1 id="enabling-device-extensions">Enabling device extensions<a hidden class="anchor" aria-hidden="true" href="#enabling-device-extensions">#</a></h1>
<p>We will require the <strong>VK_KHR_swapchain</strong> <em>device</em> extension to be enabled when we create the Vulkan device in order to be able to use swapchain functionality to present images to the surface.</p>
<p>We will need to take this into consideration when selecting a PhysicalDevice to work with, so that we only select from those devices that support the swapchain extension. Additionally, we will need to tell Vulkan to enable these when we create the logical device.</p>
<p>The first thing we need to do is to define them in an array, which we can do with the CStr type that is then safe to work with in the other functions. We&rsquo;ll go ahead and use unsafe to safely construct a CStr from a null-terminated byte string:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> device_extensions <span style="color:#f92672">=</span> [<span style="color:#66d9ef">unsafe</span> { CStr::from_bytes_with_nul_unchecked(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;VK_KHR_swapchain</span><span style="color:#ae81ff">\0</span><span style="color:#e6db74">&#34;</span>) }];</span></span></code></pre></div>
<p>We need to pass this through to <strong>get_physical_device</strong> and <strong>create_logical_device</strong>.</p>
<p>For getting a physical device we need to ensure the physical device we choose actually supports the extension, so we change the code to add an additional check here:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> has_required_extensions <span style="color:#f92672">=</span> validate_required_device_extensions(instance, physical_device, required_extensions)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> has_required_extensions {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Ok((physical_device, queue_family_indices));
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>The validate_required_device_extensions function is the same as the other ones we&rsquo;ve been writing except this time I decided to write it as a safe function that takes a slice of CStr references and handle the unsafety inside the function&hellip;..no particular reason, but having safe APIs is normally better.</p>
<p>The function itself just gets the supported device extensions for a physical device and checks to make sure our required ones are in there. The difference is that there can be multiple PhysicalDevices in a machine, and not having a required extension isn&rsquo;t an immediate issue, we just pass over that physical device - so we don&rsquo;t return Err explicitly this time, only when a Vulkan API call changes:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">validate_required_device_extensions</span>(
</span></span><span style="display:flex;"><span>    instance: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Instance</span>,
</span></span><span style="display:flex;"><span>    physical_device: <span style="color:#a6e22e">vk</span>::PhysicalDevice,
</span></span><span style="display:flex;"><span>    required_extensions: <span style="color:#66d9ef">&amp;</span>[<span style="color:#f92672">&amp;</span>CStr],
</span></span><span style="display:flex;"><span>) -&gt; Result<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> device_extension_properties <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>                instance.enumerate_device_extension_properties(physical_device)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> available_extensions <span style="color:#f92672">=</span> device_extension_properties
</span></span><span style="display:flex;"><span>                .iter()
</span></span><span style="display:flex;"><span>                .map(<span style="color:#f92672">|</span>prop<span style="color:#f92672">|</span> CStr::from_ptr(prop.extension_name.as_ptr()))
</span></span><span style="display:flex;"><span>                .collect::<span style="color:#f92672">&lt;</span>HashSet<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;&gt;</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> required_extension <span style="color:#66d9ef">in</span> required_extensions {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>available_extensions.contains(required_extension) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> Ok::<span style="color:#f92672">&lt;</span>_, Error<span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        Ok::<span style="color:#f92672">&lt;</span>_, Error<span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    .context(<span style="color:#e6db74">&#34;Error in validate_required_device_extensions.&#34;</span>)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>The second time we need the extensions are when creating the logical device. However in that case, we do need to extract the raw pointers from the CStrs since the builder for creating a new Vulkan device is taking a &amp;[*const i8] rather than a &amp;[&amp;CStr]. We can&rsquo;t transmute the memory directly unfortunately so we need to create a secondary collection with the transformed pointers. Then we add them to the device create info:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> device <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> required_extensions <span style="color:#f92672">=</span> required_extensions
</span></span><span style="display:flex;"><span>        .iter()
</span></span><span style="display:flex;"><span>        .map(<span style="color:#f92672">|</span>cstr<span style="color:#f92672">|</span> cstr.as_ptr())
</span></span><span style="display:flex;"><span>        .collect::<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;&gt;</span>();
</span></span><span style="display:flex;"><span>    instance.create_device(
</span></span><span style="display:flex;"><span>        physical_device,
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>vk::DeviceCreateInfo::builder()
</span></span><span style="display:flex;"><span>            .queue_create_infos(<span style="color:#f92672">&amp;</span>infos)
</span></span><span style="display:flex;"><span>            .enabled_extension_names(<span style="color:#f92672">&amp;</span>required_extensions),
</span></span><span style="display:flex;"><span>        None,
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>}<span style="color:#f92672">?</span>;</span></span></code></pre></div>
<h1 id="getting-surface-information">Getting surface information<a hidden class="anchor" aria-hidden="true" href="#getting-surface-information">#</a></h1>
<p>Another thing we need to do is to get information about the surface capabilities of the physical device so that we can make use of that information when we need to set up a swap chain.</p>
<p>We&rsquo;ll first create a struct to hold the information. The information we&rsquo;ll keep hold of is:</p>
<ol>
<li>The available formats for data on the surface (e.g. RGBA)</li>
<li>The avalable presentation modes for strategies and timings of when the image swapping in a swapchain actually happens</li>
<li>The assorted capabilities of the surface such as maximum number of images, minimum number, etc.</li>
</ol>
<p>The struct looks as follows. We also add an is_valid method that ensures there&rsquo;s at least 1 supported format and presentation mode:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SurfaceInfo</span> {
</span></span><span style="display:flex;"><span>    present_modes: Vec<span style="color:#f92672">&lt;</span>PresentModeKHR<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    surface_formats: Vec<span style="color:#f92672">&lt;</span>SurfaceFormatKHR<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    surface_capabilities: <span style="color:#a6e22e">SurfaceCapabilitiesKHR</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> SurfaceInfo {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">is_valid</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">!</span>self.present_modes.is_empty() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>self.surface_formats.is_empty()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>We&rsquo;ll look up all of these things in a function called <strong>get_surface_info</strong> which calls the functions to retrieve the information through unsafe code. The function itself will return a Result because it&rsquo;s fallible (each of the FFI calls returns a VkResult so they&rsquo;re fallible). But there&rsquo;s nothing surprising about it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_surface_info</span>(
</span></span><span style="display:flex;"><span>    surface_ext: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Surface</span>,
</span></span><span style="display:flex;"><span>    physical_device: <span style="color:#a6e22e">vk</span>::PhysicalDevice,
</span></span><span style="display:flex;"><span>    surface: <span style="color:#a6e22e">SurfaceKHR</span>,
</span></span><span style="display:flex;"><span>) -&gt; Result<span style="color:#f92672">&lt;</span>SurfaceInfo<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> present_modes <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>            surface_ext.get_physical_device_surface_present_modes(physical_device, surface)
</span></span><span style="display:flex;"><span>        }<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> surface_capabilities <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>            surface_ext.get_physical_device_surface_capabilities(physical_device, surface)
</span></span><span style="display:flex;"><span>        }<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> surface_formats <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">unsafe</span> { surface_ext.get_physical_device_surface_formats(physical_device, surface) }<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>        Ok::<span style="color:#f92672">&lt;</span>_, Error<span style="color:#f92672">&gt;</span>(SurfaceInfo {
</span></span><span style="display:flex;"><span>            present_modes,
</span></span><span style="display:flex;"><span>            surface_capabilities,
</span></span><span style="display:flex;"><span>            surface_formats,
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    .context(<span style="color:#e6db74">&#34;Error when trying to get surface information for a physical device.&#34;</span>)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://forgottenmaster.github.io/">Robin Smith</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
