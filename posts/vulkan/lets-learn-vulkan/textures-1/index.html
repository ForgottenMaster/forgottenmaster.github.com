<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>17. Textures Part 1 | Robin Smith</title>
<meta name="keywords" content="">
<meta name="description" content="So far we have two animated but flat-color shaded quads in the scene, but we will often want to be able to render textures to models in an actual application. This post focuses on loading the image data into memory,and setting up pipeline barriers for getting the image into the correct format for the correct part of the pipeline. The next post will deal with actually setting up descriptors and allowing the shader to access the image through a sampler.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/vulkan/lets-learn-vulkan/textures-1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/vulkan/lets-learn-vulkan/textures-1/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Robin Smith (Alt + H)">Robin Smith</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/resume/" title="Résumé">
                    <span>Résumé</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/vulkan/">Vulkan</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/vulkan/lets-learn-vulkan/">Let&#39;s Learn Vulkan</a></div>
    <h1 class="post-title entry-hint-parent">
      17. Textures Part 1
    </h1>
    <div class="post-meta"><span title='2024-03-31 14:30:59 +0100 BST'>March 31, 2024</span>&nbsp;·&nbsp;16 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#loading-image-from-file" aria-label="Loading Image From File">Loading Image From File</a></li>
                <li>
                    <a href="#making-helper-functions" aria-label="Making Helper Functions">Making Helper Functions</a></li>
                <li>
                    <a href="#copy-image-buffer-function" aria-label="Copy Image Buffer Function">Copy Image Buffer Function</a></li>
                <li>
                    <a href="#transition-image-layout-function" aria-label="Transition Image Layout Function">Transition Image Layout Function</a></li>
                <li>
                    <a href="#texture-struct" aria-label="Texture Struct">Texture Struct</a></li>
                <li>
                    <a href="#create-texture-function" aria-label="Create Texture Function">Create Texture Function</a><ul>
                        
                <li>
                    <a href="#1-loading-the-file" aria-label="1. Loading the file">1. Loading the file</a></li>
                <li>
                    <a href="#2-creating-a-staging-buffer" aria-label="2. Creating a staging buffer">2. Creating a staging buffer</a></li>
                <li>
                    <a href="#3-copying-data-into-the-staging-buffer" aria-label="3. Copying data into the staging buffer">3. Copying data into the staging buffer</a></li>
                <li>
                    <a href="#4-find-a-supported-image-format" aria-label="4. Find a supported image format">4. Find a supported image format</a></li>
                <li>
                    <a href="#5-creating-the-image" aria-label="5. Creating the image">5. Creating the image</a></li>
                <li>
                    <a href="#6-copying-the-buffer-to-the-image" aria-label="6. Copying the buffer to the image">6. Copying the buffer to the image</a></li>
                <li>
                    <a href="#7-cleanup-and-return" aria-label="7. Cleanup and return">7. Cleanup and return</a></li></ul>
                </li>
                <li>
                    <a href="#creating-the-texture" aria-label="Creating the texture">Creating the texture</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>So far we have two animated but flat-color shaded quads in the scene, but we will often want to be able to render textures to models in an actual application. This post focuses on loading the image data into memory,and setting up pipeline barriers for getting the image into the correct format for the correct part of the pipeline. The next post will deal with actually setting up descriptors and allowing the shader to access the image through a sampler.</p>
<h1 id="loading-image-from-file">Loading Image From File<a hidden class="anchor" aria-hidden="true" href="#loading-image-from-file">#</a></h1>
<p>Firstly we will need to be able to load an image from an image file we have. We can do this in Rust with the image crate easily, and we&rsquo;ll make a function for loading the image data from file so we can just call it multiple times.</p>
<p>The function itself looks as follows</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">load_image_from_file</span>(path: <span style="color:#a6e22e">impl</span> AsRef<span style="color:#f92672">&lt;</span>Path<span style="color:#f92672">&gt;</span> <span style="color:#f92672">+</span> Clone <span style="color:#f92672">+</span> Display) -&gt; Result<span style="color:#f92672">&lt;</span>(Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span>, <span style="color:#66d9ef">u32</span>, <span style="color:#66d9ef">u32</span>)<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> image <span style="color:#f92672">=</span> image::io::Reader::open(path.clone())
</span></span><span style="display:flex;"><span>        .with_context(<span style="color:#f92672">||</span> format!(<span style="color:#e6db74">&#34;Loading image from file path: </span><span style="color:#e6db74">{path}</span><span style="color:#e6db74">&#34;</span>))<span style="color:#f92672">?</span>
</span></span><span style="display:flex;"><span>        .decode()
</span></span><span style="display:flex;"><span>        .with_context(<span style="color:#f92672">||</span> format!(<span style="color:#e6db74">&#34;Decoding image loaded from file path: </span><span style="color:#e6db74">{path}</span><span style="color:#e6db74">&#34;</span>))<span style="color:#f92672">?</span>
</span></span><span style="display:flex;"><span>        .into_rgba8();
</span></span><span style="display:flex;"><span>    Ok((image.as_bytes().to_owned(), image.width(), image.height()))
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>For the function, we take a path which is any type with the following traits:</p>
<ol>
<li><strong>AsRef<!-- raw HTML omitted --></strong> =&gt; Required because the image reader opening function requires this trait</li>
<li><strong>Clone</strong> =&gt; Required because we&rsquo;re needing to reuse path for the error reporting message</li>
<li><strong>Display</strong> =&gt; Required so that the error messages can incorporate the path for more information</li>
</ol>
<p>The function then returns a tuple with:</p>
<ol>
<li>The bytes of the image</li>
<li>The width of the image</li>
<li>The height of the image</li>
</ol>
<p>Inside the function we simply use the <strong>Reader</strong> type from the image crate with the file path, and then call decode after loading to get a <strong>DynamicImage</strong>. We need to put error handling on both loading and decoding the image, which is why <strong>with_context</strong> is used.</p>
<p>The image may be in any format, but we want to guarantee RGBA8 so as to make the code easier (we only have to write it for one image format), therefore we use the into_rgba8 method to convert the data if needed.</p>
<p>For our purposes we&rsquo;ll test that the loading is correct with the following call in main</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> (_image_bytes, _width, _height) <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    load_image_from_file(<span style="color:#e6db74">&#34;assets/textures/image1.jpg&#34;</span>).context(<span style="color:#e6db74">&#34;Loading image1.jpg&#34;</span>)<span style="color:#f92672">?</span>;</span></span></code></pre></div>
<p>And we&rsquo;ll use the following image at that location</p>
<p><img loading="lazy" src="image1.jpg" alt="Image 1"  />
</p>
<h1 id="making-helper-functions">Making Helper Functions<a hidden class="anchor" aria-hidden="true" href="#making-helper-functions">#</a></h1>
<p>Before moving onto making a function to create a texture, we will need to implement a copy command buffer to image function. Before we do that however, there&rsquo;s a couple of parts that are shared between this copying and the copying we&rsquo;re already doing, with respect to command buffers.</p>
<p>We still want to be able to create/allocate a command buffer and set it to be one time submit, and we want to be able to end recording and submit the buffer to the queue.</p>
<p>We can do this by copying the code we have already inside create_staged_buffer into a couple of helper functions which are simple enough to just display here</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">begin_command_buffer</span>(device: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Device</span>, command_pool: <span style="color:#a6e22e">CommandPool</span>) -&gt; Result<span style="color:#f92672">&lt;</span>CommandBuffer<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> command_buffer <span style="color:#f92672">=</span> device
</span></span><span style="display:flex;"><span>            .allocate_command_buffers(
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">&amp;</span>CommandBufferAllocateInfo::builder()
</span></span><span style="display:flex;"><span>                    .command_pool(command_pool)
</span></span><span style="display:flex;"><span>                    .level(CommandBufferLevel::<span style="color:#66d9ef">PRIMARY</span>)
</span></span><span style="display:flex;"><span>                    .command_buffer_count(<span style="color:#ae81ff">1</span>),
</span></span><span style="display:flex;"><span>            )
</span></span><span style="display:flex;"><span>            .context(<span style="color:#e6db74">&#34;Failed to allocate a command buffer.&#34;</span>)<span style="color:#f92672">?</span>[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        device
</span></span><span style="display:flex;"><span>            .begin_command_buffer(
</span></span><span style="display:flex;"><span>                command_buffer,
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">&amp;</span>CommandBufferBeginInfo::builder().flags(CommandBufferUsageFlags::<span style="color:#66d9ef">ONE_TIME_SUBMIT</span>),
</span></span><span style="display:flex;"><span>            )
</span></span><span style="display:flex;"><span>            .context(<span style="color:#e6db74">&#34;Failed to begin recording the command buffer.&#34;</span>)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Ok(command_buffer)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">end_and_submit_command_buffer</span>(
</span></span><span style="display:flex;"><span>    device: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Device</span>,
</span></span><span style="display:flex;"><span>    queue: <span style="color:#a6e22e">Queue</span>,
</span></span><span style="display:flex;"><span>    command_pool: <span style="color:#a6e22e">CommandPool</span>,
</span></span><span style="display:flex;"><span>    command_buffer: <span style="color:#a6e22e">CommandBuffer</span>,
</span></span><span style="display:flex;"><span>) -&gt; Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>        device
</span></span><span style="display:flex;"><span>            .end_command_buffer(command_buffer)
</span></span><span style="display:flex;"><span>            .context(<span style="color:#e6db74">&#34;Failed to end recording the command buffer.&#34;</span>)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> command_buffers <span style="color:#f92672">=</span> [command_buffer];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> submit_infos <span style="color:#f92672">=</span> [<span style="color:#f92672">*</span>SubmitInfo::builder().command_buffers(<span style="color:#f92672">&amp;</span>command_buffers)];
</span></span><span style="display:flex;"><span>        device
</span></span><span style="display:flex;"><span>            .queue_submit(queue, <span style="color:#f92672">&amp;</span>submit_infos, Fence::null())
</span></span><span style="display:flex;"><span>            .context(<span style="color:#e6db74">&#34;Failed to submit the command buffer to the queue.&#34;</span>)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>        device
</span></span><span style="display:flex;"><span>            .queue_wait_idle(queue)
</span></span><span style="display:flex;"><span>            .context(<span style="color:#e6db74">&#34;Failed to wait for the transfer to finish.&#34;</span>)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        device.free_command_buffers(command_pool, <span style="color:#f92672">&amp;</span>[command_buffer]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Ok(())
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h1 id="copy-image-buffer-function">Copy Image Buffer Function<a hidden class="anchor" aria-hidden="true" href="#copy-image-buffer-function">#</a></h1>
<p>We want to be able to copy image data from a buffer to an image, so we should make a reusable function to do this which we&rsquo;ll call copy_image_buffer.</p>
<p>The functionality of this function will be to take a source buffer holding the data (this will be the staging buffer we will make in the create_texture function a bit later), and a destination image. We need to also specify the width and height of the image so Vulkan knows the row length.</p>
<p>We do the copy on the transfer queue, which is gonna be the same as the graphics queue because graphics can also perform transfers (however it could be a different queue in theory).</p>
<p>The signature of the function will be as follows</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">copy_image_buffer</span>(
</span></span><span style="display:flex;"><span>    device: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Device</span>,
</span></span><span style="display:flex;"><span>    transfer_queue: <span style="color:#a6e22e">Queue</span>,
</span></span><span style="display:flex;"><span>    transfer_command_pool: <span style="color:#a6e22e">CommandPool</span>,
</span></span><span style="display:flex;"><span>    src_buffer: <span style="color:#a6e22e">Buffer</span>,
</span></span><span style="display:flex;"><span>    dst_image: <span style="color:#a6e22e">Image</span>,
</span></span><span style="display:flex;"><span>    width: <span style="color:#66d9ef">u32</span>,
</span></span><span style="display:flex;"><span>    height: <span style="color:#66d9ef">u32</span>,
</span></span><span style="display:flex;"><span>) -&gt; Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span></span></span></code></pre></div>
<p>We don&rsquo;t need any data as such, but we still need to return anyhow::Result because one of the steps of the process may fail.</p>
<p>The first step is to use the <strong>begin_command_buffer</strong> helper function we made above to allocate and begin recording of a command buffer. This may fail for example if we can&rsquo;t allocate any more buffers from the pool or something like that.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> transfer_command_buffer <span style="color:#f92672">=</span> begin_command_buffer(device, transfer_command_pool)
</span></span><span style="display:flex;"><span>    .context(<span style="color:#e6db74">&#34;Beginning command buffer recording for copy_image_buffer&#34;</span>)<span style="color:#f92672">?</span>;</span></span></code></pre></div>
<p>There are a few pieces of data required to specify what to copy where when doing an image transfer from a buffer.</p>
<p>The first will be the subresource information which tells Vulkan which layer or level, or even channel of the destination image we&rsquo;re copying the data to</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> image_subresource <span style="color:#f92672">=</span> ImageSubresourceLayers::builder()
</span></span><span style="display:flex;"><span>    .aspect_mask(ImageAspectFlags::<span style="color:#66d9ef">COLOR</span>)
</span></span><span style="display:flex;"><span>    .mip_level(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    .base_array_layer(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    .layer_count(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    .build();</span></span></code></pre></div>
<p>Here we specify:</p>
<ol>
<li><strong>aspect_mask</strong> =&gt; This specifies the aspects of the image we&rsquo;re copying to such as depth, color, etc. In our case we&rsquo;re copying the color data.</li>
<li><strong>mip_level</strong> =&gt; This specifies the MIP level we&rsquo;re copying. We aren&rsquo;t using MIP levels though, so we specify level 0.</li>
<li><strong>base_array_layer</strong> =&gt; This specifies the index of the first layer we&rsquo;re copying in the image (for multi-layer images). We&rsquo;re only using one layer though, so index is set to 0.</li>
<li><strong>layer_count</strong> =&gt; This is the number of layers we&rsquo;re copying in the image. We&rsquo;re only using one layer, so this is set to 1.</li>
</ol>
<p>Secondly we need to define the offset (in 3-dimensions) of the copy in the destination image, which we can form with the Offset3D type</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> offset_3d <span style="color:#f92672">=</span> Offset3D::builder().x(<span style="color:#ae81ff">0</span>).y(<span style="color:#ae81ff">0</span>).z(<span style="color:#ae81ff">0</span>).build();</span></span></code></pre></div>
<p>This one is very simple, because we&rsquo;re copying the entire image, from the beginning, so there is no offset in any axis.</p>
<p>Next up, now that we&rsquo;ve determined <em>where</em> to copy to in the image, we need to determine <em>how much</em> to copy. We can do this with the Extent3D type.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> extent_3d <span style="color:#f92672">=</span> Extent3D::builder()
</span></span><span style="display:flex;"><span>    .width(width)
</span></span><span style="display:flex;"><span>    .height(height)
</span></span><span style="display:flex;"><span>    .depth(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    .build();</span></span></code></pre></div>
<p>Here we specify:</p>
<ol>
<li><strong>width</strong> =&gt; The width of the image, which we pass in since we receive it as a parameter to the copy_image_buffer function</li>
<li><strong>height</strong> =&gt; The height of the image, which we can also simply pass in as it&rsquo;s received into the function</li>
<li><strong>depth</strong> =&gt; The depth of the image, which is 1 here because we&rsquo;re using a 2D image</li>
</ol>
<p>Finally we can make the actual description of the image copy arguments:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> buffer_image_copy <span style="color:#f92672">=</span> BufferImageCopy::builder()
</span></span><span style="display:flex;"><span>    .buffer_offset(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    .buffer_row_length(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    .buffer_image_height(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    .image_subresource(image_subresource)
</span></span><span style="display:flex;"><span>    .image_offset(offset_3d)
</span></span><span style="display:flex;"><span>    .image_extent(extent_3d)
</span></span><span style="display:flex;"><span>    .build();</span></span></code></pre></div>
<p>The <strong>image_subresource</strong>, <strong>image_offset</strong>, and <strong>image_extent</strong> are already specified above, so we can just pass those in as they&rsquo;re self-explanatory. Apart from this we have:</p>
<ol>
<li><strong>buffer_offset</strong> =&gt; This is the offset into the source buffer that we are copying the data from. It allows the same buffer to hold many pieces of data if needed.</li>
<li><strong>buffer_row_length</strong> =&gt; This specifies the length of a row in texels in the buffer memory of a sub-image. If 0 it&rsquo;s ignored, and image_extent.width is used. If non-zero then must be equal or greater than image_extent.width</li>
<li><strong>buffer_image_height</strong> =&gt; This specifies the height in texels in the buffer memory of a sub-image to copy from. If 0 it&rsquo;s ignored, and image_extent.height is used. If non-zero then must be equal or greater than image_extent.height</li>
</ol>
<p>Finally, we perform the actual transfer operation. The only thing of note here is that we want the image layout to be put into <strong>TRANSFER_DST_OPTIMAL</strong> for the transfer to happen fast.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>device.cmd_copy_buffer_to_image(
</span></span><span style="display:flex;"><span>    transfer_command_buffer,
</span></span><span style="display:flex;"><span>    src_buffer,
</span></span><span style="display:flex;"><span>    dst_image,
</span></span><span style="display:flex;"><span>    ImageLayout::<span style="color:#66d9ef">TRANSFER_DST_OPTIMAL</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&amp;</span>[buffer_image_copy],
</span></span><span style="display:flex;"><span>);</span></span></code></pre></div>
<p>Finally we can end recording of the command buffer, and submit it to the transfer queue to actually perform the operation. Again this may fail, so we add some context in case it does</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>end_and_submit_command_buffer(
</span></span><span style="display:flex;"><span>    device,
</span></span><span style="display:flex;"><span>    transfer_queue,
</span></span><span style="display:flex;"><span>    transfer_command_pool,
</span></span><span style="display:flex;"><span>    transfer_command_buffer,
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>.context(<span style="color:#e6db74">&#34;Ending and submitting command buffer recording in copy_image_buffer&#34;</span>)</span></span></code></pre></div>
<h1 id="transition-image-layout-function">Transition Image Layout Function<a hidden class="anchor" aria-hidden="true" href="#transition-image-layout-function">#</a></h1>
<p>In order to be able to use the image we&rsquo;ve allocated, we first need to be able to put it into the correct format for the way we&rsquo;ll be using it.</p>
<p>Vulkan requires us to allocate the image initially with either undefined layout, or preinitialized but we can&rsquo;t keep it in that layout.</p>
<p>We will need to do a couple of transitions during the texture creation process, so I introduce a helper function with the following signature</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">transition_image_layout</span>(
</span></span><span style="display:flex;"><span>    device: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Device</span>,
</span></span><span style="display:flex;"><span>    queue: <span style="color:#a6e22e">Queue</span>,
</span></span><span style="display:flex;"><span>    command_pool: <span style="color:#a6e22e">CommandPool</span>,
</span></span><span style="display:flex;"><span>    image: <span style="color:#a6e22e">Image</span>,
</span></span><span style="display:flex;"><span>    old_layout: <span style="color:#a6e22e">ImageLayout</span>,
</span></span><span style="display:flex;"><span>    new_layout: <span style="color:#a6e22e">ImageLayout</span>,
</span></span><span style="display:flex;"><span>) -&gt; Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span></span></span></code></pre></div>
<p>We need to pass the usual (device, queue, and command pool) but the things that are important for this function are:</p>
<ol>
<li><strong>image</strong> =&gt; The image that we are wanting to transition the layout of</li>
<li><strong>old_layout</strong> =&gt; The layout that we&rsquo;re transitioning from</li>
<li><strong>new_layout</strong> =&gt; The layout that we&rsquo;re wanting to transition to</li>
</ol>
<p>The first step to implementing this function will be to allocate and begin a command buffer from the pool. Luckily we have a function for this</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> command_buffer <span style="color:#f92672">=</span> begin_command_buffer(device, command_pool)
</span></span><span style="display:flex;"><span>    .context(<span style="color:#e6db74">&#34;Beginning a command buffer for transitioning image layout&#34;</span>)<span style="color:#f92672">?</span>;</span></span></code></pre></div>
<p>For the transition, we need to identify which subresource range of the image we&rsquo;re actually transitioning. This allows for a single Image resource in Vulkan to have multiple independant sub images, and we might only transition one of those.</p>
<p>In our case however the entire image is a single resource with no subresources. Therefore this looks the same as it did in the create_image function</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> subresource_range <span style="color:#f92672">=</span> ImageSubresourceRange::builder()
</span></span><span style="display:flex;"><span>    .aspect_mask(ImageAspectFlags::<span style="color:#66d9ef">COLOR</span>)
</span></span><span style="display:flex;"><span>    .base_mip_level(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    .level_count(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    .base_array_layer(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    .layer_count(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    .build();</span></span></code></pre></div>
<p>The second piece of information we will need is the actual description of the memory barrier we will be setting up. This barrier tells Vulkan when to perform the transition, and what the format change is.</p>
<p>Before we can set up this description however, there are a few pieces of information that are dependant on the layout transition we&rsquo;re performing. Rust makes it easy to represent as a match expression. However for creating a texture, there is only an immediate need for 2 particular transitions. We&rsquo;ll just return an error if anything else is given.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> (src_access_mask, dst_access_mask, src_stage_flags, dst_stage_flags) <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> (old_layout, new_layout) {
</span></span><span style="display:flex;"><span>        (ImageLayout::<span style="color:#66d9ef">UNDEFINED</span>, ImageLayout::<span style="color:#66d9ef">TRANSFER_DST_OPTIMAL</span>) <span style="color:#f92672">=&gt;</span> (
</span></span><span style="display:flex;"><span>            AccessFlags::<span style="color:#66d9ef">NONE</span>,
</span></span><span style="display:flex;"><span>            AccessFlags::<span style="color:#66d9ef">TRANSFER_WRITE</span>,
</span></span><span style="display:flex;"><span>            PipelineStageFlags::<span style="color:#66d9ef">TOP_OF_PIPE</span>,
</span></span><span style="display:flex;"><span>            PipelineStageFlags::<span style="color:#66d9ef">TRANSFER</span>,
</span></span><span style="display:flex;"><span>        ),
</span></span><span style="display:flex;"><span>        (ImageLayout::<span style="color:#66d9ef">TRANSFER_DST_OPTIMAL</span>, ImageLayout::<span style="color:#66d9ef">SHADER_READ_ONLY_OPTIMAL</span>) <span style="color:#f92672">=&gt;</span> (
</span></span><span style="display:flex;"><span>            AccessFlags::<span style="color:#66d9ef">TRANSFER_WRITE</span>,
</span></span><span style="display:flex;"><span>            AccessFlags::<span style="color:#66d9ef">SHADER_READ</span>,
</span></span><span style="display:flex;"><span>            PipelineStageFlags::<span style="color:#66d9ef">TRANSFER</span>,
</span></span><span style="display:flex;"><span>            PipelineStageFlags::<span style="color:#66d9ef">FRAGMENT_SHADER</span>,
</span></span><span style="display:flex;"><span>        ),
</span></span><span style="display:flex;"><span>        _ <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> Err(anyhow!(
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;Unsupported image layout transition from {old_layout:?} to {new_layout:?}&#34;</span>
</span></span><span style="display:flex;"><span>            ))
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };</span></span></code></pre></div>
<p>A brief description of the produced values is:</p>
<ol>
<li><strong>src_access_mask</strong> =&gt; This defines the type of access within the source stages which represents the earliest opportunity that this barrier can be placed</li>
<li><strong>dst_access_mask</strong> =&gt; This defines the type of access within the destination stages and represents the latest opportunity for this barrier to be placed</li>
<li><strong>src_stage_flags</strong> =&gt; This defines the earliest stage in the pipeline that this barrier can be placed</li>
<li><strong>dst_stage_flags</strong> =&gt; This defines the latest stage in the pipeline that this barrier can be placed</li>
</ol>
<p>Now we have these we can go ahead and set up the description of our image memory barrier</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> memory_barrier <span style="color:#f92672">=</span> ImageMemoryBarrier::builder()
</span></span><span style="display:flex;"><span>    .old_layout(old_layout)
</span></span><span style="display:flex;"><span>    .new_layout(new_layout)
</span></span><span style="display:flex;"><span>    .src_queue_family_index(<span style="color:#66d9ef">QUEUE_FAMILY_IGNORED</span>)
</span></span><span style="display:flex;"><span>    .dst_queue_family_index(<span style="color:#66d9ef">QUEUE_FAMILY_IGNORED</span>)
</span></span><span style="display:flex;"><span>    .image(image)
</span></span><span style="display:flex;"><span>    .subresource_range(subresource_range)
</span></span><span style="display:flex;"><span>    .src_access_mask(src_access_mask)
</span></span><span style="display:flex;"><span>    .dst_access_mask(dst_access_mask)
</span></span><span style="display:flex;"><span>    .build();</span></span></code></pre></div>
<p>Most of the parameters will be self explanatory, but we have two here <strong>src_queue_family_index</strong> and <strong>dst_queue_family_index</strong> which might need a little explaining.</p>
<p>These are used in the case that the transition also moves ownership of the image from on queue family to another. However in our case, we are keeping the image on the same queue and so we can ignore both of these parameters.</p>
<p>With all of the data in place that we need to actually tell Vulkan about the pipeline barrier, we can record it into the command buffer with the following that should also be self-explanatory</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>    device.cmd_pipeline_barrier(
</span></span><span style="display:flex;"><span>        command_buffer,
</span></span><span style="display:flex;"><span>        src_stage_flags,
</span></span><span style="display:flex;"><span>        dst_stage_flags,
</span></span><span style="display:flex;"><span>        DependencyFlags::empty(),
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>[],
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>[],
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>[memory_barrier],
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Finally, one last thing left is to actually end the command buffer recording and submit it to the queue. This is just a call to the helper function we defined though</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>end_and_submit_command_buffer(device, queue, command_pool, command_buffer)
</span></span><span style="display:flex;"><span>    .context(<span style="color:#e6db74">&#34;Ending a command buffer for transitioning image layout&#34;</span>)<span style="color:#f92672">?</span>;</span></span></code></pre></div>
<h1 id="texture-struct">Texture Struct<a hidden class="anchor" aria-hidden="true" href="#texture-struct">#</a></h1>
<p>To make it easier to pass things around, we&rsquo;ll bundle up the data for a Texture into a struct which looks as follows</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Texture</span> {
</span></span><span style="display:flex;"><span>    image: <span style="color:#a6e22e">Image</span>,
</span></span><span style="display:flex;"><span>    image_memory: <span style="color:#a6e22e">DeviceMemory</span>,
</span></span><span style="display:flex;"><span>    _width: <span style="color:#66d9ef">u32</span>,
</span></span><span style="display:flex;"><span>    _height: <span style="color:#66d9ef">u32</span>,
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>The fields are self explanatory, however a note here is the <strong>_width</strong> and <strong>_height</strong> fields are prefixed with underscores to show that they&rsquo;re unused (at the moment), but stored in case we do need them.</p>
<h1 id="create-texture-function">Create Texture Function<a hidden class="anchor" aria-hidden="true" href="#create-texture-function">#</a></h1>
<p>With the above all implemented, we can now implement the actual <strong>create_texture</strong> function which the main program will then use to get Vulkan to prepare an <strong>Image</strong> and allocated memory. The signature will look as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">create_texture</span>(
</span></span><span style="display:flex;"><span>    instance: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Instance</span>,
</span></span><span style="display:flex;"><span>    device: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Device</span>,
</span></span><span style="display:flex;"><span>    physical_device: <span style="color:#a6e22e">PhysicalDevice</span>,
</span></span><span style="display:flex;"><span>    transfer_queue: <span style="color:#a6e22e">Queue</span>,
</span></span><span style="display:flex;"><span>    transfer_command_pool: <span style="color:#a6e22e">CommandPool</span>,
</span></span><span style="display:flex;"><span>    path: <span style="color:#a6e22e">impl</span> AsRef<span style="color:#f92672">&lt;</span>Path<span style="color:#f92672">&gt;</span> <span style="color:#f92672">+</span> Clone <span style="color:#f92672">+</span> Display,
</span></span><span style="display:flex;"><span>) -&gt; Result<span style="color:#f92672">&lt;</span>Texture<span style="color:#f92672">&gt;</span></span></span></code></pre></div>
<p>The parameters are self-explanatory here as they&rsquo;ve been passed into various other functions thus far. Of special note is the <strong>path</strong> parameter which has an opaque trait type. This is the same type (combination of traits) as is passed into the file loading function.</p>
<h2 id="1-loading-the-file">1. Loading the file<a hidden class="anchor" aria-hidden="true" href="#1-loading-the-file">#</a></h2>
<p>The first step will be to load the file at the given path, and then calculate the total amount of bytes that are in the image data.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> (image_data, width, height) <span style="color:#f92672">=</span> load_image_from_file(path.clone())
</span></span><span style="display:flex;"><span>    .with_context(<span style="color:#f92672">||</span> format!(<span style="color:#e6db74">&#34;Attempting to create texture for image at path </span><span style="color:#e6db74">{path}</span><span style="color:#e6db74">&#34;</span>))<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> image_size <span style="color:#f92672">=</span> (width <span style="color:#f92672">*</span> height <span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span>) <span style="color:#66d9ef">as</span> DeviceSize; <span style="color:#75715e">// 4 bytes per pixel RGBA8
</span></span></span></code></pre></div>
<p>Loading the image (and getting its width and height) is very simple as it&rsquo;s just delegated to the <strong>load_image_from_file</strong> function we implemented. However we do add another bit of context to the error report in case it does error.</p>
<p>For the total number of bytes we have in the image, we need to multiply the number of pixels (width * height) by the number of bytes per pixel, which we know is 4 (because load_image_from_file converts the image format to RGBA8 after load).</p>
<h2 id="2-creating-a-staging-buffer">2. Creating a staging buffer<a hidden class="anchor" aria-hidden="true" href="#2-creating-a-staging-buffer">#</a></h2>
<p>We will need to allocate a buffer that is host visible that we can copy our data into on the CPU. The data isn&rsquo;t kept there however and will be moved to GPU memory, so this is a temporary (or staging) buffer.</p>
<p>We can allocate it with the help of the <strong>create_buffer</strong> function that was made</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> (staging_buffer, staging_buffer_memory) <span style="color:#f92672">=</span> create_buffer(
</span></span><span style="display:flex;"><span>    instance,
</span></span><span style="display:flex;"><span>    device,
</span></span><span style="display:flex;"><span>    physical_device,
</span></span><span style="display:flex;"><span>    BufferUsageFlags::<span style="color:#66d9ef">TRANSFER_SRC</span>,
</span></span><span style="display:flex;"><span>    MemoryPropertyFlags::<span style="color:#66d9ef">HOST_VISIBLE</span> <span style="color:#f92672">|</span> MemoryPropertyFlags::<span style="color:#66d9ef">HOST_COHERENT</span>,
</span></span><span style="display:flex;"><span>    image_size,
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>.with_context(<span style="color:#f92672">||</span> format!(<span style="color:#e6db74">&#34;Attempting to create texture for image at path </span><span style="color:#e6db74">{path}</span><span style="color:#e6db74">&#34;</span>))<span style="color:#f92672">?</span>;</span></span></code></pre></div>
<p>Here we:</p>
<ol>
<li>Set BufferUsageFlags to TRANSFER_SRC. This is because the staging buffer will be copied <strong>from</strong></li>
<li>Set the MemoryPropertyFlags to HOST_VISIBLE and HOST_COHERENT. This is so we can memory map the buffer and copy our data into it</li>
<li>Set the number of bytes we&rsquo;re allocating to <strong>image_size</strong> which we&rsquo;ve calculated are the number of bytes in the image data</li>
</ol>
<h2 id="3-copying-data-into-the-staging-buffer">3. Copying data into the staging buffer<a hidden class="anchor" aria-hidden="true" href="#3-copying-data-into-the-staging-buffer">#</a></h2>
<p>Next we can copy the data we have into the buffer we&rsquo;ve allocated. This is an unsafe operation and as a refresher we need to:</p>
<ol>
<li>Call Device::map_memory in order to map the whole buffer memory, and return a (mutable) pointer to the data</li>
<li>Use ptr::copy_nonoverlapping to copy the entire data from our Vec of bytes to the buffer memory</li>
<li>Call Device::unmap_memory to close off writing and allow Vulkan to do whatever it needs to with the data to optimise it</li>
</ol>
<p>In code this looks as follows</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> write_ptr <span style="color:#f92672">=</span> device
</span></span><span style="display:flex;"><span>        .map_memory(
</span></span><span style="display:flex;"><span>            staging_buffer_memory,
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>            image_size,
</span></span><span style="display:flex;"><span>            MemoryMapFlags::empty(),
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>        .context(<span style="color:#e6db74">&#34;Failed to map the staging buffer memory.&#34;</span>)<span style="color:#f92672">?</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">as</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">mut</span> <span style="color:#66d9ef">u8</span>;
</span></span><span style="display:flex;"><span>    ptr::copy_nonoverlapping(image_data.as_ptr(), write_ptr, image_size <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>);
</span></span><span style="display:flex;"><span>    device.unmap_memory(staging_buffer_memory);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h2 id="4-find-a-supported-image-format">4. Find a supported image format<a hidden class="anchor" aria-hidden="true" href="#4-find-a-supported-image-format">#</a></h2>
<p>Now we have te data residing in (host visible) buffer memory, we need to create an Image as the destination to copy it to.</p>
<p>Before we can do this, we need to determine a suitable format for the image from those supported by the device.</p>
<p>Can just use the <strong>get_best_image_format</strong> function that was implemented previously:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> format <span style="color:#f92672">=</span> get_best_image_format(
</span></span><span style="display:flex;"><span>    instance,
</span></span><span style="display:flex;"><span>    physical_device,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&amp;</span>[Format::<span style="color:#66d9ef">R8G8B8A8_UNORM</span>],
</span></span><span style="display:flex;"><span>    ImageTiling::<span style="color:#66d9ef">OPTIMAL</span>,
</span></span><span style="display:flex;"><span>    FormatFeatureFlags::<span style="color:#66d9ef">TRANSFER_DST</span> <span style="color:#f92672">|</span> FormatFeatureFlags::<span style="color:#66d9ef">SAMPLED_IMAGE</span>,
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>.with_context(<span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>    format!(<span style="color:#e6db74">&#34;Attempting to find image format while creating a texture for image at path </span><span style="color:#e6db74">{path}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>})<span style="color:#f92672">?</span>;</span></span></code></pre></div>
<p>Nothing too surprising here:</p>
<ol>
<li>We want <strong>R8G8B8A8_UNORM</strong> as it fits our RGBA8 data</li>
<li>We want optimal tiling for the image</li>
<li>We will use the image as a transfer destination (from the buffer), and to sample from - so the format we use must support both</li>
</ol>
<h2 id="5-creating-the-image">5. Creating the image<a hidden class="anchor" aria-hidden="true" href="#5-creating-the-image">#</a></h2>
<p>We can now use the <strong>create_image</strong> function to actually allocate and create the image for us which looks as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> (image, image_memory) <span style="color:#f92672">=</span> create_image(
</span></span><span style="display:flex;"><span>    instance,
</span></span><span style="display:flex;"><span>    device,
</span></span><span style="display:flex;"><span>    physical_device,
</span></span><span style="display:flex;"><span>    width,
</span></span><span style="display:flex;"><span>    height,
</span></span><span style="display:flex;"><span>    ImageTiling::<span style="color:#66d9ef">OPTIMAL</span>,
</span></span><span style="display:flex;"><span>    ImageUsageFlags::<span style="color:#66d9ef">TRANSFER_DST</span> <span style="color:#f92672">|</span> ImageUsageFlags::<span style="color:#66d9ef">SAMPLED</span>,
</span></span><span style="display:flex;"><span>    ImageLayout::<span style="color:#66d9ef">UNDEFINED</span>,
</span></span><span style="display:flex;"><span>    format,
</span></span><span style="display:flex;"><span>    MemoryPropertyFlags::<span style="color:#66d9ef">DEVICE_LOCAL</span>,
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>.with_context(<span style="color:#f92672">||</span> format!(<span style="color:#e6db74">&#34;Attempting to create texture for image at path </span><span style="color:#e6db74">{path}</span><span style="color:#e6db74">&#34;</span>))<span style="color:#f92672">?</span>;</span></span></code></pre></div>
<p>For the image, we know the width and the height which are fairly self-explanatory (those came from the image loading function). We require optimal tiling on the image, and we need it to be usable as a transfer destination, and sampled from shaders, so we specify those as ImageUsageFlags.</p>
<p>For the ImageLayout Vulkan only allows us to specify either UNDEFINED or PREINITIALIZED. In this case we don&rsquo;t care which layout it comes as, and we&rsquo;ll be transitioning it for the copy soon.</p>
<p>We want the image to be DEVICE_LOCAL to be as fast as possible here though.</p>
<h2 id="6-copying-the-buffer-to-the-image">6. Copying the buffer to the image<a hidden class="anchor" aria-hidden="true" href="#6-copying-the-buffer-to-the-image">#</a></h2>
<p>Now the image is allocated by Vulkan, we need to get the data from the staging buffer into there, which we can of course do with the <strong>copy_image_buffer</strong> helper function that was made. However, in order to copy the buffer to the image it needs to be put into the correct layout for being the destination of a transfer.</p>
<p>We can do that by calling the helper function <strong>transition_image_layout</strong> which in this case will be a transition from UNDEFINED (what we created it as), to TRANSFER_DST_OPTIMAL</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>transition_image_layout(
</span></span><span style="display:flex;"><span>    device,
</span></span><span style="display:flex;"><span>    transfer_queue,
</span></span><span style="display:flex;"><span>    transfer_command_pool,
</span></span><span style="display:flex;"><span>    image,
</span></span><span style="display:flex;"><span>    ImageLayout::<span style="color:#66d9ef">UNDEFINED</span>,
</span></span><span style="display:flex;"><span>    ImageLayout::<span style="color:#66d9ef">TRANSFER_DST_OPTIMAL</span>,
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>.with_context(<span style="color:#f92672">||</span> format!(<span style="color:#e6db74">&#34;Attempting to create texture for image at path </span><span style="color:#e6db74">{path}</span><span style="color:#e6db74">&#34;</span>))<span style="color:#f92672">?</span>;</span></span></code></pre></div>
<p>THEN we can call the copy_image_buffer function</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>copy_image_buffer(
</span></span><span style="display:flex;"><span>    device,
</span></span><span style="display:flex;"><span>    transfer_queue,
</span></span><span style="display:flex;"><span>    transfer_command_pool,
</span></span><span style="display:flex;"><span>    staging_buffer,
</span></span><span style="display:flex;"><span>    image,
</span></span><span style="display:flex;"><span>    width,
</span></span><span style="display:flex;"><span>    height,
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>.with_context(<span style="color:#f92672">||</span> format!(<span style="color:#e6db74">&#34;Attempting to create texture for image at path </span><span style="color:#e6db74">{path}</span><span style="color:#e6db74">&#34;</span>))<span style="color:#f92672">?</span>;</span></span></code></pre></div>
<p>After we have copied the data from the staging buffer to the image however, we need to transition the image into the final layout which will be used for sampling, so we do that now after the copy</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>transition_image_layout(
</span></span><span style="display:flex;"><span>    device,
</span></span><span style="display:flex;"><span>    transfer_queue,
</span></span><span style="display:flex;"><span>    transfer_command_pool,
</span></span><span style="display:flex;"><span>    image,
</span></span><span style="display:flex;"><span>    ImageLayout::<span style="color:#66d9ef">TRANSFER_DST_OPTIMAL</span>,
</span></span><span style="display:flex;"><span>    ImageLayout::<span style="color:#66d9ef">SHADER_READ_ONLY_OPTIMAL</span>,
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>.with_context(<span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>    format!(<span style="color:#e6db74">&#34;Attempting to transition texture to shader readable for image at path </span><span style="color:#e6db74">{path}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>})<span style="color:#f92672">?</span>;</span></span></code></pre></div>
<p>In this case, we need to put it into the SHADER_READ_ONLY_OPTIMAL layout for sampling</p>
<h2 id="7-cleanup-and-return">7. Cleanup and return<a hidden class="anchor" aria-hidden="true" href="#7-cleanup-and-return">#</a></h2>
<p>Finally we&rsquo;ve finished preparing the image and can return it. However, we need to remember to do one thing. We need to clean up the staging buffer!</p>
<p>The staging buffer we allocated has done its job and now the image data is safely within the image memory in the correct layout. Simply clean up the staging buffer and memory</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>    device.destroy_buffer(staging_buffer, None);
</span></span><span style="display:flex;"><span>    device.free_memory(staging_buffer_memory, None);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>And finally, we can now return the Texture to the caller, bundling up the image and memory (along with the currently unused width and height).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>Ok(Texture {
</span></span><span style="display:flex;"><span>    image,
</span></span><span style="display:flex;"><span>    image_memory,
</span></span><span style="display:flex;"><span>    _width: <span style="color:#a6e22e">width</span>,
</span></span><span style="display:flex;"><span>    _height: <span style="color:#a6e22e">height</span>,
</span></span><span style="display:flex;"><span>})</span></span></code></pre></div>
<h1 id="creating-the-texture">Creating the texture<a hidden class="anchor" aria-hidden="true" href="#creating-the-texture">#</a></h1>
<p>Now the create_texture function is present, we can finally use it!</p>
<p>Using it in the main function here to allocate our texture for hooking up at a later point</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> textures <span style="color:#f92672">=</span> vec![create_texture(
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&amp;</span>instance,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&amp;</span>logical_device,
</span></span><span style="display:flex;"><span>    physical_device,
</span></span><span style="display:flex;"><span>    queues.graphics_queue,
</span></span><span style="display:flex;"><span>    graphics_command_pool,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;assets/textures/image1.jpg&#34;</span>,
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>.context(<span style="color:#e6db74">&#34;Creating texture for image1.jpg&#34;</span>)<span style="color:#f92672">?</span>];</span></span></code></pre></div>
<p>Here it&rsquo;s a Vec<!-- raw HTML omitted --> even though we only have one Texture in it, however this means it&rsquo;s easier to add more later and not change the cleanup code.</p>
<p>Speaking of which, we need to remember to pass the Vec<!-- raw HTML omitted --> into the cleanup function and then run the following</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> texture <span style="color:#66d9ef">in</span> textures {
</span></span><span style="display:flex;"><span>    device.destroy_image(texture.image, None);
</span></span><span style="display:flex;"><span>    device.free_memory(texture.image_memory, None);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Now it&rsquo;s finished and we have a shiny new image in GPU memory ready to be bound to the fragment shader for sampling!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="http://localhost:1313/">Robin Smith</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body>

</html>
