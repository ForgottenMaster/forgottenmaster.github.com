<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>13. Uniform Buffer Objects | Robin Smith</title>
<meta name="keywords" content="">
<meta name="description" content="Currently although we are defining the 4 vertices of a square what we actually have is a rectangle due to the scaling of the window. This is more obvious on windows that are much wider, or taller than the other dimension. As an example let&rsquo;s take a look at our current implementation in a window with a width of 1200 and a height of only 600
Solution In order to solve this issue we will need to transform the vertices in our vertex shader by a model-view-projection trio of matrices.">
<meta name="author" content="">
<link rel="canonical" href="https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/uniform-buffer-objects/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://forgottenmaster.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://forgottenmaster.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://forgottenmaster.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://forgottenmaster.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://forgottenmaster.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/uniform-buffer-objects/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="13. Uniform Buffer Objects" />
<meta property="og:description" content="Currently although we are defining the 4 vertices of a square what we actually have is a rectangle due to the scaling of the window. This is more obvious on windows that are much wider, or taller than the other dimension. As an example let&rsquo;s take a look at our current implementation in a window with a width of 1200 and a height of only 600
Solution In order to solve this issue we will need to transform the vertices in our vertex shader by a model-view-projection trio of matrices." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/uniform-buffer-objects/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-09T19:16:52+00:00" />
<meta property="article:modified_time" content="2023-03-09T19:16:52+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="13. Uniform Buffer Objects"/>
<meta name="twitter:description" content="Currently although we are defining the 4 vertices of a square what we actually have is a rectangle due to the scaling of the window. This is more obvious on windows that are much wider, or taller than the other dimension. As an example let&rsquo;s take a look at our current implementation in a window with a width of 1200 and a height of only 600
Solution In order to solve this issue we will need to transform the vertices in our vertex shader by a model-view-projection trio of matrices."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://forgottenmaster.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Vulkan",
      "item": "https://forgottenmaster.github.io/posts/vulkan/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Let's Learn Vulkan",
      "item": "https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "13. Uniform Buffer Objects",
      "item": "https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/uniform-buffer-objects/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "13. Uniform Buffer Objects",
  "name": "13. Uniform Buffer Objects",
  "description": "Currently although we are defining the 4 vertices of a square what we actually have is a rectangle due to the scaling of the window. This is more obvious on windows that are much wider, or taller than the other dimension. As an example let\u0026rsquo;s take a look at our current implementation in a window with a width of 1200 and a height of only 600\nSolution In order to solve this issue we will need to transform the vertices in our vertex shader by a model-view-projection trio of matrices.",
  "keywords": [
    
  ],
  "articleBody": "Currently although we are defining the 4 vertices of a square what we actually have is a rectangle due to the scaling of the window. This is more obvious on windows that are much wider, or taller than the other dimension. As an example let’s take a look at our current implementation in a window with a width of 1200 and a height of only 600\nSolution In order to solve this issue we will need to transform the vertices in our vertex shader by a model-view-projection trio of matrices. Definitions for these are as follows:\nmodel: This matrix transforms the model itself such as scaling it, moving, or rotating it in world space. view: This defines the positioning and orientation of the camera that is viewing the scene. projection: This matrix defines how the world space coordinates are projected into screen space. The big question is how do we get these matrices from our application into the shader to be used? The answer here is Uniform Buffer Objects.\nAdding Definitions In order to use UBO’s in Vulkan, we must first define the structure of the object on the application side, as well as the shader side. However first we will need to install a new dependency.\nInstalling Glam We don’t want to reinvent the wheel when it comes to matrix maths, and there are several crates which contain types compatible with the shader equivalents so that the buffer of data on the application side matches up with what the shader expects.\nWe’ll install a crate called glam which is as simple as adding this to our Cargo.toml\nglam = \"0.23.0\" Defining the UBO Application Side We can define our UBO structure on the application side fairly easily now that we’ve installed glam since it contains types matching up with the shader types. Putting these into a struct with “C” representation will result in the same layout.\nIn this case, the three entries are 4-D matrices which in GLSL is mat4. Similarly in glam, it’s Mat4 so the structure looks as follows\n#[repr(C)] struct ModelViewProjection { projection: Mat4, view: Mat4, model: Mat4, } Defining the UBO Shader Side We can then go ahead and define the UBO with the same structure in our Vertex shader.\nlayout(binding = 0) uniform MVP { mat4 projection; mat4 view; mat4 model; } mvp; Notice here that we must specify a layout and must tell it that this UBO is at binding 0. We can also have different descriptor sets which we’ll encounter soon, and here there’s an implicit “set = 0” in the layout, but we can leave it off here.\nNotice also the keyword uniform which means this data will be constant over the whole draw call and not vary per-vertex like attributes do.\nUsing the UBO Now we can alter the vertex shader to actually use the UBO data. This is simple, we will take the calculated vertex position (in model/local space) and apply in order the model, view, and projection matrices as so\ngl_Position = mvp.projection * mvp.view * mvp.model * vec4(position, 1.0); Descriptors Overview Next we need to consider how we get data hooked up to the graphics pipeline so that it can be passed over to the Vertex shader. Vulkan uses something known as descriptor sets for this type of data, of which uniform buffers are only one kind.\nThere are a few different types that interplay here but as a visual overview we can look to this diagram\nDescriptor Sets\rReddit\nOver the next few sections i’ll go over these types and setting them up to get our data into a uniform buffer and connected up to the pipeline.\nDescriptor Set Layout The first step is to tell the pipeline the layout of our descriptor sets. This can be thought of as defining the shape of the descriptor sets, as it’s used to create the pipeline layout, and the actual descriptor sets matching this shape are bound before using the pipeline to draw.\nFirst step then is to create this descriptor set layout. Like the PipelineLayout, Vulkan expects us to create this separately (and destroy separately) before we go ahead and use it to construct one or more pipeline layouts. We’ll do this in a create_descriptor_set_layout function.\nfn create_descriptor_set_layout(device: \u0026Device) -\u003e Result\u003cDescriptorSetLayout\u003e { unsafe { device .create_descriptor_set_layout( \u0026DescriptorSetLayoutCreateInfo::builder().bindings(\u0026[ *DescriptorSetLayoutBinding::builder() .descriptor_type(DescriptorType::UNIFORM_BUFFER) .descriptor_count(1) .stage_flags(ShaderStageFlags::VERTEX), ]), None, ) .context(\"Failed to create a descriptor set layout.\") } } We can pass multiple bindings as mentioned into the builder when constructing a layout for a single descriptor set. The index of the binding in the list corresponds with the “binding” number in our vertex shader. In this case we only have a single binding at index 0 and that is indeed what the vertex shader looks at when mapping the UBO.\nWe are only creating a single descriptor within this set, and the type of this descriptor is a UNIFORM_BUFFER. We must specify which stage of the pipeline we’ll be binding the descriptors to, and in this case the vertex shader uses the data, so it gets bound to ShaderStageFlags::VERTEX.\nOnce we’ve constructed this, we need to go ahead and pass it in to our pipeline layout also\nfn create_pipeline_layout( device: \u0026Device, set_layouts: \u0026[DescriptorSetLayout], ) -\u003e Result\u003cPipelineLayout\u003e { unsafe { device.create_pipeline_layout( \u0026PipelineLayoutCreateInfo::builder() .set_layouts(set_layouts) .push_constant_ranges(\u0026[]), None, ) } .context(\"Error trying to create a pipeline layout.\") } Notice that we can pass multiple sets also, which corresponds to the “set” number in the layout within our vertex shader. set=0 is the default and is what we’re using, which corresponds to the descriptor set at index 0.\nUniform Buffers Next we can go ahead and allocate the buffers and backing memory for our uniform data. We need to create one buffer per swapchain image because we don’t want the application to be updating the uniform data within the buffer while it’s still being rendered.\nTherefore we make our create_uniform_buffers function, and pass the number to create in.\nfn create_uniform_buffers( instance: \u0026Instance, device: \u0026Device, physical_device: PhysicalDevice, count: usize, ) -\u003e Result\u003cVec\u003c(Buffer, DeviceMemory)\u003e\u003e { let mut buffers = Vec::with_capacity(count); for _ in 0..count { buffers.push( create_buffer( instance, device, physical_device, BufferUsageFlags::UNIFORM_BUFFER, MemoryPropertyFlags::HOST_VISIBLE | MemoryPropertyFlags::HOST_COHERENT, mem::size_of::\u003cModelViewProjection\u003e().try_into().unwrap(), ) .context(\"Failed to create a uniform buffer.\")?, ); } Ok(buffers) } We return a Vec\u003c(Buffer, DeviceMemory)\u003e because we are creating multiple in a loop.\nWe force the device memory to be HOST_VISIBLE and HOST_COHERENT because we will be updating this memory every frame potentially as the model/view matrices change due to the model moving in the world, or the camera. There’s no point using staging buffer because the overhead of constantly copying to device local memory every frame would not be worth it.\nThe buffer usage is set to UNIFORM_BUFFER, and the size of the buffer wants to be large enough to store a single ModelViewProjection struct in it.\nThe create_buffer function we wrote earlier will take care of allocating the buffer and memory, and binding the two together!\nAllocating Descriptor Sets Now that we have told the pipeline what the structure of the descriptor set is that it should expect, and we’ve allocated our buffers for them we can start working on the actual descriptor set instances.\nHowever, Vulkan doesn’t allow us to just create descriptor sets unfortunately. They must be allocated from a pool much like command buffers are.\nfn create_descriptor_pool(device: \u0026Device, count: u32) -\u003e Result\u003cDescriptorPool\u003e { unsafe { device .create_descriptor_pool( \u0026DescriptorPoolCreateInfo::builder() .max_sets(count) .pool_sizes(\u0026[*DescriptorPoolSize::builder() .ty(DescriptorType::UNIFORM_BUFFER) .descriptor_count(count)]), None, ) .context(\"Failed to create a descriptor pool.\") } } In order to create a descriptor pool though, unlike when creating a command buffer pool, we must tell Vulkan the maximum number of different descriptor sets that can be allocated from this pool at any given time. Additionally we need to tell Vulkan the maximum number of individual descriptor types.\nIn our case, the maximum number of descriptor set instances is the number of swapchain images (passed in via count). Additionally, since we only have a single uniform buffer descriptor per set, then we tell Vulkan to create a number of uniform buffer descriptors in the pool equal to count also.\nNext we need to actually allocate the descriptor set instances we need from the pool. In our case we will just be draining the pool since we told it to create just enough for our needs.\nfn allocate_descriptor_sets( device: \u0026Device, descriptor_pool: DescriptorPool, descriptor_set_layout: DescriptorSetLayout, count: usize, ) -\u003e Result\u003cVec\u003cDescriptorSet\u003e\u003e { let layouts = std::iter::repeat(descriptor_set_layout) .take(count) .collect::\u003cVec\u003c_\u003e\u003e(); unsafe { device .allocate_descriptor_sets( \u0026DescriptorSetAllocateInfo::builder() .descriptor_pool(descriptor_pool) .set_layouts(\u0026layouts), ) .context(\"Failed to allocate descriptor sets.\") } } We pass the DescriptorSetLayout here through to the allocate_descriptor_sets function, along with the pool, and the count of how many.\nThe way the allocate_descriptor_sets function is setup from Vulkan isthat it takes the pool, along with a slice of layouts, and will return an instance per layout in the slice in the same order (hence this function returns a Vec).\nWe only have one DescriptorSetLayout and want count copies, so we can use the handy iterator functions to create a vector with count copies of the layout with\nlet layouts = std::iter::repeat(descriptor_set_layout) .take(count) .collect::\u003cVec\u003c_\u003e\u003e(); With that, we have allocated the descriptor set instances and are one step closer to using them!\nBinding There are two kinds of bindings we need to do at this point to make the buffers usable in our shaders\nBinding the buffers to the descriptor sets Binding the descriptor sets to the draw call Binding the buffers to the descriptor sets is slightly more involved but it’s not too bad - it’s just that Vulkan has a few different types we need to construct to do the updating.\nFor this, we’ll go ahead and make a function update_descriptor_sets with the following signature\nfn update_descriptor_sets( device: \u0026Device, buffers: \u0026[(Buffer, DeviceMemory)], sets: \u0026[DescriptorSet], ) It requires the device to be able to call the update function with, but along with this requires the buffers, and descriptor sets. The function expects these two slices to be the same length and order such that buffers[i] should be boun to sets[i].\nThe first thing we need to do here is to create the list of DescriptorBufferInfo. This is a separate type because our descriptors, as mentioned could be of various types and in this case they are buffers, so we need the buffer infos.\nThe buffer info has the following information in it\nThe buffer that this descriptor will be bound to The offset within the buffer that the descriptor should be associated with The range within the buffer of the data to be bound to this descriptor In our case, the offset is 0 (default), and the range is the size of one ModelViewProjection instance.\nWe will go ahead and create on DescriptorBufferInfo struct for each uniform buffer\nlet buffer_infos = buffers .iter() .map(|(buffer, _)| { vec![*DescriptorBufferInfo::builder() .buffer(*buffer) .range(mem::size_of::\u003cModelViewProjection\u003e().try_into().unwrap())] }) .collect::\u003cVec\u003c_\u003e\u003e(); Notice that we are returning a Vec for each buffer, this is because the next step will take a vec of those and each one would be associated with a binding though again we’re using only a single buffer per set, so this is just going to be at binding 0 (index 0).\nNow we need to go over the buffer infos, and the DescriptorSet instances associated with them, which we can do by zipping them together\nbuffer_infos .iter() .zip(sets) And for each pair, we’ll map them to a WriteDescriptorSet instance containing the information to write/bind to the descriptor set instance\n.map(|(buffer_info, set)| { *WriteDescriptorSet::builder() .dst_set(*set) .descriptor_type(DescriptorType::UNIFORM_BUFFER) .buffer_info(buffer_info) }) We set the descriptor set, along with the descriptor type (UNIFORM_BUFFER), and the list of buffer infos defining all the uniform buffers in the set. We only have one, but it’s still a list, we can pass it straight in.\nFinally we can go ahead and collect all these WriteDescriptorSet instances into a Vec\n.collect::\u003cVec\u003c_\u003e\u003e(); The last step is to tell Vulkan to actually go ahead and update these descriptor set instances with the appropriate information\nunsafe { device.update_descriptor_sets(\u0026writes, \u0026[]); } There are actually two kinds of updates we can do with descriptor sets. We’re only doing writes but we could also do copies where we copy bindings from one set to another.\nThat’s enough for binding our buffers to our descriptor sets!. Next we just have to bind our descriptor sets to our draw calls. We’ll hop on over to where we record our command buffers per frame and add this just before the draw call\ndevice.cmd_bind_descriptor_sets( *command_buffer, PipelineBindPoint::GRAPHICS, pipeline_layout, 0, \u0026[*descriptor_set], \u0026[], ); Here we’re saying we want to bind these descriptor sets to the graphics pipeline bind point, with the given pipeline layout, and we’re providing the descriptor sets to match the pipeline layout. In this case only a single descriptor set which will be the one associated with the current command buffer.\nAnd….that’s all the setup we need! our vertex shader is now reading the UBO, however we need to populate it with something sensible.\nWriting Into the UBOs We’ll handle this by keeping an instance of the ModelViewProjection structure around that we can update during our application as needed. Just before we ask to draw to the appropriate image, we’ll copy the data from this single instance into the matching UBO for that frame/image.\nFirstly we’ll initialise the struct as follows\nlet mut mvp = ModelViewProjection { model: Mat4::IDENTITY, view: Mat4::look_at_rh( Vec3::new(0.0, 0.0, 2.0), Vec3::new(0.0, 0.0, 0.0), Vec3::new(0.0, 1.0, 0.0), ), projection: Mat4::perspective_rh(45.0_f32.to_radians(), aspect, 0.1, 100.0), }; The explanations are as follows\nmodel: We start off with the model being untranslated, unrotated, and unscaled - the identity matrix view: We can use the look_at_rh function (OpenGL is a RH coordinate system) to create a camera matrix at coordinate (0, 0, 2) and looking towards the origin, with up being the standard (0, 1, 0) projection: Here we’re using a perspective projection with a 45 degree field of view. We calculate the aspect ratio of the images, and we set the near clipping plane to 0.1, the far clipping plane to 100 To update the UBO before the draw is executed, we’ll hop over to the draw function. We’ll need to do what we did with our other buffers and map the memory for the uniform buffer, write to it, and then unmap. Since we’ve seen this before, I’ll just show the code in its entirety\n// update the uniform buffer with the MVP. let uniform_memory = uniform_buffers[image_index as usize].1; let dst = device .map_memory( uniform_memory, 0, mem::size_of::\u003cModelViewProjection\u003e().try_into().unwrap(), MemoryMapFlags::empty(), ) .context(\"Failed to map uniform buffer memory.\")? as *mut ModelViewProjection; let src = mvp as *const ModelViewProjection; ptr::copy_nonoverlapping(src, dst, 1); device.unmap_memory(uniform_memory); With this, we can now see that our square is actually a square! (finally)\nAnimation Finally we can have an animated image, all we need to do is to simply rotate the model matrix a little each frame.\nWe will do this in the standard way of calculating the delta time between the last frame, and the current frame. We can then use this delta time along with a speed to rotate the square in a framerate-independant way.\nIn Rust we can get a timestamp like\nlet mut last_frame_timestamp = Instant::now(); So we start off with a timestamp initialised to the time that we start our application’s event loop.\nIn order to calculate the elapsed time since the last frame and now, we can take another timestamp and calculate the elapsed time between the two as\nlet timestamp = Instant::now(); let elapsed = timestamp.duration_since(last_frame_timestamp).as_secs_f32(); The function duration_since will take an earlier timestamp and calculate a Duration between the two. We can choose how to extract information from this Duration but here we’ll just get the total number of seconds as an f32, which handles partial seconds.\nOnce we have the elapsed time, we can rotate the model matrix by some amount - in this case we’ll use a speed of 100 degrees per second\nmvp.model *= Mat4::from_rotation_z(100.0_f32.to_radians() * elapsed); Although notice that Mat4::from_rotation_z expects the angle in radians so we convert from degrees to radians by using the built-in Rust function on f32’s, to_radians.\nAfter rotating the model matrix, we update the timestamp of the previous frame, and request that the window be redrawn\nlast_frame_timestamp = timestamp; window.request_redraw(); Running our program now, we can see a very nice rotating square!\nThere should have been a video here but your browser does not seem\rto support it.\r",
  "wordCount" : "2716",
  "inLanguage": "en",
  "datePublished": "2023-03-09T19:16:52Z",
  "dateModified": "2023-03-09T19:16:52Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/uniform-buffer-objects/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Robin Smith",
    "logo": {
      "@type": "ImageObject",
      "url": "https://forgottenmaster.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://forgottenmaster.github.io/" accesskey="h" title="Robin Smith (Alt + H)">Robin Smith</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://forgottenmaster.github.io/resume/" title="Résumé">
                    <span>Résumé</span>
                </a>
            </li>
            <li>
                <a href="https://forgottenmaster.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://forgottenmaster.github.io/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://forgottenmaster.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/vulkan/">Vulkan</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/">Let&#39;s Learn Vulkan</a></div>
    <h1 class="post-title entry-hint-parent">
      13. Uniform Buffer Objects
    </h1>
    <div class="post-meta"><span title='2023-03-09 19:16:52 +0000 UTC'>March 9, 2023</span>&nbsp;·&nbsp;13 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#solution" aria-label="Solution">Solution</a></li>
                <li>
                    <a href="#adding-definitions" aria-label="Adding Definitions">Adding Definitions</a><ul>
                        
                <li>
                    <a href="#installing-glam" aria-label="Installing Glam">Installing Glam</a></li>
                <li>
                    <a href="#defining-the-ubo-application-side" aria-label="Defining the UBO Application Side">Defining the UBO Application Side</a></li>
                <li>
                    <a href="#defining-the-ubo-shader-side" aria-label="Defining the UBO Shader Side">Defining the UBO Shader Side</a></li>
                <li>
                    <a href="#using-the-ubo" aria-label="Using the UBO">Using the UBO</a></li></ul>
                </li>
                <li>
                    <a href="#descriptors-overview" aria-label="Descriptors Overview">Descriptors Overview</a></li>
                <li>
                    <a href="#descriptor-set-layout" aria-label="Descriptor Set Layout">Descriptor Set Layout</a></li>
                <li>
                    <a href="#uniform-buffers" aria-label="Uniform Buffers">Uniform Buffers</a></li>
                <li>
                    <a href="#allocating-descriptor-sets" aria-label="Allocating Descriptor Sets">Allocating Descriptor Sets</a></li>
                <li>
                    <a href="#binding" aria-label="Binding">Binding</a></li>
                <li>
                    <a href="#writing-into-the-ubos" aria-label="Writing Into the UBOs">Writing Into the UBOs</a></li>
                <li>
                    <a href="#animation" aria-label="Animation">Animation</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Currently although we are defining the 4 vertices of a <strong>square</strong> what we actually have is a rectangle due to the scaling of the window. This is more obvious on windows that are much wider, or taller than the other dimension. As an example let&rsquo;s take a look at our current implementation in a window with a width of 1200 and a height of only 600</p>
<p><img loading="lazy" src="stretched.PNG" alt="Stretched"  />
</p>
<h1 id="solution">Solution<a hidden class="anchor" aria-hidden="true" href="#solution">#</a></h1>
<p>In order to solve this issue we will need to transform the vertices in our vertex shader by a model-view-projection trio of matrices. Definitions for these are as follows:</p>
<ul>
<li><strong>model</strong>: This matrix transforms the model itself such as scaling it, moving, or rotating it in world space.</li>
<li><strong>view</strong>: This defines the positioning and orientation of the camera that is viewing the scene.</li>
<li><strong>projection</strong>: This matrix defines how the world space coordinates are projected into screen space.</li>
</ul>
<p>The big question is how do we get these matrices from our application into the shader to be used? The answer here is <strong>Uniform Buffer Objects</strong>.</p>
<h1 id="adding-definitions">Adding Definitions<a hidden class="anchor" aria-hidden="true" href="#adding-definitions">#</a></h1>
<p>In order to use UBO&rsquo;s in Vulkan, we must first define the structure of the object on the application side, as well as the shader side. However first we will need to install a new dependency.</p>
<h2 id="installing-glam">Installing Glam<a hidden class="anchor" aria-hidden="true" href="#installing-glam">#</a></h2>
<p>We don&rsquo;t want to reinvent the wheel when it comes to matrix maths, and there are several crates which contain types compatible with the shader equivalents so that the buffer of data on the application side matches up with what the shader expects.</p>
<p>We&rsquo;ll install a crate called glam which is as simple as adding this to our Cargo.toml</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-toml" data-lang="toml"><span style="display:flex;"><span><span style="color:#a6e22e">glam</span> = <span style="color:#e6db74">&#34;0.23.0&#34;</span></span></span></code></pre></div>
<h2 id="defining-the-ubo-application-side">Defining the UBO Application Side<a hidden class="anchor" aria-hidden="true" href="#defining-the-ubo-application-side">#</a></h2>
<p>We can define our UBO structure on the application side fairly easily now that we&rsquo;ve installed glam since it contains types matching up with the shader types. Putting these into a struct with &ldquo;C&rdquo; representation will result in the same layout.</p>
<p>In this case, the three entries are 4-D matrices which in GLSL is <strong>mat4</strong>. Similarly in glam, it&rsquo;s <strong>Mat4</strong> so the structure looks as follows</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ModelViewProjection</span> {
</span></span><span style="display:flex;"><span>    projection: <span style="color:#a6e22e">Mat4</span>,
</span></span><span style="display:flex;"><span>    view: <span style="color:#a6e22e">Mat4</span>,
</span></span><span style="display:flex;"><span>    model: <span style="color:#a6e22e">Mat4</span>,
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h2 id="defining-the-ubo-shader-side">Defining the UBO Shader Side<a hidden class="anchor" aria-hidden="true" href="#defining-the-ubo-shader-side">#</a></h2>
<p>We can then go ahead and define the UBO with the <strong>same structure</strong> in our Vertex shader.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-glsl" data-lang="glsl"><span style="display:flex;"><span>layout(binding <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">uniform</span> MVP {
</span></span><span style="display:flex;"><span>    mat4 projection;
</span></span><span style="display:flex;"><span>    mat4 view;
</span></span><span style="display:flex;"><span>    mat4 model;
</span></span><span style="display:flex;"><span>} mvp;</span></span></code></pre></div>
<p>Notice here that we must specify a layout and must tell it that this UBO is at binding 0. We can also have different <strong>descriptor sets</strong> which we&rsquo;ll encounter soon, and here there&rsquo;s an implicit &ldquo;set = 0&rdquo; in the layout, but we can leave it off here.</p>
<p>Notice also the keyword <strong>uniform</strong> which means this data will be constant over the whole draw call and not vary per-vertex like attributes do.</p>
<h2 id="using-the-ubo">Using the UBO<a hidden class="anchor" aria-hidden="true" href="#using-the-ubo">#</a></h2>
<p>Now we can alter the vertex shader to actually use the UBO data. This is simple, we will take the calculated vertex position (in model/local space) and apply in order the <strong>model</strong>, <strong>view</strong>, and <strong>projection</strong> matrices as so</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-glsl" data-lang="glsl"><span style="display:flex;"><span>gl_Position <span style="color:#f92672">=</span> mvp.projection <span style="color:#f92672">*</span> mvp.view <span style="color:#f92672">*</span> mvp.model <span style="color:#f92672">*</span> <span style="color:#66d9ef">vec4</span>(position, <span style="color:#ae81ff">1.0</span>);</span></span></code></pre></div>
<h1 id="descriptors-overview">Descriptors Overview<a hidden class="anchor" aria-hidden="true" href="#descriptors-overview">#</a></h1>
<p>Next we need to consider <em>how</em> we get data hooked up to the graphics pipeline so that it can be passed over to the Vertex shader. Vulkan uses something known as <strong>descriptor sets</strong> for this type of data, of which uniform buffers are only one kind.</p>
<p>There are a few different types that interplay here but as a visual overview we can look to this diagram</p>
<figure class="align-center ">
    <img loading="lazy" src="https://i.redd.it/4bigribcd1o21.png#center"/> <figcaption>
            Descriptor Sets<p>
                    <a href="https://www.reddit.com/r/vulkan/comments/b4uj52/visual_explanation_of_descriptor_sets_i_made_a/">Reddit</a></p>
        </figcaption>
</figure>

<p>Over the next few sections i&rsquo;ll go over these types and setting them up to get our data into a uniform buffer and connected up to the pipeline.</p>
<h1 id="descriptor-set-layout">Descriptor Set Layout<a hidden class="anchor" aria-hidden="true" href="#descriptor-set-layout">#</a></h1>
<p>The first step is to tell the pipeline the <em>layout</em> of our descriptor sets. This can be thought of as defining the shape of the descriptor sets, as it&rsquo;s used to create the pipeline layout, and the actual descriptor sets matching this shape are bound before using the pipeline to draw.</p>
<p>First step then is to create this descriptor set layout. Like the PipelineLayout, Vulkan expects us to create this separately (and destroy separately) before we go ahead and use it to construct one or more pipeline layouts. We&rsquo;ll do this in a create_descriptor_set_layout function.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">create_descriptor_set_layout</span>(device: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Device</span>) -&gt; Result<span style="color:#f92672">&lt;</span>DescriptorSetLayout<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>        device
</span></span><span style="display:flex;"><span>            .create_descriptor_set_layout(
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">&amp;</span>DescriptorSetLayoutCreateInfo::builder().bindings(<span style="color:#f92672">&amp;</span>[
</span></span><span style="display:flex;"><span>                    <span style="color:#f92672">*</span>DescriptorSetLayoutBinding::builder()
</span></span><span style="display:flex;"><span>                        .descriptor_type(DescriptorType::<span style="color:#66d9ef">UNIFORM_BUFFER</span>)
</span></span><span style="display:flex;"><span>                        .descriptor_count(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>                        .stage_flags(ShaderStageFlags::<span style="color:#66d9ef">VERTEX</span>),
</span></span><span style="display:flex;"><span>                ]),
</span></span><span style="display:flex;"><span>                None,
</span></span><span style="display:flex;"><span>            )
</span></span><span style="display:flex;"><span>            .context(<span style="color:#e6db74">&#34;Failed to create a descriptor set layout.&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>We can pass multiple <strong>bindings</strong> as mentioned into the builder when constructing a layout for a single descriptor set. The index of the binding in the list corresponds with the &ldquo;binding&rdquo; number in our vertex shader. In this case we only have a single binding at index 0 and that is indeed what the vertex shader looks at when mapping the UBO.</p>
<p>We are only creating a single descriptor within this set, and the type of this descriptor is a <strong>UNIFORM_BUFFER</strong>. We must specify which stage of the pipeline we&rsquo;ll be binding the descriptors to, and in this case the vertex shader uses the data, so it gets bound to ShaderStageFlags::<strong>VERTEX</strong>.</p>
<p>Once we&rsquo;ve constructed this, we need to go ahead and pass it in to our pipeline layout also</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">create_pipeline_layout</span>(
</span></span><span style="display:flex;"><span>    device: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Device</span>,
</span></span><span style="display:flex;"><span>    set_layouts: <span style="color:#66d9ef">&amp;</span>[DescriptorSetLayout],
</span></span><span style="display:flex;"><span>) -&gt; Result<span style="color:#f92672">&lt;</span>PipelineLayout<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>        device.create_pipeline_layout(
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&amp;</span>PipelineLayoutCreateInfo::builder()
</span></span><span style="display:flex;"><span>                .set_layouts(set_layouts)
</span></span><span style="display:flex;"><span>                .push_constant_ranges(<span style="color:#f92672">&amp;</span>[]),
</span></span><span style="display:flex;"><span>            None,
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    .context(<span style="color:#e6db74">&#34;Error trying to create a pipeline layout.&#34;</span>)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Notice that we can pass multiple sets also, which corresponds to the &ldquo;set&rdquo; number in the layout within our vertex shader. set=0 is the default and is what we&rsquo;re using, which corresponds to the descriptor set at index 0.</p>
<h1 id="uniform-buffers">Uniform Buffers<a hidden class="anchor" aria-hidden="true" href="#uniform-buffers">#</a></h1>
<p>Next we can go ahead and allocate the buffers and backing memory for our uniform data. We need to create one buffer <strong>per swapchain image</strong> because we don&rsquo;t want the application to be updating the uniform data within the buffer while it&rsquo;s still being rendered.</p>
<p>Therefore we make our create_uniform_buffer<strong>s</strong> function, and pass the number to create in.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">create_uniform_buffers</span>(
</span></span><span style="display:flex;"><span>    instance: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Instance</span>,
</span></span><span style="display:flex;"><span>    device: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Device</span>,
</span></span><span style="display:flex;"><span>    physical_device: <span style="color:#a6e22e">PhysicalDevice</span>,
</span></span><span style="display:flex;"><span>    count: <span style="color:#66d9ef">usize</span>,
</span></span><span style="display:flex;"><span>) -&gt; Result<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>(Buffer, DeviceMemory)<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> buffers <span style="color:#f92672">=</span> Vec::with_capacity(count);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> _ <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>count {
</span></span><span style="display:flex;"><span>        buffers.push(
</span></span><span style="display:flex;"><span>            create_buffer(
</span></span><span style="display:flex;"><span>                instance,
</span></span><span style="display:flex;"><span>                device,
</span></span><span style="display:flex;"><span>                physical_device,
</span></span><span style="display:flex;"><span>                BufferUsageFlags::<span style="color:#66d9ef">UNIFORM_BUFFER</span>,
</span></span><span style="display:flex;"><span>                MemoryPropertyFlags::<span style="color:#66d9ef">HOST_VISIBLE</span> <span style="color:#f92672">|</span> MemoryPropertyFlags::<span style="color:#66d9ef">HOST_COHERENT</span>,
</span></span><span style="display:flex;"><span>                mem::size_of::<span style="color:#f92672">&lt;</span>ModelViewProjection<span style="color:#f92672">&gt;</span>().try_into().unwrap(),
</span></span><span style="display:flex;"><span>            )
</span></span><span style="display:flex;"><span>            .context(<span style="color:#e6db74">&#34;Failed to create a uniform buffer.&#34;</span>)<span style="color:#f92672">?</span>,
</span></span><span style="display:flex;"><span>        );
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Ok(buffers)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>We return a Vec&lt;(Buffer, DeviceMemory)&gt; because we are creating multiple in a loop.</p>
<p>We force the device memory to be <strong>HOST_VISIBLE</strong> and <strong>HOST_COHERENT</strong> because we will be updating this memory every frame potentially as the model/view matrices change due to the model moving in the world, or the camera. There&rsquo;s no point using staging buffer because the overhead of constantly copying to device local memory every frame would not be worth it.</p>
<p>The buffer usage is set to <strong>UNIFORM_BUFFER</strong>, and the size of the buffer wants to be large enough to store a single ModelViewProjection struct in it.</p>
<p>The create_buffer function we wrote earlier will take care of allocating the buffer and memory, and binding the two together!</p>
<h1 id="allocating-descriptor-sets">Allocating Descriptor Sets<a hidden class="anchor" aria-hidden="true" href="#allocating-descriptor-sets">#</a></h1>
<p>Now that we have told the pipeline what the structure of the descriptor set is that it should expect, and we&rsquo;ve allocated our buffers for them we can start working on the actual descriptor set instances.</p>
<p>However, Vulkan doesn&rsquo;t allow us to just create descriptor sets unfortunately. They must be allocated from a <strong>pool</strong> much like command buffers are.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">create_descriptor_pool</span>(device: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Device</span>, count: <span style="color:#66d9ef">u32</span>) -&gt; Result<span style="color:#f92672">&lt;</span>DescriptorPool<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>        device
</span></span><span style="display:flex;"><span>            .create_descriptor_pool(
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">&amp;</span>DescriptorPoolCreateInfo::builder()
</span></span><span style="display:flex;"><span>                    .max_sets(count)
</span></span><span style="display:flex;"><span>                    .pool_sizes(<span style="color:#f92672">&amp;</span>[<span style="color:#f92672">*</span>DescriptorPoolSize::builder()
</span></span><span style="display:flex;"><span>                        .ty(DescriptorType::<span style="color:#66d9ef">UNIFORM_BUFFER</span>)
</span></span><span style="display:flex;"><span>                        .descriptor_count(count)]),
</span></span><span style="display:flex;"><span>                None,
</span></span><span style="display:flex;"><span>            )
</span></span><span style="display:flex;"><span>            .context(<span style="color:#e6db74">&#34;Failed to create a descriptor pool.&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>In order to create a descriptor pool though, unlike when creating a command buffer pool, we must tell Vulkan the maximum number of different descriptor sets that can be allocated from this pool at any given time. Additionally we need to tell Vulkan the maximum number of individual descriptor types.</p>
<p>In our case, the maximum number of descriptor set instances is the number of swapchain images (passed in via count). Additionally, since we only have a single uniform buffer descriptor per set, then we tell Vulkan to create a number of uniform buffer descriptors in the pool equal to count also.</p>
<p>Next we need to actually <strong>allocate</strong> the descriptor set instances we need from the pool. In our case we will just be draining the pool since we told it to create just enough for our needs.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">allocate_descriptor_sets</span>(
</span></span><span style="display:flex;"><span>    device: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Device</span>,
</span></span><span style="display:flex;"><span>    descriptor_pool: <span style="color:#a6e22e">DescriptorPool</span>,
</span></span><span style="display:flex;"><span>    descriptor_set_layout: <span style="color:#a6e22e">DescriptorSetLayout</span>,
</span></span><span style="display:flex;"><span>    count: <span style="color:#66d9ef">usize</span>,
</span></span><span style="display:flex;"><span>) -&gt; Result<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>DescriptorSet<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> layouts <span style="color:#f92672">=</span> std::iter::repeat(descriptor_set_layout)
</span></span><span style="display:flex;"><span>        .take(count)
</span></span><span style="display:flex;"><span>        .collect::<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;&gt;</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>        device
</span></span><span style="display:flex;"><span>            .allocate_descriptor_sets(
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">&amp;</span>DescriptorSetAllocateInfo::builder()
</span></span><span style="display:flex;"><span>                    .descriptor_pool(descriptor_pool)
</span></span><span style="display:flex;"><span>                    .set_layouts(<span style="color:#f92672">&amp;</span>layouts),
</span></span><span style="display:flex;"><span>            )
</span></span><span style="display:flex;"><span>            .context(<span style="color:#e6db74">&#34;Failed to allocate descriptor sets.&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>We pass the DescriptorSetLayout here through to the allocate_descriptor_sets function, along with the pool, and the count of how many.</p>
<p>The way the allocate_descriptor_sets function is setup from Vulkan isthat it takes the pool, along with a <strong>slice</strong> of layouts, and will return an instance per layout in the slice in the same order (hence this function returns a Vec<!-- raw HTML omitted -->).</p>
<p>We only have one DescriptorSetLayout and want count copies, so we can use the handy iterator functions to create a vector with count copies of the layout with</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> layouts <span style="color:#f92672">=</span> std::iter::repeat(descriptor_set_layout)
</span></span><span style="display:flex;"><span>    .take(count)
</span></span><span style="display:flex;"><span>    .collect::<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;&gt;</span>();</span></span></code></pre></div>
<p>With that, we have allocated the descriptor set instances and are one step closer to using them!</p>
<h1 id="binding">Binding<a hidden class="anchor" aria-hidden="true" href="#binding">#</a></h1>
<p>There are two kinds of bindings we need to do at this point to make the buffers usable in our shaders</p>
<ol>
<li>Binding the <strong>buffers</strong> to the <strong>descriptor sets</strong></li>
<li>Binding the <strong>descriptor sets</strong> to the <strong>draw call</strong></li>
</ol>
<p>Binding the buffers to the descriptor sets is slightly more involved but it&rsquo;s not too bad - it&rsquo;s just that Vulkan has a few different types we need to construct to do the updating.</p>
<p>For this, we&rsquo;ll go ahead and make a function <strong>update_descriptor_sets</strong> with the following signature</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">update_descriptor_sets</span>(
</span></span><span style="display:flex;"><span>    device: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Device</span>,
</span></span><span style="display:flex;"><span>    buffers: <span style="color:#66d9ef">&amp;</span>[(Buffer, DeviceMemory)],
</span></span><span style="display:flex;"><span>    sets: <span style="color:#66d9ef">&amp;</span>[DescriptorSet],
</span></span><span style="display:flex;"><span>)</span></span></code></pre></div>
<p>It requires the device to be able to call the update function with, but along with this requires the buffers, and descriptor sets. The function expects these two slices to be the same length and order such that buffers[i] should be boun to sets[i].</p>
<p>The first thing we need to do here is to create the list of <strong>DescriptorBufferInfo</strong>. This is a separate type because our descriptors, as mentioned could be of various types and in this case they are buffers, so we need the buffer infos.</p>
<p>The buffer info has the following information in it</p>
<ol>
<li>The buffer that this descriptor will be bound to</li>
<li>The offset within the buffer that the descriptor should be associated with</li>
<li>The range within the buffer of the data to be bound to this descriptor</li>
</ol>
<p>In our case, the offset is 0 (default), and the range is the size of one ModelViewProjection instance.</p>
<p>We will go ahead and create on DescriptorBufferInfo struct for <strong>each</strong> uniform buffer</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> buffer_infos <span style="color:#f92672">=</span> buffers
</span></span><span style="display:flex;"><span>    .iter()
</span></span><span style="display:flex;"><span>    .map(<span style="color:#f92672">|</span>(buffer, _)<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>        vec![<span style="color:#f92672">*</span>DescriptorBufferInfo::builder()
</span></span><span style="display:flex;"><span>            .buffer(<span style="color:#f92672">*</span>buffer)
</span></span><span style="display:flex;"><span>            .range(mem::size_of::<span style="color:#f92672">&lt;</span>ModelViewProjection<span style="color:#f92672">&gt;</span>().try_into().unwrap())]
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    .collect::<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;&gt;</span>();</span></span></code></pre></div>
<p>Notice that we are returning a <strong>Vec</strong><!-- raw HTML omitted --> for each buffer, this is because the next step will take a vec of those and each one would be associated with a binding though again we&rsquo;re using only a single buffer per set, so this is just going to be at binding 0 (index 0).</p>
<p>Now we need to go over the buffer infos, and the DescriptorSet instances associated with them, which we can do by zipping them together</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>buffer_infos
</span></span><span style="display:flex;"><span>    .iter()
</span></span><span style="display:flex;"><span>    .zip(sets)</span></span></code></pre></div>
<p>And for each pair, we&rsquo;ll map them to a <strong>WriteDescriptorSet</strong> instance containing the information to write/bind to the descriptor set instance</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>.map(<span style="color:#f92672">|</span>(buffer_info, set)<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>WriteDescriptorSet::builder()
</span></span><span style="display:flex;"><span>        .dst_set(<span style="color:#f92672">*</span>set)
</span></span><span style="display:flex;"><span>        .descriptor_type(DescriptorType::<span style="color:#66d9ef">UNIFORM_BUFFER</span>)
</span></span><span style="display:flex;"><span>        .buffer_info(buffer_info)
</span></span><span style="display:flex;"><span>})</span></span></code></pre></div>
<p>We set the descriptor set, along with the descriptor type (UNIFORM_BUFFER), and the list of buffer infos defining all the uniform buffers in the set. We only have one, but it&rsquo;s still a list, we can pass it straight in.</p>
<p>Finally we can go ahead and collect all these WriteDescriptorSet instances into a Vec</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>.collect::<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;&gt;</span>();</span></span></code></pre></div>
<p>The last step is to tell Vulkan to actually go ahead and update these descriptor set instances with the appropriate information</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>    device.update_descriptor_sets(<span style="color:#f92672">&amp;</span>writes, <span style="color:#f92672">&amp;</span>[]);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>There are actually two kinds of updates we can do with descriptor sets. We&rsquo;re only doing <strong>writes</strong> but we could also do <strong>copies</strong> where we copy bindings from one set to another.</p>
<p>That&rsquo;s enough for binding our buffers to our descriptor sets!. Next we just have to bind our descriptor sets to our draw calls. We&rsquo;ll hop on over to where we record our command buffers per frame and add this just before the draw call</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>device.cmd_bind_descriptor_sets(
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>command_buffer,
</span></span><span style="display:flex;"><span>    PipelineBindPoint::<span style="color:#66d9ef">GRAPHICS</span>,
</span></span><span style="display:flex;"><span>    pipeline_layout,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&amp;</span>[<span style="color:#f92672">*</span>descriptor_set],
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&amp;</span>[],
</span></span><span style="display:flex;"><span>);</span></span></code></pre></div>
<p>Here we&rsquo;re saying we want to bind these descriptor sets to the graphics pipeline bind point, with the given pipeline layout, and we&rsquo;re providing the descriptor sets to match the pipeline layout. In this case only a single descriptor set which will be the one associated with the current command buffer.</p>
<p>And&hellip;.that&rsquo;s all the setup we need! our vertex shader is now reading the UBO, however we need to populate it with something sensible.</p>
<h1 id="writing-into-the-ubos">Writing Into the UBOs<a hidden class="anchor" aria-hidden="true" href="#writing-into-the-ubos">#</a></h1>
<p>We&rsquo;ll handle this by keeping an instance of the ModelViewProjection structure around that we can update during our application as needed. Just before we ask to draw to the appropriate image, we&rsquo;ll copy the data from this single instance into the matching UBO for that frame/image.</p>
<p>Firstly we&rsquo;ll initialise the struct as follows</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> mvp <span style="color:#f92672">=</span> ModelViewProjection {
</span></span><span style="display:flex;"><span>    model: <span style="color:#a6e22e">Mat4</span>::<span style="color:#66d9ef">IDENTITY</span>,
</span></span><span style="display:flex;"><span>    view: <span style="color:#a6e22e">Mat4</span>::look_at_rh(
</span></span><span style="display:flex;"><span>        Vec3::new(<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">2.0</span>),
</span></span><span style="display:flex;"><span>        Vec3::new(<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>),
</span></span><span style="display:flex;"><span>        Vec3::new(<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">0.0</span>),
</span></span><span style="display:flex;"><span>    ),
</span></span><span style="display:flex;"><span>    projection: <span style="color:#a6e22e">Mat4</span>::perspective_rh(<span style="color:#ae81ff">45.0_</span><span style="color:#66d9ef">f32</span>.to_radians(), aspect, <span style="color:#ae81ff">0.1</span>, <span style="color:#ae81ff">100.0</span>),
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p>The explanations are as follows</p>
<ul>
<li><strong>model</strong>: We start off with the model being untranslated, unrotated, and unscaled - the identity matrix</li>
<li><strong>view</strong>: We can use the look_at_rh function (OpenGL is a RH coordinate system) to create a camera matrix at coordinate (0, 0, 2) and looking towards the origin, with up being the standard (0, 1, 0)</li>
<li><strong>projection</strong>: Here we&rsquo;re using a perspective projection with a 45 degree field of view. We calculate the aspect ratio of the images, and we set the near clipping plane to 0.1, the far clipping plane to 100</li>
</ul>
<p>To update the UBO before the draw is executed, we&rsquo;ll hop over to the draw function. We&rsquo;ll need to do what we did with our other buffers and map the memory for the uniform buffer, write to it, and then unmap. Since we&rsquo;ve seen this before, I&rsquo;ll just show the code in its entirety</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// update the uniform buffer with the MVP.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> uniform_memory <span style="color:#f92672">=</span> uniform_buffers[image_index <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>].<span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dst <span style="color:#f92672">=</span> device
</span></span><span style="display:flex;"><span>    .map_memory(
</span></span><span style="display:flex;"><span>        uniform_memory,
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>        mem::size_of::<span style="color:#f92672">&lt;</span>ModelViewProjection<span style="color:#f92672">&gt;</span>().try_into().unwrap(),
</span></span><span style="display:flex;"><span>        MemoryMapFlags::empty(),
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    .context(<span style="color:#e6db74">&#34;Failed to map uniform buffer memory.&#34;</span>)<span style="color:#f92672">?</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">as</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">mut</span> ModelViewProjection;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> src <span style="color:#f92672">=</span> mvp <span style="color:#66d9ef">as</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> ModelViewProjection;
</span></span><span style="display:flex;"><span>ptr::copy_nonoverlapping(src, dst, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>device.unmap_memory(uniform_memory);</span></span></code></pre></div>
<p>With this, we can now see that our square is actually a square! (finally)</p>
<p><img loading="lazy" src="correct.PNG" alt="Correct Square"  />
</p>
<h1 id="animation">Animation<a hidden class="anchor" aria-hidden="true" href="#animation">#</a></h1>
<p>Finally we can have an animated image, all we need to do is to simply rotate the model matrix a little each frame.</p>
<p>We will do this in the standard way of calculating the delta time between the last frame, and the current frame. We can then use this delta time along with a speed to rotate the square in a framerate-independant way.</p>
<p>In Rust we can get a timestamp like</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> last_frame_timestamp <span style="color:#f92672">=</span> Instant::now();</span></span></code></pre></div>
<p>So we start off with a timestamp initialised to the time that we start our application&rsquo;s event loop.</p>
<p>In order to calculate the elapsed time since the last frame and now, we can take another timestamp and calculate the elapsed time between the two as</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> timestamp <span style="color:#f92672">=</span> Instant::now();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> elapsed <span style="color:#f92672">=</span> timestamp.duration_since(last_frame_timestamp).as_secs_f32();</span></span></code></pre></div>
<p>The function <strong>duration_since</strong> will take an earlier timestamp and calculate a <strong>Duration</strong> between the two. We can choose how to extract information from this Duration but here we&rsquo;ll just get the total number of seconds as an f32, which handles partial seconds.</p>
<p>Once we have the elapsed time, we can rotate the model matrix by some amount - in this case we&rsquo;ll use a speed of 100 degrees per second</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>mvp.model <span style="color:#f92672">*=</span> Mat4::from_rotation_z(<span style="color:#ae81ff">100.0_</span><span style="color:#66d9ef">f32</span>.to_radians() <span style="color:#f92672">*</span> elapsed);</span></span></code></pre></div>
<p>Although notice that Mat4::from_rotation_z expects the angle in <strong>radians</strong> so we convert from degrees to radians by using the built-in Rust function on f32&rsquo;s, to_radians.</p>
<p>After rotating the model matrix, we update the timestamp of the previous frame, and request that the window be redrawn</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>last_frame_timestamp <span style="color:#f92672">=</span> timestamp;
</span></span><span style="display:flex;"><span>window.request_redraw();</span></span></code></pre></div>
<p>Running our program now, we can see a very nice <strong>rotating</strong> square!</p>
<video style="max-width: 100%" class="video-shortcode" preload="auto" controls>
    <source src="rotating.mp4" type="video/mp4">
    There should have been a video here but your browser does not seem
    to support it.
</video>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://forgottenmaster.github.io/">Robin Smith</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body>

</html>
