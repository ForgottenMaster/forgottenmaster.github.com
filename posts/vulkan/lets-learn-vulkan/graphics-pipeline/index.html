<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>7. Graphics Pipeline | Robin Firth</title>
<meta name="keywords" content="" />
<meta name="description" content="Now that we have somewhere to render to (surface), and something to render with (swapchain), we need to define how to render. This is going to be the responsibility of the graphics pipeline which we must set up manually.
Overview An overview of the graphics pipeline is shown below
Overview of graphics pipelineVulkan Tutorial
The sections highlighted in yellow indicate those sections which we can program through shader modules.">
<meta name="author" content="">
<link rel="canonical" href="https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/graphics-pipeline/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.6f60056d44d3f7eb69a4bc6c332b59960f3a995802bded244750232f33713c49.css" integrity="sha256-b2AFbUTT9&#43;tppLxsMytZlg86mVgCve0kR1AjLzNxPEk=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://forgottenmaster.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://forgottenmaster.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://forgottenmaster.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://forgottenmaster.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://forgottenmaster.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.92.2" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta property="og:title" content="7. Graphics Pipeline" />
<meta property="og:description" content="Now that we have somewhere to render to (surface), and something to render with (swapchain), we need to define how to render. This is going to be the responsibility of the graphics pipeline which we must set up manually.
Overview An overview of the graphics pipeline is shown below
Overview of graphics pipelineVulkan Tutorial
The sections highlighted in yellow indicate those sections which we can program through shader modules." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/graphics-pipeline/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-25T16:21:48&#43;00:00" />
<meta property="article:modified_time" content="2023-02-25T16:21:48&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="7. Graphics Pipeline"/>
<meta name="twitter:description" content="Now that we have somewhere to render to (surface), and something to render with (swapchain), we need to define how to render. This is going to be the responsibility of the graphics pipeline which we must set up manually.
Overview An overview of the graphics pipeline is shown below
Overview of graphics pipelineVulkan Tutorial
The sections highlighted in yellow indicate those sections which we can program through shader modules."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://forgottenmaster.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Vulkan",
      "item": "https://forgottenmaster.github.io/posts/vulkan/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Let's Learn Vulkan",
      "item": "https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "7. Graphics Pipeline",
      "item": "https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/graphics-pipeline/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "7. Graphics Pipeline",
  "name": "7. Graphics Pipeline",
  "description": "Now that we have somewhere to render to (surface), and something to render with (swapchain), we need to define how to render. This is going to be the responsibility of the graphics pipeline which we must set up manually.\nOverview An overview of the graphics pipeline is shown below\n\rOverview of graphics pipeline\rVulkan Tutorial\n\r\rThe sections highlighted in yellow indicate those sections which we can program through shader modules.",
  "keywords": [
    
  ],
  "articleBody": "Now that we have somewhere to render to (surface), and something to render with (swapchain), we need to define how to render. This is going to be the responsibility of the graphics pipeline which we must set up manually.\nOverview An overview of the graphics pipeline is shown below\n\rOverview of graphics pipeline\rVulkan Tutorial\n\r\rThe sections highlighted in yellow indicate those sections which we can program through shader modules. The green stages are fixed functionality, but we can tweak the settings for them.\nThe stages are described briefly below\n Input assembly: This stage is where the input buffers are taken and assembled/interpreted as some kinds of primitives. This stage assembles the input primitives (such as lines or triangles) from the input data buffers. Vertex shader: This stage is where we are able to modify the vertices coming in, such as determining their final position, but also we are able to define per-vertex data here too that is passed along the pipeline. Tesselation: This is able to break up primitives such as triangles into smaller triangles before being passed along to the next stage Geometry shader: A geometry shader is able to create brand new geometry as part of the pipeline. Rasterization: The rasterizer takes the per-vertex data that has been calculated, and determines the attributes at a given pixel/fragment on screen. For example the fragments of a filled triangle, where the data for a fragment is interpolated from the triangle vertices. Fragment shader: This stage allows us to determine the final properties and color of a fragment. Color blending: This blends the fragment color with the existing contents of the framebuffer to allow for transparency on closer objects to the camera for example.  The first things we’ll need to create in Vulkan before we can create the graphics pipeline itself are the pipeline layout and the render pass.\nPipeline Layout The pipeline layout is required to be created first and it tells Vulkan which resources a pipeline has access to and how they are bound. It contains both descriptor sets and push constant ranges but for now we will just ignore them entirely.\nThe creation function is actually super small so here it is in its entirety\nfn create_pipeline_layout(device: \u0026Device) - ResultPipelineLayout { unsafe { device.create_pipeline_layout( \u0026PipelineLayoutCreateInfo::builder() .set_layouts(\u0026[]) .push_constant_ranges(\u0026[]), None, ) } .context(\"Error trying to create a pipeline layout.\") } Note that we’re passing empty slices for descriptor set layouts, and push constant ranges.\nRender Pass In contrast to the pipeline layout, the render pass is a little more involved to set up but it’s not too bad conceptually.\nA render pass defines three main things:\n The attachments for the render pass. These define the formats for the bound resources/images used in a render pass, including their initial layout (before the render pass starts) and their final layout (after the render pass ends). The subpasses of the render pass. When the render pass runs, it will run each of the subpasses. Each subpass specifies which attachments it requires, along with the point in the graphics pipeline that that subpass will run. The subpass dependencies. These are required to let Vulkan know which stages need to happen before a subpass, and which can happen only after a subpass.  We’ll create a function to make our render pass, it’ll take the device, and also the format of our swapchain images so we can set up a color attachment with the same format.\nAttachment Descriptions The first thing we’ll need to figure out to create a render pass is which attachments we require. Each attachment will have a specific format, along with a sampling mode. Additionally we need to define which layout the attachment starts the render pass with, and which layout it should have after the render pass has finished.\nLayout is not the same as format though. Format is the number of bits per pixel, number of channels, etc. such as R8G8B8A8. Layout specifies how these bytes are laid out in memory for a particular purpose.\nFor this simple renderer, we only need a single attachment that will be set to be ready to be presented after the render pass\nlet attachment_descriptions = [*AttachmentDescription::builder() .format(format) .samples(SampleCountFlags::TYPE_1) .load_op(AttachmentLoadOp::CLEAR) .store_op(AttachmentStoreOp::STORE) .stencil_load_op(AttachmentLoadOp::DONT_CARE) .stencil_store_op(AttachmentStoreOp::DONT_CARE) .initial_layout(ImageLayout::UNDEFINED) .final_layout(ImageLayout::PRESENT_SRC_KHR)]; The rationale for the setup here is as follows\n format: Set to the same format as the images in our swapchain (passed into the create_render_pass function). This is because we will be using one of the images from the swapchain as attachment so requires the same format. samples: Set to the same number of samples as the images in the swapchain again. load_op: This is set to clear. This is the operation we want to perform on the attachment before the render pass is started. In our case we want to clear the attachment to a known good value. store_op: This is which operation we want to perform on the attachment after the render pass is finished. In this case we want to store the values for later presentation. stencil_load_op/stencil_store_op: Set both of these to “Don’t care” because we’re not using a stencil buffer at the moment. initial_layout: This is the initial layout for the image before the render pass starts. In this case we don’t really mind what the layout is when we start the pass, it’s undefined - it’ll be set to a different layout for our subpass soon. final_layout: Because we’re going to be presenting this attachment to the surface, we want it to be put into a layout optimal for that purpose at the end of the render pass.  Subpass Descriptions Next we need to define our subpass(es). In our case we have only a single subpass which will use our attachment as a color attachment.\nThe subpasses don’t deal with the attachments directly but instead deal with attachment references which are able to refer to the specific attachment but define that it should be put into a different format.\nThe subpass descriptions themselves are easy enough\nlet attachment_references = [*AttachmentReference::builder() .attachment(0) .layout(ImageLayout::COLOR_ATTACHMENT_OPTIMAL)]; let subpass_descriptions = [*SubpassDescription::builder() .pipeline_bind_point(PipelineBindPoint::GRAPHICS) .color_attachments(\u0026attachment_references)]; Here we\n Define a single attachment reference which refers to the attachment we defined earlier (attachment #0), and with layout optimal for being a color attachment. Binds to the graphics pipeline.  Subpass Dependencies Subpass dependencies are where we need to specify the stages at which the layout transitions for our attachments can happen.\nIn our case we have only a single subpass, but this subpass will need to perform a transition from “undefined” (at the start of the render pass) to “color attachment optimal” (for the subpass).\nHowever there will be other commands submitted to the GPU before our render pass potentially starts, so we need to let Vulkan know when this can happen.\nThere is a special subpass ID that vulkan uses called VK_SUBPASS_EXTERNAL to identify “everything before” or “everything after” our render passes.\nIn our case, we are only allowed to perform a transition once we’re allowed to write to our color attachments. Therefore our one dependency will be between “external” and our subpass 0\nlet subpass_dependencies = [*SubpassDependency::builder() .src_subpass(SUBPASS_EXTERNAL) .dst_subpass(0) .src_stage_mask(PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT) .dst_stage_mask(PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT) .src_access_mask(AccessFlags::empty()) .dst_access_mask(AccessFlags::COLOR_ATTACHMENT_WRITE)]; A brief summary is as follows\n src_subpass: We are dependant upon the “external” subpass here, which is everything outside our render pass. dst_subpass: This is subpass 0 that we’re defining our dependency for. src_stage_mask/dst_stage_mask: The transition can happen at the color attachment output stage. src_access_mask: We don’t need any particular memory access to start the transition. Just getting into the COLOR_ATTACHMENT_OUTPUT stage is sufficient. dst_access_mask: We need to wait until we’re allowed to write to the color attachment.  Creating the Render Pass We can now go ahead and slap all these together to make our render pass\ndevice.create_render_pass( \u0026RenderPassCreateInfo::builder() .attachments(\u0026attachment_descriptions) .subpasses(\u0026subpass_descriptions) .dependencies(\u0026subpass_dependencies), None, ) Graphics Pipeline With the above prerequisites created, we can go ahead and create a graphics pipeline. For now, we’ll bake most of the settings in, though we will need to take the layout and render pass in, along with a few other things. Signature of our create_graphics_pipeline function will look as follows\nfn create_graphics_pipeline( vertex_shader: ShaderModule, fragment_shader: ShaderModule, swapchain_extents: Extent2D, pipeline_layout: PipelineLayout, render_pass: RenderPass, device: \u0026Device, ) - ResultPipeline Shader Stages We firstly go ahead and take the two shader modules for vertex and fragment shaders and add the additional information that Vulkan will need to interface with them.\nFirstly, we need to define the name of the main function as a CStr. Both of our shaders use the name “main” as the entry point, so we can just create this name and re-use it\nlet name = unsafe { CStr::from_bytes_with_nul_unchecked(b\"main\\0\") }; We then define our array of shader stages and create a stage each for vertex and fragment shaders\nlet shader_stages = [ *PipelineShaderStageCreateInfo::builder() .stage(ShaderStageFlags::VERTEX) .module(vertex_shader) .name(name), *PipelineShaderStageCreateInfo::builder() .stage(ShaderStageFlags::FRAGMENT) .module(fragment_shader) .name(name), ]; Vertex Input The vertex input stage is where we define sources for our vertex data. However at the moment our vertex data is baked into the vertex shader and as such, we can go ahead and use the default version for now\nlet vertex_input = PipelineVertexInputStateCreateInfo::builder(); Input Assembly This defines how we are interpreting the vertex data coming in, whether it be lines or triangles for example. There are two components to this\n Topology: This is the main component and defines whether we are processing the input data as points, lines, or triangles. Within these primitives we can choose to have them in list form or strip form. We choose triangle list, so every group of 3 vertices will make a triangle and no data is shared. Primitive Restart: This allows us to use a special index when rendering using indexed data, to indicate that the primitive should be restarted. For example, if we’re rendering a strip of triangles, then every additional vertex from #4 onwards will be linked with the previous 2 to make a triangle. We can use the special restart index to instead forget those two previous triangles and start a new triangle with the next 3 verts. We will disable this  let input_assembly = PipelineInputAssemblyStateCreateInfo::builder() .topology(PrimitiveTopology::TRIANGLE_LIST) .primitive_restart_enable(false); Viewport State We next need to define our viewports and scissors which will control which portion of the image will be rendered to, and whether ay of it is clipped off.\nAs a visual representation of viewports and scissors, take the following image (image from Vulkan Tutorial)\n\rViewport and Scissor\rVulkan Tutorial\n\r\rViewport defines the offset and size of the image that we’ll render to as if it’s the entire screen. If a viewport is stretched or squished then the rendered image will be too.\nScissor defines the area that will be clipped off. This does not stretch or squish the image, but anything outside of the scissor rectangle will instead be cropped out.\nFor our case we’ll have:\n 1 viewport which starts at offset (0,0) and has the same extents as the swapchain images. Thus, this viewport takes up the entire image. We set the max depth to 1.0 which is the maximum that Vulkan goes to under normalized coordinates. 1 scissor which also covers the entire swapchain image.  let viewports = [Viewport { width: swapchain_extents.width as f32, height: swapchain_extents.height as f32, max_depth: 1.0, ..Viewport::default() }]; let scissors = [Rect2D { extent: swapchain_extents, ..Rect2D::default() }]; let viewport_state = PipelineViewportStateCreateInfo::builder() .viewports(\u0026viewports) .scissors(\u0026scissors); Rasterization The rasterization stage is where the pipeline takes the per-vertex data determined by the vertex, tesselation, and geometry shaders and interpolates that data across the fragments.\nIt can cull out back facing primitives which it determines by winding order\nlet rasterization_state = PipelineRasterizationStateCreateInfo::builder() .polygon_mode(PolygonMode::FILL) .cull_mode(CullModeFlags::BACK) .front_face(FrontFace::CLOCKWISE) .line_width(1.0); For our use case\n polygon_mode: This is the way that the polygons should be filled in. In this case we just want to completely fill our polygons/triangles. cull_mode: This determines which side if any of the rendered polygons are culled out when facing the camera. We say that the back faces of polygons are culled out. front_face: This determines the winding order resulting in the front face of the polygon. We choose clockwise which means that when you’re looking at the polygon straight-on, if the vertices are plotted in a clockwise fashion, it has its front face toward you. line_width: We set the line width to 1.0 here, but it’s possible with extensions to have thicker lines.  Multisample This one is pretty straightforward - we’re not yet using multisampling, so we set it to 1 sample\nlet multisample = PipelineMultisampleStateCreateInfo::builder() .rasterization_samples(SampleCountFlags::TYPE_1); Color Blending Color blending determines how a new fragment’s color is blended with an existing fragment in the framebuffer. This is used to have transparency/translucency on objects in the scene.\nThe basic formula for calculating the final color for a fragment is: color_op((src_color_blend_factor * src_color),(dst_color_blend_factor * dst_color))\nIn our case when blending, we want to multiply the new (src) color by its alpha, and the old (dst) color by 1-src_alpha, then add them together.\nFor example, if the incoming fragment has an alpha of 1 then the resulting fragment is set to the new color. If it has an alpha of 0, then the resulting fragment ends up being the old color. If 0.5, then the result will be halfway between the two colors.\nFor alpha value though, we don’t want to keep the old alpha, but just keep the new alpha (not that it’s used at all when it’s in the framebuffer).\nThe resulting code then looks as follows\nlet color_blend_attachments = [*PipelineColorBlendAttachmentState::builder() .blend_enable(true) .color_write_mask(ColorComponentFlags::RGBA) .src_color_blend_factor(BlendFactor::SRC_ALPHA) .dst_color_blend_factor(BlendFactor::ONE_MINUS_SRC_ALPHA) .color_blend_op(BlendOp::ADD) .src_alpha_blend_factor(BlendFactor::ONE) .dst_alpha_blend_factor(BlendFactor::ZERO) .alpha_blend_op(BlendOp::ADD)]; let color_blend = PipelineColorBlendStateCreateInfo::builder().attachments(\u0026color_blend_attachments); As another brief rundown of these settings\n blend_enable: Set to true because we are wanting to blend colors color_write_mask: Which components of our fragments we are operating on src_color_blend_factor: We use the alpha of the incoming fragment to determine how much of its color is used dst_color_blend_factor: We use 1-the alpha of the incoming fragment to determine how much of the fragment already in the framebuffer to use color_blend_op: We want to add these together to get the final blended color src_alpha_blend_factor: We want to just keep the new alpha dst_alpha_blend_factor: We don’t care what the old alpha was alpha_blend_op: Again we just add them together  Pipeline Creation We can now finally just throw everything together to make our pipeline. Note that Vulkan allows us to create multiple pipelines at once so we need to specify a list of creation structs.\nlet graphics_pipeline_create_infos = [*GraphicsPipelineCreateInfo::builder() .stages(\u0026shader_stages) .vertex_input_state(\u0026vertex_input) .input_assembly_state(\u0026input_assembly) .viewport_state(\u0026viewport_state) .rasterization_state(\u0026rasterization_state) .multisample_state(\u0026multisample) .color_blend_state(\u0026color_blend) .layout(pipeline_layout) .render_pass(render_pass) .subpass(0)]; unsafe { let pipelines = device .create_graphics_pipelines(PipelineCache::null(), \u0026graphics_pipeline_create_infos, None) .map_err(|(_, e)| e)?; Ok(pipelines[0]) } We need to call map_err on the return Result because Vulkan actually returns to us the pipelines created before an error occurred, along with the error. We don’t care too much about the already-created pipelines….although we could/should destroy them if this were production quality.\nWe know we’re creating only a single pipeline so we then go ahead and return pipelines[0].\n",
  "wordCount" : "2466",
  "inLanguage": "en",
  "datePublished": "2023-02-25T16:21:48Z",
  "dateModified": "2023-02-25T16:21:48Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/graphics-pipeline/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Robin Firth",
    "logo": {
      "@type": "ImageObject",
      "url": "https://forgottenmaster.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://forgottenmaster.github.io/" accesskey="h" title="Robin Firth (Alt + H)">Robin Firth</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://forgottenmaster.github.io/resume/" title="Résumé">
                    <span>Résumé</span>
                </a>
            </li>
            <li>
                <a href="https://forgottenmaster.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://forgottenmaster.github.io/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://forgottenmaster.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/vulkan/">Vulkan</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/">Let&#39;s Learn Vulkan</a></div>
    <h1 class="post-title">
      7. Graphics Pipeline
    </h1>
    <div class="post-meta"><span title='2023-02-25 16:21:48 +0000 UTC'>February 25, 2023</span>&nbsp;·&nbsp;12 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#overview" aria-label="Overview">Overview</a></li>
                <li>
                    <a href="#pipeline-layout" aria-label="Pipeline Layout">Pipeline Layout</a></li>
                <li>
                    <a href="#render-pass" aria-label="Render Pass">Render Pass</a><ul>
                        
                <li>
                    <a href="#attachment-descriptions" aria-label="Attachment Descriptions">Attachment Descriptions</a></li>
                <li>
                    <a href="#subpass-descriptions" aria-label="Subpass Descriptions">Subpass Descriptions</a></li>
                <li>
                    <a href="#subpass-dependencies" aria-label="Subpass Dependencies">Subpass Dependencies</a></li>
                <li>
                    <a href="#creating-the-render-pass" aria-label="Creating the Render Pass">Creating the Render Pass</a></li></ul>
                </li>
                <li>
                    <a href="#graphics-pipeline" aria-label="Graphics Pipeline">Graphics Pipeline</a><ul>
                        
                <li>
                    <a href="#shader-stages" aria-label="Shader Stages">Shader Stages</a></li>
                <li>
                    <a href="#vertex-input" aria-label="Vertex Input">Vertex Input</a></li>
                <li>
                    <a href="#input-assembly" aria-label="Input Assembly">Input Assembly</a></li>
                <li>
                    <a href="#viewport-state" aria-label="Viewport State">Viewport State</a></li>
                <li>
                    <a href="#rasterization" aria-label="Rasterization">Rasterization</a></li>
                <li>
                    <a href="#multisample" aria-label="Multisample">Multisample</a></li>
                <li>
                    <a href="#color-blending" aria-label="Color Blending">Color Blending</a></li>
                <li>
                    <a href="#pipeline-creation" aria-label="Pipeline Creation">Pipeline Creation</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Now that we have somewhere to render to (surface), and something to render with (swapchain), we need to define how to render. This is going to be the responsibility of the graphics pipeline which we must set up manually.</p>
<h1 id="overview">Overview<a hidden class="anchor" aria-hidden="true" href="#overview">#</a></h1>
<p>An overview of the graphics pipeline is shown below</p>
<figure class="align-center ">
    <img loading="lazy" src="graphics-pipeline.svg#center"/> <figcaption>
            Overview of graphics pipeline<p>
                    <a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Introduction">Vulkan Tutorial</a></p>
        </figcaption>
</figure>

<p>The sections highlighted in yellow indicate those sections which we can program through shader modules. The green stages are fixed functionality, but we can tweak the settings for them.</p>
<p>The stages are described briefly below</p>
<ol>
<li><strong>Input assembly</strong>: This stage is where the input buffers are taken and assembled/interpreted as some kinds of primitives. This stage assembles the input primitives (such as lines or triangles) from the input data buffers.</li>
<li><strong>Vertex shader</strong>: This stage is where we are able to modify the vertices coming in, such as determining their final position, but also we are able to define per-vertex data here too that is passed along the pipeline.</li>
<li><strong>Tesselation</strong>: This is able to break up primitives such as triangles into smaller triangles before being passed along to the next stage</li>
<li><strong>Geometry shader</strong>: A geometry shader is able to create brand new geometry as part of the pipeline.</li>
<li><strong>Rasterization</strong>: The rasterizer takes the per-vertex data that has been calculated, and determines the attributes at a given pixel/fragment on screen. For example the fragments of a filled triangle, where the data for a fragment is interpolated from the triangle vertices.</li>
<li><strong>Fragment shader</strong>: This stage allows us to determine the final properties and color of a fragment.</li>
<li><strong>Color blending</strong>: This blends the fragment color with the existing contents of the framebuffer to allow for transparency on closer objects to the camera for example.</li>
</ol>
<p>The first things we&rsquo;ll need to create in Vulkan before we can create the graphics pipeline itself are the <strong>pipeline layout</strong> and the <strong>render pass</strong>.</p>
<h1 id="pipeline-layout">Pipeline Layout<a hidden class="anchor" aria-hidden="true" href="#pipeline-layout">#</a></h1>
<p>The pipeline layout is required to be created first and it tells Vulkan which resources a pipeline has access to and how they are bound. It contains both <strong>descriptor sets</strong> and <strong>push constant ranges</strong> but for now we will just ignore them entirely.</p>
<p>The creation function is actually super small so here it is in its entirety</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">create_pipeline_layout</span>(device: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Device</span>) -&gt; Result<span style="color:#f92672">&lt;</span>PipelineLayout<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">unsafe</span> {
        device.create_pipeline_layout(
            <span style="color:#f92672">&amp;</span>PipelineLayoutCreateInfo::builder()
                .set_layouts(<span style="color:#f92672">&amp;</span>[])
                .push_constant_ranges(<span style="color:#f92672">&amp;</span>[]),
            None,
        )
    }
    .context(<span style="color:#e6db74">&#34;Error trying to create a pipeline layout.&#34;</span>)
}</code></pre></div>
<p>Note that we&rsquo;re passing empty slices for descriptor set layouts, and push constant ranges.</p>
<h1 id="render-pass">Render Pass<a hidden class="anchor" aria-hidden="true" href="#render-pass">#</a></h1>
<p>In contrast to the pipeline layout, the render pass is a little more involved to set up but it&rsquo;s not too bad conceptually.</p>
<p>A render pass defines three main things:</p>
<ol>
<li>The <strong>attachments</strong> for the render pass. These define the formats for the bound resources/images used in a render pass, including their initial layout (before the render pass starts) and their final layout (after the render pass ends).</li>
<li>The <strong>subpasses</strong> of the render pass. When the render pass runs, it will run each of the subpasses. Each subpass specifies which attachments it requires, along with the point in the graphics pipeline that that subpass will run.</li>
<li>The <strong>subpass dependencies</strong>. These are required to let Vulkan know which stages need to happen before a subpass, and which can happen only after a subpass.</li>
</ol>
<p>We&rsquo;ll create a function to make our render pass, it&rsquo;ll take the device, and also the format of our swapchain images so we can set up a color attachment with the same format.</p>
<h2 id="attachment-descriptions">Attachment Descriptions<a hidden class="anchor" aria-hidden="true" href="#attachment-descriptions">#</a></h2>
<p>The first thing we&rsquo;ll need to figure out to create a render pass is which attachments we require. Each attachment will have a specific format, along with a sampling mode. Additionally we need to define which layout the attachment starts the render pass with, and which layout it should have after the render pass has finished.</p>
<p>Layout is not the same as format though. Format is the number of bits per pixel, number of channels, etc. such as R8G8B8A8. Layout specifies how these bytes are laid out in memory for a particular purpose.</p>
<p>For this simple renderer, we only need a single attachment that will be set to be ready to be presented after the render pass</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> attachment_descriptions <span style="color:#f92672">=</span> [<span style="color:#f92672">*</span>AttachmentDescription::builder()
    .format(format)
    .samples(SampleCountFlags::TYPE_1)
    .load_op(AttachmentLoadOp::CLEAR)
    .store_op(AttachmentStoreOp::STORE)
    .stencil_load_op(AttachmentLoadOp::DONT_CARE)
    .stencil_store_op(AttachmentStoreOp::DONT_CARE)
    .initial_layout(ImageLayout::UNDEFINED)
    .final_layout(ImageLayout::PRESENT_SRC_KHR)];</code></pre></div>
<p>The rationale for the setup here is as follows</p>
<ol>
<li><strong>format</strong>: Set to the same format as the images in our swapchain (passed into the create_render_pass function). This is because we will be using one of the images from the swapchain as attachment so requires the same format.</li>
<li><strong>samples</strong>: Set to the same number of samples as the images in the swapchain again.</li>
<li><strong>load_op</strong>: This is set to clear. This is the operation we want to perform on the attachment before the render pass is started. In our case we want to clear the attachment to a known good value.</li>
<li><strong>store_op</strong>: This is which operation we want to perform on the attachment after the render pass is finished. In this case we want to store the values for later presentation.</li>
<li><strong>stencil_load_op</strong>/<strong>stencil_store_op</strong>: Set both of these to &ldquo;Don&rsquo;t care&rdquo; because we&rsquo;re not using a stencil buffer at the moment.</li>
<li><strong>initial_layout</strong>: This is the initial layout for the image before the render pass starts. In this case we don&rsquo;t really mind what the layout is when we start the pass, it&rsquo;s undefined - it&rsquo;ll be set to a different layout for our subpass soon.</li>
<li><strong>final_layout</strong>: Because we&rsquo;re going to be presenting this attachment to the surface, we want it to be put into a layout optimal for that purpose at the end of the render pass.</li>
</ol>
<h2 id="subpass-descriptions">Subpass Descriptions<a hidden class="anchor" aria-hidden="true" href="#subpass-descriptions">#</a></h2>
<p>Next we need to define our subpass(es). In our case we have only a single subpass which will use our attachment as a color attachment.</p>
<p>The subpasses don&rsquo;t deal with the attachments directly but instead deal with <strong>attachment references</strong> which are able to refer to the specific attachment but define that it should be put into a different format.</p>
<p>The subpass descriptions themselves are easy enough</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> attachment_references <span style="color:#f92672">=</span> [<span style="color:#f92672">*</span>AttachmentReference::builder()
    .attachment(<span style="color:#ae81ff">0</span>)
    .layout(ImageLayout::COLOR_ATTACHMENT_OPTIMAL)];
<span style="color:#66d9ef">let</span> subpass_descriptions <span style="color:#f92672">=</span> [<span style="color:#f92672">*</span>SubpassDescription::builder()
    .pipeline_bind_point(PipelineBindPoint::GRAPHICS)
    .color_attachments(<span style="color:#f92672">&amp;</span>attachment_references)];</code></pre></div>
<p>Here we</p>
<ol>
<li>Define a single attachment reference which refers to the attachment we defined earlier (attachment #0), and with layout optimal for being a color attachment.</li>
<li>Binds to the graphics pipeline.</li>
</ol>
<h2 id="subpass-dependencies">Subpass Dependencies<a hidden class="anchor" aria-hidden="true" href="#subpass-dependencies">#</a></h2>
<p>Subpass dependencies are where we need to specify the stages at which the layout transitions for our attachments can happen.</p>
<p>In our case we have only a single subpass, but this subpass will need to perform a transition from &ldquo;undefined&rdquo; (at the start of the render pass) to &ldquo;color attachment optimal&rdquo; (for the subpass).</p>
<p>However there will be other commands submitted to the GPU before our render pass potentially starts, so we need to let Vulkan know <strong>when</strong> this can happen.</p>
<p>There is a special subpass ID that vulkan uses called VK_SUBPASS_EXTERNAL to identify &ldquo;everything before&rdquo; or &ldquo;everything after&rdquo; our render passes.</p>
<p>In our case, we are only allowed to perform a transition once we&rsquo;re allowed to write to our color attachments. Therefore our one dependency will be between &ldquo;external&rdquo; and our subpass 0</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> subpass_dependencies <span style="color:#f92672">=</span> [<span style="color:#f92672">*</span>SubpassDependency::builder()
    .src_subpass(SUBPASS_EXTERNAL)
    .dst_subpass(<span style="color:#ae81ff">0</span>)
    .src_stage_mask(PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT)
    .dst_stage_mask(PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT)
    .src_access_mask(AccessFlags::empty())
    .dst_access_mask(AccessFlags::COLOR_ATTACHMENT_WRITE)];</code></pre></div>
<p>A brief summary is as follows</p>
<ol>
<li><strong>src_subpass</strong>: We are dependant upon the &ldquo;external&rdquo; subpass here, which is everything outside our render pass.</li>
<li><strong>dst_subpass</strong>: This is subpass 0 that we&rsquo;re defining our dependency for.</li>
<li><strong>src_stage_mask</strong>/<strong>dst_stage_mask</strong>: The transition can happen at the color attachment output stage.</li>
<li><strong>src_access_mask</strong>: We don&rsquo;t need any particular memory access to start the transition. Just getting into the COLOR_ATTACHMENT_OUTPUT stage is sufficient.</li>
<li><strong>dst_access_mask</strong>: We need to wait until we&rsquo;re allowed to write to the color attachment.</li>
</ol>
<h2 id="creating-the-render-pass">Creating the Render Pass<a hidden class="anchor" aria-hidden="true" href="#creating-the-render-pass">#</a></h2>
<p>We can now go ahead and slap all these together to make our render pass</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">device.create_render_pass(
    <span style="color:#f92672">&amp;</span>RenderPassCreateInfo::builder()
        .attachments(<span style="color:#f92672">&amp;</span>attachment_descriptions)
        .subpasses(<span style="color:#f92672">&amp;</span>subpass_descriptions)
        .dependencies(<span style="color:#f92672">&amp;</span>subpass_dependencies),
    None,
)</code></pre></div>
<h1 id="graphics-pipeline">Graphics Pipeline<a hidden class="anchor" aria-hidden="true" href="#graphics-pipeline">#</a></h1>
<p>With the above prerequisites created, we can go ahead and create a graphics pipeline. For now, we&rsquo;ll bake most of the settings in, though we will need to take the layout and render pass in, along with a few other things. Signature of our create_graphics_pipeline function will look as follows</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">create_graphics_pipeline</span>(
    vertex_shader: <span style="color:#a6e22e">ShaderModule</span>,
    fragment_shader: <span style="color:#a6e22e">ShaderModule</span>,
    swapchain_extents: <span style="color:#a6e22e">Extent2D</span>,
    pipeline_layout: <span style="color:#a6e22e">PipelineLayout</span>,
    render_pass: <span style="color:#a6e22e">RenderPass</span>,
    device: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Device</span>,
) -&gt; Result<span style="color:#f92672">&lt;</span>Pipeline<span style="color:#f92672">&gt;</span></code></pre></div>
<h2 id="shader-stages">Shader Stages<a hidden class="anchor" aria-hidden="true" href="#shader-stages">#</a></h2>
<p>We firstly go ahead and take the two shader modules for vertex and fragment shaders and add the additional information that Vulkan will need to interface with them.</p>
<p>Firstly, we need to define the name of the main function as a CStr. Both of our shaders use the name &ldquo;main&rdquo; as the entry point, so we can just create this name and re-use it</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> name <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { CStr::from_bytes_with_nul_unchecked(<span style="color:#e6db74">b&#34;main</span><span style="color:#ae81ff">\0</span><span style="color:#e6db74">&#34;</span>) };</code></pre></div>
<p>We then define our array of shader stages and create a stage each for vertex and fragment shaders</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> shader_stages <span style="color:#f92672">=</span> [
    <span style="color:#f92672">*</span>PipelineShaderStageCreateInfo::builder()
        .stage(ShaderStageFlags::VERTEX)
        .module(vertex_shader)
        .name(name),
    <span style="color:#f92672">*</span>PipelineShaderStageCreateInfo::builder()
        .stage(ShaderStageFlags::FRAGMENT)
        .module(fragment_shader)
        .name(name),
];</code></pre></div>
<h2 id="vertex-input">Vertex Input<a hidden class="anchor" aria-hidden="true" href="#vertex-input">#</a></h2>
<p>The vertex input stage is where we define sources for our vertex data. However at the moment our vertex data is baked into the vertex shader and as such, we can go ahead and use the default version for now</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> vertex_input <span style="color:#f92672">=</span> PipelineVertexInputStateCreateInfo::builder();</code></pre></div>
<h2 id="input-assembly">Input Assembly<a hidden class="anchor" aria-hidden="true" href="#input-assembly">#</a></h2>
<p>This defines how we are interpreting the vertex data coming in, whether it be lines or triangles for example. There are two components to this</p>
<ol>
<li><strong>Topology</strong>: This is the main component and defines whether we are processing the input data as points, lines, or triangles. Within these primitives we can choose to have them in list form or strip form. We choose triangle list, so every group of 3 vertices will make a triangle and no data is shared.</li>
<li><strong>Primitive Restart</strong>: This allows us to use a special index when rendering using indexed data, to indicate that the primitive should be restarted. For example, if we&rsquo;re rendering a strip of triangles, then every additional vertex from #4 onwards will be linked with the previous 2 to make a triangle. We can use the special restart index to instead forget those two previous triangles and start a new triangle with the next 3 verts. We will disable this</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> input_assembly <span style="color:#f92672">=</span> PipelineInputAssemblyStateCreateInfo::builder()
    .topology(PrimitiveTopology::TRIANGLE_LIST)
    .primitive_restart_enable(<span style="color:#66d9ef">false</span>);</code></pre></div>
<h2 id="viewport-state">Viewport State<a hidden class="anchor" aria-hidden="true" href="#viewport-state">#</a></h2>
<p>We next need to define our <strong>viewports</strong> and <strong>scissors</strong> which will control which portion of the image will be rendered to, and whether ay of it is clipped off.</p>
<p>As a visual representation of viewports and scissors, take the following image (image from Vulkan Tutorial)</p>
<figure class="align-center ">
    <img loading="lazy" src="viewport-and-scissor.png#center"/> <figcaption>
            Viewport and Scissor<p>
                    <a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Fixed_functions#page_Viewports-and-scissors">Vulkan Tutorial</a></p>
        </figcaption>
</figure>

<p><strong>Viewport</strong> defines the offset and size of the image that we&rsquo;ll render to as if it&rsquo;s the entire screen. If a viewport is stretched or squished then the rendered image will be too.</p>
<p><strong>Scissor</strong> defines the area that will be clipped off. This does not stretch or squish the image, but anything outside of the scissor rectangle will instead be cropped out.</p>
<p>For our case we&rsquo;ll have:</p>
<ul>
<li><strong>1 viewport</strong> which starts at offset (0,0) and has the same extents as the swapchain images. Thus, this viewport takes up the entire image. We set the max depth to 1.0 which is the maximum that Vulkan goes to under normalized coordinates.</li>
<li><strong>1 scissor</strong> which also covers the entire swapchain image.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> viewports <span style="color:#f92672">=</span> [Viewport {
    width: <span style="color:#a6e22e">swapchain_extents</span>.width <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f32</span>,
    height: <span style="color:#a6e22e">swapchain_extents</span>.height <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f32</span>,
    max_depth: <span style="color:#ae81ff">1.0</span>,
    <span style="color:#f92672">..</span>Viewport::default()
}];
<span style="color:#66d9ef">let</span> scissors <span style="color:#f92672">=</span> [Rect2D {
    extent: <span style="color:#a6e22e">swapchain_extents</span>,
    <span style="color:#f92672">..</span>Rect2D::default()
}];
<span style="color:#66d9ef">let</span> viewport_state <span style="color:#f92672">=</span> PipelineViewportStateCreateInfo::builder()
    .viewports(<span style="color:#f92672">&amp;</span>viewports)
    .scissors(<span style="color:#f92672">&amp;</span>scissors);</code></pre></div>
<h2 id="rasterization">Rasterization<a hidden class="anchor" aria-hidden="true" href="#rasterization">#</a></h2>
<p>The rasterization stage is where the pipeline takes the per-vertex data determined by the vertex, tesselation, and geometry shaders and interpolates that data across the fragments.</p>
<p>It can cull out back facing primitives which it determines by winding order</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> rasterization_state <span style="color:#f92672">=</span> PipelineRasterizationStateCreateInfo::builder()
    .polygon_mode(PolygonMode::FILL)
    .cull_mode(CullModeFlags::BACK)
    .front_face(FrontFace::CLOCKWISE)
    .line_width(<span style="color:#ae81ff">1.0</span>);</code></pre></div>
<p>For our use case</p>
<ul>
<li><strong>polygon_mode</strong>: This is the way that the polygons should be filled in. In this case we just want to completely fill our polygons/triangles.</li>
<li><strong>cull_mode</strong>: This determines which side if any of the rendered polygons are culled out when facing the camera. We say that the back faces of polygons are culled out.</li>
<li><strong>front_face</strong>: This determines the winding order resulting in the front face of the polygon. We choose clockwise which means that when you&rsquo;re looking at the polygon straight-on, if the vertices are plotted in a clockwise fashion, it has its front face toward you.</li>
<li><strong>line_width</strong>: We set the line width to 1.0 here, but it&rsquo;s possible with extensions to have thicker lines.</li>
</ul>
<h2 id="multisample">Multisample<a hidden class="anchor" aria-hidden="true" href="#multisample">#</a></h2>
<p>This one is pretty straightforward - we&rsquo;re not yet using multisampling, so we set it to 1 sample</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> multisample <span style="color:#f92672">=</span> PipelineMultisampleStateCreateInfo::builder()
    .rasterization_samples(SampleCountFlags::TYPE_1);</code></pre></div>
<h2 id="color-blending">Color Blending<a hidden class="anchor" aria-hidden="true" href="#color-blending">#</a></h2>
<p>Color blending determines how a new fragment&rsquo;s color is blended with an existing fragment in the framebuffer. This is used to have transparency/translucency on objects in the scene.</p>
<p>The basic formula for calculating the final color for a fragment is: <strong>color_op((src_color_blend_factor * src_color),(dst_color_blend_factor * dst_color))</strong></p>
<p>In our case when blending, we want to multiply the new (src) color by its alpha, and the old (dst) color by 1-src_alpha, then add them together.</p>
<p>For example, if the incoming fragment has an alpha of 1 then the resulting fragment is set to the new color. If it has an alpha of 0, then the resulting fragment ends up being the old color. If 0.5, then the result will be halfway between the two colors.</p>
<p>For alpha value though, we don&rsquo;t want to keep the old alpha, but just keep the new alpha (not that it&rsquo;s used at all when it&rsquo;s in the framebuffer).</p>
<p>The resulting code then looks as follows</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> color_blend_attachments <span style="color:#f92672">=</span> [<span style="color:#f92672">*</span>PipelineColorBlendAttachmentState::builder()
    .blend_enable(<span style="color:#66d9ef">true</span>)
    .color_write_mask(ColorComponentFlags::RGBA)
    .src_color_blend_factor(BlendFactor::SRC_ALPHA)
    .dst_color_blend_factor(BlendFactor::ONE_MINUS_SRC_ALPHA)
    .color_blend_op(BlendOp::ADD)
    .src_alpha_blend_factor(BlendFactor::ONE)
    .dst_alpha_blend_factor(BlendFactor::ZERO)
    .alpha_blend_op(BlendOp::ADD)];
<span style="color:#66d9ef">let</span> color_blend <span style="color:#f92672">=</span>
    PipelineColorBlendStateCreateInfo::builder().attachments(<span style="color:#f92672">&amp;</span>color_blend_attachments);</code></pre></div>
<p>As another brief rundown of these settings</p>
<ol>
<li><strong>blend_enable</strong>: Set to true because we are wanting to blend colors</li>
<li><strong>color_write_mask</strong>: Which components of our fragments we are operating on</li>
<li><strong>src_color_blend_factor</strong>: We use the alpha of the incoming fragment to determine how much of its color is used</li>
<li><strong>dst_color_blend_factor</strong>: We use 1-the alpha of the incoming fragment to determine how much of the fragment already in the framebuffer to use</li>
<li><strong>color_blend_op</strong>: We want to add these together to get the final blended color</li>
<li><strong>src_alpha_blend_factor</strong>: We want to just keep the new alpha</li>
<li><strong>dst_alpha_blend_factor</strong>: We don&rsquo;t care what the old alpha was</li>
<li><strong>alpha_blend_op</strong>: Again we just add them together</li>
</ol>
<h2 id="pipeline-creation">Pipeline Creation<a hidden class="anchor" aria-hidden="true" href="#pipeline-creation">#</a></h2>
<p>We can now finally just throw everything together to make our pipeline. Note that Vulkan allows us to create multiple pipelines at once so we need to specify a list of creation structs.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> graphics_pipeline_create_infos <span style="color:#f92672">=</span> [<span style="color:#f92672">*</span>GraphicsPipelineCreateInfo::builder()
    .stages(<span style="color:#f92672">&amp;</span>shader_stages)
    .vertex_input_state(<span style="color:#f92672">&amp;</span>vertex_input)
    .input_assembly_state(<span style="color:#f92672">&amp;</span>input_assembly)
    .viewport_state(<span style="color:#f92672">&amp;</span>viewport_state)
    .rasterization_state(<span style="color:#f92672">&amp;</span>rasterization_state)
    .multisample_state(<span style="color:#f92672">&amp;</span>multisample)
    .color_blend_state(<span style="color:#f92672">&amp;</span>color_blend)
    .layout(pipeline_layout)
    .render_pass(render_pass)
    .subpass(<span style="color:#ae81ff">0</span>)];
<span style="color:#66d9ef">unsafe</span> {
    <span style="color:#66d9ef">let</span> pipelines <span style="color:#f92672">=</span> device
        .create_graphics_pipelines(PipelineCache::null(), <span style="color:#f92672">&amp;</span>graphics_pipeline_create_infos, None)
        .map_err(<span style="color:#f92672">|</span>(_, e)<span style="color:#f92672">|</span> e)<span style="color:#f92672">?</span>;
    Ok(pipelines[<span style="color:#ae81ff">0</span>])
}</code></pre></div>
<p>We need to call map_err on the return Result because Vulkan actually returns to us the pipelines created before an error occurred, along with the error. We don&rsquo;t care too much about the already-created pipelines&hellip;.although we could/should destroy them if this were production quality.</p>
<p>We know we&rsquo;re creating only a single pipeline so we then go ahead and return pipelines[0].</p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://forgottenmaster.github.io/">Robin Firth</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
