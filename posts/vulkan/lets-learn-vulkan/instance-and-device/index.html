<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>2. The Window, the Instance, and the Device | Robin Smith</title>
<meta name="keywords" content="">
<meta name="description" content="The first things we&rsquo;ll need to do to start using Vulkan will be to open a window to render into, create a Vulkan instance, and create a logical Vulkan device from that instance.
The end result will just show a blank white window as shown below.
Event loop and window The first step which we can get out of the way before even touching Vulkan will be to create a window for us to eventually render into, and an event loop that winit uses to allow us to handle the events from the user such as resizing etc.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/vulkan/lets-learn-vulkan/instance-and-device/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/vulkan/lets-learn-vulkan/instance-and-device/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Robin Smith (Alt + H)">Robin Smith</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/resume/" title="Résumé">
                    <span>Résumé</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/vulkan/">Vulkan</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/vulkan/lets-learn-vulkan/">Let&#39;s Learn Vulkan</a></div>
    <h1 class="post-title entry-hint-parent">
      2. The Window, the Instance, and the Device
    </h1>
    <div class="post-meta"><span title='2023-02-15 22:32:00 +0000 UTC'>February 15, 2023</span>&nbsp;·&nbsp;14 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#event-loop-and-window" aria-label="Event loop and window">Event loop and window</a></li>
                <li>
                    <a href="#ash-entry-point" aria-label="Ash entry point">Ash entry point</a></li>
                <li>
                    <a href="#creating-an-instance" aria-label="Creating an instance">Creating an instance</a><ul>
                        
                <li>
                    <a href="#preparing-our-application-name" aria-label="Preparing our application name">Preparing our application name</a></li>
                <li>
                    <a href="#application-and-api-versions" aria-label="Application and API versions">Application and API versions</a></li>
                <li>
                    <a href="#applicationinfo" aria-label="ApplicationInfo">ApplicationInfo</a></li>
                <li>
                    <a href="#gathering-extensions" aria-label="Gathering extensions">Gathering extensions</a></li>
                <li>
                    <a href="#validating-extensions" aria-label="Validating extensions">Validating extensions</a></li>
                <li>
                    <a href="#creating-the-instance-creation-info" aria-label="Creating the instance creation info">Creating the instance creation info</a></li>
                <li>
                    <a href="#creating-the-instance" aria-label="Creating the instance">Creating the instance</a></li></ul>
                </li>
                <li>
                    <a href="#selecting-a-physical-device" aria-label="Selecting a physical device">Selecting a physical device</a></li>
                <li>
                    <a href="#creating-the-vulkan-device" aria-label="Creating the Vulkan device">Creating the Vulkan device</a></li>
                <li>
                    <a href="#running-the-event-loop" aria-label="Running the event loop">Running the event loop</a></li>
                <li>
                    <a href="#cleaning-up" aria-label="Cleaning up">Cleaning up</a></li>
                <li>
                    <a href="#putting-it-all-together" aria-label="Putting it all together">Putting it all together</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>The first things we&rsquo;ll need to do to start using Vulkan will be to open a window to render into, create a Vulkan instance, and create a logical Vulkan device from that instance.</p>
<p>The end result will just show a blank white window as shown below.</p>
<p><img loading="lazy" src="window.PNG" alt="Blank Window"  />
</p>
<h1 id="event-loop-and-window">Event loop and window<a hidden class="anchor" aria-hidden="true" href="#event-loop-and-window">#</a></h1>
<p>The first step which we can get out of the way before even touching Vulkan will be to create a window for us to eventually render into, and an event loop that winit uses to allow us to handle the events from the user such as resizing etc.</p>
<p>The function to create the EventLoop, and the window is fairly straightforward here:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">create_event_loop_and_window</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(EventLoop<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span>, Window)<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> event_loop <span style="color:#f92672">=</span> EventLoop::new();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> window <span style="color:#f92672">=</span> create_window(<span style="color:#f92672">&amp;</span>event_loop).context(<span style="color:#e6db74">&#34;Error in create_event_loop_and_window&#34;</span>)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>    Ok((event_loop, window))
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>As with most of our functions, this returns an <strong>anyhow::Result</strong>. We use anyhow in order to get a common Result/error type to be used and can be propagated up the callstack, additionally allowing us to add context.</p>
<p>In the case of success, we return the event loop, and the window as tuple. If a failure were to occur, we make sure to add appropriate context to the Result we&rsquo;re propagating so that when it&rsquo;s printed out we can see the trace that caused the error.</p>
<p>In order to add context to an anyhow::Result, we use the <strong>context</strong> method as shown in the above snippet.</p>
<p>The event loop is a simple infallible constructor, but the window can fail. We wrap up window construction into the <strong>create_window</strong> method which looks as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">create_window</span>(event_loop: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">EventLoop</span><span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span>) -&gt; Result<span style="color:#f92672">&lt;</span>Window<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    WindowBuilder::new()
</span></span><span style="display:flex;"><span>        .with_resizable(<span style="color:#66d9ef">false</span>)
</span></span><span style="display:flex;"><span>        .with_title(<span style="color:#e6db74">&#34;Let&#39;s Learn Vulkan&#34;</span>)
</span></span><span style="display:flex;"><span>        .with_inner_size(Size::Physical(PhysicalSize {
</span></span><span style="display:flex;"><span>            width: <span style="color:#ae81ff">800</span>,
</span></span><span style="display:flex;"><span>            height: <span style="color:#ae81ff">600</span>,
</span></span><span style="display:flex;"><span>        }))
</span></span><span style="display:flex;"><span>        .build(event_loop)
</span></span><span style="display:flex;"><span>        .context(<span style="color:#e6db74">&#34;Error in create_window.&#34;</span>)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>In this case, the WindowBuilder requires the EventLoop so we pass that in by reference. On success will return the created window, but it&rsquo;s fallible so we use anyhow::Result again.</p>
<p>We set the window to not be resizable (so that we don&rsquo;t have to deal with swapchain recreation just yet), and fix it to a size of 800x600 for now.</p>
<h1 id="ash-entry-point">Ash entry point<a hidden class="anchor" aria-hidden="true" href="#ash-entry-point">#</a></h1>
<p>The first thing we need to do is to get the entry point object from which we create Vulkan instances. In Ash, which is the Vulkan library we&rsquo;re using, there are two methods of getting the Vulkan entry point:</p>
<ol>
<li><strong>Entry::linked</strong> - Statically links Vulkan into the program. This requires the Vulkan SDK to be installed on development machine, but executables don&rsquo;t need to dynamically find the Vulkan loader on the target machine.</li>
<li><strong>Entry::load</strong> - Dynamically loads Vulkan on the target machine. This is fallible because Vulkan may fail to be located on the target machine.</li>
</ol>
<p>We&rsquo;ll use Entry::linked because we have installed the Vulkan SDK on our development machine.</p>
<h1 id="creating-an-instance">Creating an instance<a hidden class="anchor" aria-hidden="true" href="#creating-an-instance">#</a></h1>
<p>Now that we have the window and an entry point, we can create the first kind of object that Vulkan needs to be set up. The first object type is an <strong>instance</strong> and it contains metadata relating to the application name, engine name &amp; version, etc.</p>
<p>It also defines which version of the Vulkan API we&rsquo;re using, and which extensions and layers we want to enable too.</p>
<p>The first thing we&rsquo;ll want is to prepare our application name to pass to the instance creation. Now, this isn&rsquo;t actually necessary&hellip;in fact the only thing that&rsquo;s <em>required</em> for the app info is the Vulkan API version that we want to use.</p>
<h2 id="preparing-our-application-name">Preparing our application name<a hidden class="anchor" aria-hidden="true" href="#preparing-our-application-name">#</a></h2>
<p>The Ash API takes our application name as a CStr object, which is a non-owning value that represents a view into some memory that represents a C-style string.</p>
<p>A C-style string is a byte string which is <strong>null-terminated</strong>.</p>
<p>We can construct a CStr <em>unsafely</em> with the from_bytes_with_nul_unchecked associated function. This is marked as unsafe because it expects the bytes that it&rsquo;s given to contain a null-terminator at the end, and doesn&rsquo;t validate that it does.</p>
<p>However, since we&rsquo;re hardcoding the application name byte string in code here, we can guarantee that it&rsquo;s a valid null-terminated string, and can make a CStr with the following code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> application_name <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { CStr::from_bytes_with_nul_unchecked(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;Let&#39;s Learn Vulkan</span><span style="color:#ae81ff">\0</span><span style="color:#e6db74">&#34;</span>) };</span></span></code></pre></div>
<h2 id="application-and-api-versions">Application and API versions<a hidden class="anchor" aria-hidden="true" href="#application-and-api-versions">#</a></h2>
<p>The application version again is optional, and can be any valid version. The Vulkan API version however is mandatory, and must be only one of a fixed set of version numbers.</p>
<p>In order to construct an arbitrary version from a (variant, major, minor, patch) quartet, we can use the <strong>make_api_version</strong> function from Ash, as <strong>vk::make_api_version(1, 1, 0, 0)</strong>.</p>
<p>For the API version, there are a set of constants that we can use instead. In this case, we&rsquo;ll use API version 1.3 which is the latest as of writing. The constant can be accessed as <strong>vk::API_VERSION_1_3</strong>.</p>
<h2 id="applicationinfo">ApplicationInfo<a hidden class="anchor" aria-hidden="true" href="#applicationinfo">#</a></h2>
<p>Ash provides some nice builders for each of the structs Vulkan uses, so we only need to specify those fields we are actually using.</p>
<p>In our case, we will set the application name, version, and API version with the following code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> application_info <span style="color:#f92672">=</span> vk::ApplicationInfo::builder()
</span></span><span style="display:flex;"><span>    .application_name(application_name)
</span></span><span style="display:flex;"><span>    .application_version(vk::make_api_version(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>    .api_version(vk::<span style="color:#66d9ef">API_VERSION_1_3</span>);</span></span></code></pre></div>
<h2 id="gathering-extensions">Gathering extensions<a hidden class="anchor" aria-hidden="true" href="#gathering-extensions">#</a></h2>
<p>This is where we can specify the extensions we want to enable in the created Vulkan instance, but for now we&rsquo;ll only request the essential extensions that are required to display to the window that we&rsquo;ve created.</p>
<p>The ash_window crate we&rsquo;re using can take any <strong>RawDisplayHandle</strong> and give back the list of extensions that we will need to enable to support that display.</p>
<p>Conveniently, winit can return one of these handles for us!. As such, getting the list of required extensions is simply a case of calling the <strong>enumerate_required_extensions</strong> function and passing the display handle from the window.</p>
<p>We can do this with the following code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> raw_display_handle <span style="color:#f92672">=</span> window.raw_display_handle();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> required_extensions <span style="color:#f92672">=</span> enumerate_required_extensions(raw_display_handle)<span style="color:#f92672">?</span>;</span></span></code></pre></div>
<h2 id="validating-extensions">Validating extensions<a hidden class="anchor" aria-hidden="true" href="#validating-extensions">#</a></h2>
<p>Now that we&rsquo;ve gathered the extensions we require, we need to validate that those extensions are supported on the target machine. We would get a generic error if we try to create the instance with an extension that&rsquo;s not supported, but checking them ourselves first will let us report a better error message.</p>
<p>We&rsquo;ll go ahead and make a validation function to do this. It will take a slice of *<strong>const i8</strong> which are pointers to C-style strings.</p>
<p>The function will also need access to the ash::Entry instance we made because it uses this to query the available extensions on the machine.</p>
<p>Additionally, the function must be marked as unsafe, because we&rsquo;re accepting a slice of raw pointers and trusting that the caller has ensured they all point to valid null-terminated memory.</p>
<p>The signature of the function then will look as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">unsafe</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">validate_required_extensions</span>(
</span></span><span style="display:flex;"><span>    required_extensions: <span style="color:#66d9ef">&amp;</span>[<span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">i8</span>],
</span></span><span style="display:flex;"><span>    entry: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Entry</span>,
</span></span><span style="display:flex;"><span>) -&gt; Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// contents
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}</span></span></code></pre></div>
<p>We return an anyhow::Result because this is fallible, specifically because we are using it as a way to validate that all the extensions are available. In the case of everything being okay, we don&rsquo;t have any data to return so we make the return type anyhow::Result&lt;()&gt;.</p>
<p>The first step within the function body is to enumerate all available extensions that the system supports. We also want to take these extensions, that are reported as raw pointers, and wrap them into a CStr for comparison. We then collect all the available extensions into a <strong>HashSet</strong> for quick checking:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> instance_extension_properties <span style="color:#f92672">=</span> entry.enumerate_instance_extension_properties(None)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> available_extensions <span style="color:#f92672">=</span> instance_extension_properties
</span></span><span style="display:flex;"><span>    .iter()
</span></span><span style="display:flex;"><span>    .map(<span style="color:#f92672">|</span>prop<span style="color:#f92672">|</span> CStr::from_ptr(prop.extension_name.as_ptr()))
</span></span><span style="display:flex;"><span>    .collect::<span style="color:#f92672">&lt;</span>HashSet<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;&gt;</span>();</span></span></code></pre></div>
<p>Secondly, we want to give the same treatment to the slice of extension names that was passed in as raw pointers:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> required_extensions <span style="color:#f92672">=</span> required_extensions
</span></span><span style="display:flex;"><span>    .iter()
</span></span><span style="display:flex;"><span>    .copied() <span style="color:#75715e">// .iter runs over &amp;*const i8 so copied will let us run over *const i8. This is the same as dereferencing in the map.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    .map(<span style="color:#f92672">|</span>ptr<span style="color:#f92672">|</span> CStr::from_ptr(ptr))
</span></span><span style="display:flex;"><span>    .collect::<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;&gt;</span>();</span></span></code></pre></div>
<p>We then iterate over all the required extensions provided, and check if they are available in the set of available extensions. If one is missing we can return early as an error, with a nicely formatted string telling us the name of the extension that failed:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> required_extension <span style="color:#66d9ef">in</span> required_extensions {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>available_extensions.contains(required_extension) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Err(anyhow::anyhow!(format!(
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;Required extension </span><span style="color:#e6db74">{}</span><span style="color:#e6db74"> is not available&#34;</span>,
</span></span><span style="display:flex;"><span>            required_extension.to_str()<span style="color:#f92672">?</span>
</span></span><span style="display:flex;"><span>        )));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h2 id="creating-the-instance-creation-info">Creating the instance creation info<a hidden class="anchor" aria-hidden="true" href="#creating-the-instance-creation-info">#</a></h2>
<p>Using ash&rsquo;s InstanceCreateInfoBuilder we now have enough information to create an instance. We&rsquo;ll go ahead and make the InstanceCreateInfoBuilder we&rsquo;ll use:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> instance_create_info <span style="color:#f92672">=</span> vk::InstanceCreateInfo::builder()
</span></span><span style="display:flex;"><span>    .application_info(<span style="color:#f92672">&amp;</span>application_info)
</span></span><span style="display:flex;"><span>    .enabled_extension_names(required_extensions);</span></span></code></pre></div>
<h2 id="creating-the-instance">Creating the instance<a hidden class="anchor" aria-hidden="true" href="#creating-the-instance">#</a></h2>
<p>Finally we can create the Vulkan instance!.</p>
<p>This is done in a single call, but it&rsquo;s unsafe because it&rsquo;s an FFI call. However, we&rsquo;ve verified that everything we&rsquo;re providing is configured correctly, so this is a valid call. We just need to wrap in an unsafe block:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">unsafe</span> { entry.create_instance(<span style="color:#f92672">&amp;</span>instance_create_info, None) }</span></span></code></pre></div>
<p>The &ldquo;None&rdquo; here is for custom allocation callbacks which can be used to hook in custom behaviour for objects being allocated, deallocated, etc. We won&rsquo;t be using this however so it can stay as None.</p>
<h1 id="selecting-a-physical-device">Selecting a physical device<a hidden class="anchor" aria-hidden="true" href="#selecting-a-physical-device">#</a></h1>
<p>After creating a Vulkan instance which specifies the capabilities of our Vulkan environment as a whole, we next need to select a physical device amongst those on our system that supports the capabilities we&rsquo;ll need for rendering.</p>
<p>Vulkan will give us information on all the Vulkan compatible physical devices (GPUs) on the system, and we can select which one we would like to use based on which is best for our application. Potentially even listing all devices that work for the user to select amongst themselves.</p>
<p>In order to get the available physical devices, we can use a method on the Vulkan instance. It will return an error if it can&rsquo;t retrieve the devices somehow so we&rsquo;ll propagate the error up the chain if we get it. The code looks as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> physical_devices <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { instance.enumerate_physical_devices() }<span style="color:#f92672">?</span>;</span></span></code></pre></div>
<p>The way we will interact with Vulkan will be by pushing commands onto <strong>queues</strong>, but different physical devices support different numbers and types of queues. These queues are groupes into <strong>queue families</strong> which are grouped by the capabilities of queues within that family.</p>
<p>The capabilities of a queue family are:</p>
<ul>
<li><strong>Graphics</strong>: This is the main queue capability we&rsquo;re interested in. Queues with this capability will be able to take rendering commands that will end up going through the pipeline and can render to a surface or buffer.</li>
<li><strong>Compute</strong>: Queue families with this capability will be able to take general computation commands to be processed in a compute shader for example.</li>
<li><strong>Transfer</strong>: Transfer queues can be used as dedicated pathways to transfer data quickly to and from the GPU.</li>
</ul>
<p>We can retrieve the queue family properties for a given PhysicalDevice with the following function call:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> queue_family_properties <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { instance.get_physical_device_queue_family_properties(device) };</span></span></code></pre></div>
<p>The queue family properties contains a bitmask with the capabilities of the family in a field called <strong>queue_flags</strong> that we can check supports the graphics bit with a bitmask. We also need to check that the queue family itself has at least 1 queue in it, which should be the case but we check anyway.</p>
<p>So, we get the list of queue family properties for the physical device, iterate it, find one that supports graphics operations, then&hellip;.we need to remember the index of that queue family in order to create the actual queues in the Vulkan device.</p>
<p>We actually only need 1 queue family in this case, but we&rsquo;ll still write the function to return a struct containing the indices we care about. It&rsquo;ll make it easy to add more family indices later without changing the function signature.</p>
<p>We&rsquo;ll store these in the following struct:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">QueueFamilyIndices</span> {
</span></span><span style="display:flex;"><span>    graphics_family: <span style="color:#66d9ef">u32</span>,
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>We&rsquo;ll bundle all of this up into a function to get the required indices from the physical device. It is fallible because the physical device may not have the required queue families, therefore needs to return an Option<!-- raw HTML omitted --> to indicate success or failure to find them. Full function looks as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_queue_family_indices</span>(
</span></span><span style="display:flex;"><span>    device: <span style="color:#a6e22e">vk</span>::PhysicalDevice,
</span></span><span style="display:flex;"><span>    instance: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Instance</span>,
</span></span><span style="display:flex;"><span>) -&gt; Option<span style="color:#f92672">&lt;</span>QueueFamilyIndices<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// # Safety
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// This is marked as unsafe because it&#39;s an FFI function, but the fact we have an Instance
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// indicates that we&#39;re calling it correctly.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> queue_family_properties <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsafe</span> { instance.get_physical_device_queue_family_properties(device) };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (idx, props) <span style="color:#66d9ef">in</span> queue_family_properties.into_iter().enumerate() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> props.queue_count <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> props.queue_flags.contains(vk::QueueFlags::<span style="color:#66d9ef">GRAPHICS</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> Some(QueueFamilyIndices {
</span></span><span style="display:flex;"><span>                graphics_family: <span style="color:#a6e22e">idx</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u32</span>,
</span></span><span style="display:flex;"><span>            });
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    None
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>In order to select a physical device, then, we simply need to iterate over all the available physical devices and we&rsquo;ll take the first one that has the capabilities we want. It&rsquo;s an error if no physical device on the system supports what we need though, so the function returns a Result. We need to return the PhysicalDevice that was selected, along with the queue family indices for the next step. Full physical device function looks as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_physical_device</span>(instance: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Instance</span>) -&gt; Result<span style="color:#f92672">&lt;</span>(vk::PhysicalDevice, QueueFamilyIndices)<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// # Safety
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// This is safe because the only way to get an instance is via the Ash API and we would&#39;ve
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// aborted earlier if one can&#39;t be made. The function itself is an FFI function which is why
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// it&#39;s marked unsafe but we&#39;re confident we&#39;re calling it correctly.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> physical_devices <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { instance.enumerate_physical_devices() }<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> physical_device <span style="color:#66d9ef">in</span> physical_devices {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(queue_family_indices) <span style="color:#f92672">=</span> get_queue_family_indices(physical_device, instance)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> Ok((physical_device, queue_family_indices));
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        Err(anyhow::anyhow!(<span style="color:#e6db74">&#34;Could not find a valid PhysicalDevice.&#34;</span>))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    .context(<span style="color:#e6db74">&#34;Error in get_physical_device.&#34;</span>)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h1 id="creating-the-vulkan-device">Creating the Vulkan device<a hidden class="anchor" aria-hidden="true" href="#creating-the-vulkan-device">#</a></h1>
<p>Now we&rsquo;ve selected a physical device to use, we want to actually instruct Vulkan to set up a logical device for us and tell it to allocate us some of the queues for our use.</p>
<p>The function to create a logical device will take as input the physical device, the Vulkan instance, and the queue family indices. Returning as output (if successful) the Device handle, along with handles to the queues that were created for us.</p>
<p>The function signature then looks as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">create_logical_device</span>(
</span></span><span style="display:flex;"><span>    instance: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Instance</span>,
</span></span><span style="display:flex;"><span>    physical_device: <span style="color:#a6e22e">vk</span>::PhysicalDevice,
</span></span><span style="display:flex;"><span>    queue_family_indices: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">QueueFamilyIndices</span>,
</span></span><span style="display:flex;"><span>) -&gt; Result<span style="color:#f92672">&lt;</span>(Device, QueueHandles)<span style="color:#f92672">&gt;</span></span></span></code></pre></div>
<p>The first step will be to create the device itself. For this, we need to specify the queue families we will be using along with how many queues we want to allocate for us. We don&rsquo;t actually specify this count as a number though, but as a slice of <strong>queue priorities</strong>.</p>
<p>Queue priorities are not guaranteed to be respected by the implementation but <em>may</em> be used as a hint to allocate more or less processing time to specific queues. We only have 1 queue so we&rsquo;ll just request a priority of 1.0.</p>
<p>Device creation can fail, so we need to propagate the Result if it does, the device creation code then looks as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> device <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>    instance.create_device(
</span></span><span style="display:flex;"><span>        physical_device,
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>vk::DeviceCreateInfo::builder().queue_create_infos(<span style="color:#f92672">&amp;</span>[
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">*</span>vk::DeviceQueueCreateInfo::builder()
</span></span><span style="display:flex;"><span>                .queue_family_index(queue_family_indices.graphics_family)
</span></span><span style="display:flex;"><span>                .queue_priorities(<span style="color:#f92672">&amp;</span>[<span style="color:#ae81ff">1.0</span>]),
</span></span><span style="display:flex;"><span>        ]),
</span></span><span style="display:flex;"><span>        None,
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>}<span style="color:#f92672">?</span>;</span></span></code></pre></div>
<p>After creating the device, Vulkan has allocated us the queues we requested but in order to submit commands to them, we&rsquo;re gonna need to grab their handles. We can do this by calling <strong>get_device_queue</strong> on the created Device, passing the queue family, and index of the queue we want to get the handle for. We&rsquo;ll stash these into a new struct:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">QueueHandles</span> {
</span></span><span style="display:flex;"><span>    graphics_queue: <span style="color:#a6e22e">vk</span>::Queue,
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>And the code to grab the handle and initialise the struct is as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> queues <span style="color:#f92672">=</span> QueueHandles {
</span></span><span style="display:flex;"><span>    _graphics_queue: <span style="color:#a6e22e">unsafe</span> {
</span></span><span style="display:flex;"><span>        device.get_device_queue(queue_family_indices.graphics_family, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<h1 id="running-the-event-loop">Running the event loop<a hidden class="anchor" aria-hidden="true" href="#running-the-event-loop">#</a></h1>
<p>We&rsquo;ve not constructed the Vulkan instance and device, we want to now keep the window and application open until quitting the application is requested. This will be dependant on the windowing library in use, but for winit we do this by calling <strong>run_return</strong> on the EventLoop. This will keep the app running in the provided closure until termination is requested. It also returns the error code, so the entire run_event_loop function looks as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">run_event_loop</span>(<span style="color:#66d9ef">mut</span> event_loop: <span style="color:#a6e22e">EventLoop</span><span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span>, window: <span style="color:#a6e22e">Window</span>) -&gt; <span style="color:#66d9ef">i32</span> {
</span></span><span style="display:flex;"><span>    event_loop.run_return(<span style="color:#66d9ef">move</span> <span style="color:#f92672">|</span>event, _, control_flow<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>control_flow <span style="color:#f92672">=</span> ControlFlow::Wait;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> event {
</span></span><span style="display:flex;"><span>            Event::WindowEvent {
</span></span><span style="display:flex;"><span>                event: <span style="color:#a6e22e">WindowEvent</span>::CloseRequested,
</span></span><span style="display:flex;"><span>                window_id,
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">if</span> window_id <span style="color:#f92672">==</span> window.id() <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">*</span>control_flow <span style="color:#f92672">=</span> ControlFlow::Exit,
</span></span><span style="display:flex;"><span>            _ <span style="color:#f92672">=&gt;</span> (),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>This is stating that if we receive a &ldquo;CloseRequested&rdquo; windowing event, and the window id we&rsquo;re closing is ours, then set the control flow to ControlFlow::Exit which will cause winit to leave the run_return method and go back to caller</p>
<h1 id="cleaning-up">Cleaning up<a hidden class="anchor" aria-hidden="true" href="#cleaning-up">#</a></h1>
<p>In order to &ldquo;properly&rdquo; clean up as we&rsquo;re terminating the application, we should tell Vulkan to destroy the device and instance as we&rsquo;re done with it, which will let Vulkan use those queues and such for other applications.</p>
<p>We do that with the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">cleanup</span>(instance: <span style="color:#a6e22e">Instance</span>, device: <span style="color:#a6e22e">Device</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>        device.destroy_device(None);
</span></span><span style="display:flex;"><span>        instance.destroy_instance(None);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h1 id="putting-it-all-together">Putting it all together<a hidden class="anchor" aria-hidden="true" href="#putting-it-all-together">#</a></h1>
<p>For completion, the main function of our application looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> (event_loop, window) <span style="color:#f92672">=</span> create_event_loop_and_window()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> entry <span style="color:#f92672">=</span> Entry::linked();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> instance <span style="color:#f92672">=</span> create_vulkan_instance(<span style="color:#f92672">&amp;</span>entry, window.raw_display_handle())<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> (physical_device, queue_family_indices) <span style="color:#f92672">=</span> get_physical_device(<span style="color:#f92672">&amp;</span>instance)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> (logical_device, _queues) <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>            create_logical_device(<span style="color:#f92672">&amp;</span>instance, physical_device, <span style="color:#f92672">&amp;</span>queue_family_indices)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> error_code <span style="color:#f92672">=</span> run_event_loop(event_loop, window);
</span></span><span style="display:flex;"><span>        cleanup(instance, logical_device);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> error_code <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            Ok(())
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            Err(anyhow::anyhow!(format!(
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;Application exited with error code </span><span style="color:#e6db74">{error_code}</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>            )))
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    .context(<span style="color:#e6db74">&#34;Error in main.&#34;</span>)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="http://localhost:1313/">Robin Smith</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body>

</html>
