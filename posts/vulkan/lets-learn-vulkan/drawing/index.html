<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>9. Drawing | Robin Firth</title>
<meta name="keywords" content="" />
<meta name="description" content="We can finally start drawing on the screen now that we&rsquo;ve got our framebuffers and recorded our command buffers. In order to render to the screen we will have to acquire an image from the swapchain, submit our command buffer that we recorded to the graphics queue, and then submit the image for presentation on the presentation queue. We will also however need to worry about synchronization.
Semaphores &amp; Fences There are two kinds of synchronization primitives in Vulkan which are">
<meta name="author" content="">
<link rel="canonical" href="https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/drawing/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.6f60056d44d3f7eb69a4bc6c332b59960f3a995802bded244750232f33713c49.css" integrity="sha256-b2AFbUTT9&#43;tppLxsMytZlg86mVgCve0kR1AjLzNxPEk=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js" integrity="sha256-uVus3DnjejMqn4g7Hni&#43;Srwf3KK8HyZB9V4809q9TWE="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://forgottenmaster.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://forgottenmaster.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://forgottenmaster.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://forgottenmaster.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://forgottenmaster.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.110.0">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta property="og:title" content="9. Drawing" />
<meta property="og:description" content="We can finally start drawing on the screen now that we&rsquo;ve got our framebuffers and recorded our command buffers. In order to render to the screen we will have to acquire an image from the swapchain, submit our command buffer that we recorded to the graphics queue, and then submit the image for presentation on the presentation queue. We will also however need to worry about synchronization.
Semaphores &amp; Fences There are two kinds of synchronization primitives in Vulkan which are" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/drawing/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-26T16:30:01&#43;00:00" />
<meta property="article:modified_time" content="2023-02-26T16:30:01&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="9. Drawing"/>
<meta name="twitter:description" content="We can finally start drawing on the screen now that we&rsquo;ve got our framebuffers and recorded our command buffers. In order to render to the screen we will have to acquire an image from the swapchain, submit our command buffer that we recorded to the graphics queue, and then submit the image for presentation on the presentation queue. We will also however need to worry about synchronization.
Semaphores &amp; Fences There are two kinds of synchronization primitives in Vulkan which are"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://forgottenmaster.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Vulkan",
      "item": "https://forgottenmaster.github.io/posts/vulkan/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Let's Learn Vulkan",
      "item": "https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "9. Drawing",
      "item": "https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/drawing/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "9. Drawing",
  "name": "9. Drawing",
  "description": "We can finally start drawing on the screen now that we\u0026rsquo;ve got our framebuffers and recorded our command buffers. In order to render to the screen we will have to acquire an image from the swapchain, submit our command buffer that we recorded to the graphics queue, and then submit the image for presentation on the presentation queue. We will also however need to worry about synchronization.\nSemaphores \u0026amp; Fences There are two kinds of synchronization primitives in Vulkan which are",
  "keywords": [
    
  ],
  "articleBody": "We can finally start drawing on the screen now that we’ve got our framebuffers and recorded our command buffers. In order to render to the screen we will have to acquire an image from the swapchain, submit our command buffer that we recorded to the graphics queue, and then submit the image for presentation on the presentation queue. We will also however need to worry about synchronization.\nSemaphores \u0026 Fences There are two kinds of synchronization primitives in Vulkan which are\nSemaphores: Synchronize one GPU action with another GPU action. These are reset automatically by the GPU Fences: Synchronize the CPU with a GPU action by blocking. We can wait for a fence to be signalled, and then have to manually reset it For our drawing, we will use 2 semaphores and 1 fence with the following semantics\nSemaphore 1: Will be used to sequence the playback of the command buffer so it only occurs after the image is ready in the swapchain Semaphore 2: Will be used to ensure that we don’t present the image for display until after the command buffer is finished being processed Fence: Will be used to ensure we don’t push more frames onto the queue than we support. Specifically, we don’t want to re-use images when they’re still in use by the GPU Creating our semaphores and fences in Vulkan is super easy. We do need to use creation and destruction functions and pass some creation info but they hardly require any setup.\nWe’ll make a single function to handle semaphores and fences, with the following signature\nfn create_synchronization( device: \u0026Device, amount: usize, ) -\u003e Result\u003c(Vec\u003cSemaphore\u003e, Vec\u003cSemaphore\u003e, Vec\u003cFence\u003e)\u003e We require the logical device to be able to create N semaphores and fences, along with the amount to create, and then we simply return a tuple containing:\nThe semaphores to be used for the image being made available The semaphores to be used for the command buffer having finished being processed The fences to be used to allow the CPU to wait on a particular command buffer having been processed Note that Vulkan doesn’t guarantee that creation of these semaphores or fences is actually successful, so we need to return a Result to indicate that an error has occurred.\nWe’ll first go ahead and make the builders for these create infos. The semaphore builder will be straightforward as there is nothing to configure.\nFor the fences, Vulkan will initially create them in an unsignaled state. However, in our case, we want them to start off signaled so that waiting on them will pass immediately the first time.\nIn order to do this we can pass a flag to the fence creation via the SIGNALED bit\nlet semaphore_builder = SemaphoreCreateInfo::builder(); let fence_builder = FenceCreateInfo::builder().flags(FenceCreateFlags::SIGNALED); For the actual creation we can only make a single semaphore or fence at a time with Vulkan unfortunately, so we need to iterate from 0 to N, creating a semaphore/fence each time.\nThis results in an iterator over results, which can then be collected into a result of a vec. Therefore this looks as follows\nlet image_available_semaphores = (0..amount) .map(|_| unsafe { device .create_semaphore(\u0026semaphore_builder, None) .context(\"Failed to create an image available semaphore.\") }) .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?; let queue_submit_complete_semaphores = (0..amount) .map(|_| unsafe { device .create_semaphore(\u0026semaphore_builder, None) .context(\"Failed to create a queue submit complete semaphore.\") }) .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?; let queue_submit_complete_fences = (0..amount) .map(|_| unsafe { device .create_fence(\u0026fence_builder, None) .context(\"Failed to create a queue submit complete fence.\") }) .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?; Finally we can go ahead and return these in a tuple if all were created successfully\nOk(( image_available_semaphores, queue_submit_complete_semaphores, queue_submit_complete_fences, )) We’ll have to remember to destroy these during cleanup too!\nPassing Data to the Draw Function Next we need to make sure that the main function passes along all the required data to the new draw function we’ll make. In order to do this though, it first needs to be passed along to the run_event_loop function.\nWe update the signature to add all the additional parameters we need\nfn run_event_loop( mut event_loop: EventLoop\u003c()\u003e, window: Window, device: \u0026Device, swapchain: SwapchainKHR, image_available_semaphores: \u0026[Semaphore], queue_submit_complete_semaphores: \u0026[Semaphore], queue_submit_complete_fences: \u0026[Fence], swapchain_ext: \u0026Swapchain, graphics_queue: Queue, present_queue: Queue, command_buffers: \u0026[CommandBuffer], ) -\u003e i32 The main job of the run_event_loop will be to cycle through the semaphores/fences to ensure that not too many frames are in flight at once.\nIn order to do this we start off at frame number 0, and the maximum frame count/index we can have is limited by the number of entries in the semaphores (or fences) lists.\nTherefore we can just take the length of the image_available_semaphores slice to figure out how many frames we can have in flight at a time.\nlet mut current_frame = 0; let max_frames = image_available_semaphores.len(); We essentially want to call draw each frame, with the current frame number. Then after drawing we want to update the current frame number to the next one, wrapping around when we reach max_frames.\nThe call to draw, and the current_frame update looks as follows\ndraw( device, swapchain, image_available_semaphores[current_frame], queue_submit_complete_semaphores[current_frame], queue_submit_complete_fences[current_frame], swapchain_ext, graphics_queue, present_queue, command_buffers, ) .unwrap(); current_frame = (current_frame + 1) % max_frames; How do we ensure we do this every frame, or as fast as possible at least?. Winit actually provides a handy event type that we can hook into called MainEventsCleared so we put our logic in there.\nDrawing Finally we can implement our draw function body and get something shown on screen!\nEach frame/draw function call, we follow the following sequence\nRender Loop\rIntel\nOn the Fence The very first thing that we need to do is to ensure that the command buffer we will be submitting to the queue for processing isn’t still being processed from a previous frame.\nWe don’t want a backlog of work being submitted, since doing so would cause memory to just keep increasing so we can use the fence to let the CPU wait until the appropriate frame is finished being processed.\nVisually, this can be represented with the following timeline diagram\nFence\rIntel\nCode-wise, we can use a Vulkan function to cause the CPU to block while waiting for a fence to be signaled via the GPU. Vulkan allows us to wait on multiple fences at a time so the invocation takes a slice\ndevice .wait_for_fences(\u0026[queue_submit_complete_fence], true, u64::MAX) .context(\"Failed to wait for fence while drawing image.\")?; Parameters to the wait_for_fences function are\nThe slice containing the fences we’re waiting for Whether we are waiting for all the fences to be signaled. If this is false, this function only blocks the CPU until one has been signaled. A timeout to block the CPU for. In our case we just want to block for however long it takes. After having been signaled, we need to reset the fence manually for them to be re-usable next time\ndevice .reset_fences(\u0026[queue_submit_complete_fence]) .context(\"Failed to reset fence while drawing image.\")?; Acquiring an Image The first step of our sequence, now that we’re cleared to continue by the fence, is to acquire the next available image from the swapchain.\nWe can do this with the acquire_next_image function of the swapchain extension, and it will provide us the index of the image that we should use immediately.\nHowever, we can’t actually use the image until it’s stopped being used potentially from a previous frame. In order to sequence the command buffer execution until after the image is available, we’ll use the image_available_semaphore.\nNote that we are able to pass a fence through to this method so that we can block the CPU if needed until the image is acquired. However, blocking the CPU is heavy-handed in this case, so we just pass a null handle for the fence.\nlet (image_index, _) = swapchain_ext .acquire_next_image( swapchain, u64::MAX, image_available_semaphore, Fence::null(), ) .context(\"Failed to acquire next image while drawing.\")?; Again, we set a timeout of u64::MAX since we want to block at least until Vulkan is able to tell us which image to use.\nSubmitting Command Buffer Once we’ve acquired the image index we’ll use, we need to submit the command buffer associated with that swapchain image to the graphics queue.\nHowever this requires a lot of setup for synchronization purposes to make sure Vulkan respects the correct dependencies as it processes the commands we give it.\nIn particular, to submit to a queue we need:\nA list of the semaphores that need to be triggered before this command buffer can start being processed. A list of pipeline stages that we need to wait for before this command buffer can be processed. A list of the command buffers that will be processed. A list of semaphores that will be triggered/signaled when the command buffers have all finished being processing. These lists will be as follows\nlet wait_semaphores = [image_available_semaphore]; let wait_dst_stages = [PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT]; let command_buffers = [command_buffers[image_index as usize]]; let signal_semaphores = [queue_submit_complete_semaphore]; The queue submission command can submit multiple things at once, so we will make an array but we only need a single submit info with the above\nlet submit_infos = [*SubmitInfo::builder() .wait_semaphores(\u0026wait_semaphores) .wait_dst_stage_mask(\u0026wait_dst_stages) .command_buffers(\u0026command_buffers) .signal_semaphores(\u0026signal_semaphores)]; Finally we can just go ahead and submit to the queue. We will submit to the graphics queue, and, equally importantly, we need to pass the fence through so that if the CPU spins around to this frame index again, they don’t end up sending the same command buffer again while it’s still being processed.\ndevice .queue_submit(graphics_queue, \u0026submit_infos, queue_submit_complete_fence) .context(\"Error while submitting command buffer to he queue during rendering.\")?; Presentation The last step of the sequence after acquiring an image, and rendering to that image, is to present that image to be displayed.\nTo do this we need\nA list of semaphores that the GPU needs signaled before proceeding to present A list of swapchains to present to A list of image indices on those swapchains to present In our case we have only one of each again, so the code looks as follows\nlet wait_semaphores = [queue_submit_complete_semaphore]; let swapchains = [swapchain]; let image_indices = [image_index]; Then we submit to the queue!\nswapchain_ext .queue_present( present_queue, \u0026PresentInfoKHR::builder() .wait_semaphores(\u0026wait_semaphores) .swapchains(\u0026swapchains) .image_indices(\u0026image_indices), ) .context(\"Error while presenting image to the swapchain.\")?; Vulkan will then ensure it waits for the command buffer to be finished processing (thanks to the semaphore), and then dutifully present the image to the screen for us.\nOutput Finally!, after 1000 lines of code, setting up every component of the pipeline required by Vulkan, we can go ahead and see the fruits of our labour!\nRunning our program we can see that avacado background we expect and a multicolored tria….wait, this doesn’t look right\nWe don’t see our triangle….do we now have to go through 1000 lines of code to find the issue?\nIn this case, the reason was pretty simple to track down. We have enabled back face culling, and our viewport is rendered flipped over, thus the triangle is being culled out!\nThis is due to the coordinate systems in OpenGL and Vulkan being inverted.\nOpenGL has the origin in the bottom left corner of the screen, and the y values going upwards toward the top of the screen, whereas Vulkan has the origin in the top left corner with the y axis running downwards.\nSince we have our coordinates baked into our vertex shader at the moment which is written in GLSL, we’re subject to OpenGL’s coordinate system unfortunately.\nThe difference can be illustrated with the following diagram\nCoordinate Systems\rSascha Willems\nAs detailed in the linked blog post, we can go ahead and flip our viewport over by specifying negative height to the viewport, causing it to grow upwards. However, due to the origin still being at the top left corner this would result in it being off-screen, thus we also need to offset the y position\nlet viewports = [Viewport { width: swapchain_extents.width as f32, height: -(swapchain_extents.height as f32), y: swapchain_extents.height as f32, max_depth: 1.0, ..Viewport::default() }]; Doing this change results in the front face of our triangle being correctly displayed and thus we can see that it’s now worked correctly!\n",
  "wordCount" : "1994",
  "inLanguage": "en",
  "datePublished": "2023-02-26T16:30:01Z",
  "dateModified": "2023-02-26T16:30:01Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/drawing/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Robin Firth",
    "logo": {
      "@type": "ImageObject",
      "url": "https://forgottenmaster.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://forgottenmaster.github.io/" accesskey="h" title="Robin Firth (Alt + H)">Robin Firth</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://forgottenmaster.github.io/resume/" title="Résumé">
                    <span>Résumé</span>
                </a>
            </li>
            <li>
                <a href="https://forgottenmaster.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://forgottenmaster.github.io/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://forgottenmaster.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/vulkan/">Vulkan</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/">Let&#39;s Learn Vulkan</a></div>
    <h1 class="post-title">
      9. Drawing
    </h1>
    <div class="post-meta"><span title='2023-02-26 16:30:01 +0000 UTC'>February 26, 2023</span>&nbsp;·&nbsp;10 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#semaphores--fences" aria-label="Semaphores &amp;amp; Fences">Semaphores &amp; Fences</a></li>
                <li>
                    <a href="#passing-data-to-the-draw-function" aria-label="Passing Data to the Draw Function">Passing Data to the Draw Function</a></li>
                <li>
                    <a href="#drawing" aria-label="Drawing">Drawing</a><ul>
                        
                <li>
                    <a href="#on-the-fence" aria-label="On the Fence">On the Fence</a></li>
                <li>
                    <a href="#acquiring-an-image" aria-label="Acquiring an Image">Acquiring an Image</a></li>
                <li>
                    <a href="#submitting-command-buffer" aria-label="Submitting Command Buffer">Submitting Command Buffer</a></li>
                <li>
                    <a href="#presentation" aria-label="Presentation">Presentation</a></li></ul>
                </li>
                <li>
                    <a href="#output" aria-label="Output">Output</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>We can finally start drawing on the screen now that we&rsquo;ve got our framebuffers and recorded our command buffers. In order to render to the screen we will have to acquire an image from the swapchain, submit our command buffer that we recorded to the graphics queue, and then submit the image for presentation on the presentation queue. We will also however need to worry about <strong>synchronization</strong>.</p>
<h1 id="semaphores--fences">Semaphores &amp; Fences<a hidden class="anchor" aria-hidden="true" href="#semaphores--fences">#</a></h1>
<p>There are two kinds of synchronization primitives in Vulkan which are</p>
<ul>
<li><strong>Semaphores</strong>: Synchronize one GPU action with another GPU action. These are reset automatically by the GPU</li>
<li><strong>Fences</strong>: Synchronize the CPU with a GPU action by blocking. We can wait for a fence to be signalled, and then have to manually reset it</li>
</ul>
<p>For our drawing, we will use 2 semaphores and 1 fence with the following semantics</p>
<ul>
<li><strong>Semaphore 1</strong>: Will be used to sequence the playback of the command buffer so it only occurs after the image is ready in the swapchain</li>
<li><strong>Semaphore 2</strong>: Will be used to ensure that we don&rsquo;t present the image for display until after the command buffer is finished being processed</li>
<li><strong>Fence</strong>: Will be used to ensure we don&rsquo;t push more frames onto the queue than we support. Specifically, we don&rsquo;t want to re-use images when they&rsquo;re still in use by the GPU</li>
</ul>
<p>Creating our semaphores and fences in Vulkan is super easy. We do need to use creation and destruction functions and pass some creation info but they hardly require any setup.</p>
<p>We&rsquo;ll make a single function to handle semaphores and fences, with the following signature</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">create_synchronization</span>(
</span></span><span style="display:flex;"><span>    device: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Device</span>,
</span></span><span style="display:flex;"><span>    amount: <span style="color:#66d9ef">usize</span>,
</span></span><span style="display:flex;"><span>) -&gt; Result<span style="color:#f92672">&lt;</span>(Vec<span style="color:#f92672">&lt;</span>Semaphore<span style="color:#f92672">&gt;</span>, Vec<span style="color:#f92672">&lt;</span>Semaphore<span style="color:#f92672">&gt;</span>, Vec<span style="color:#f92672">&lt;</span>Fence<span style="color:#f92672">&gt;</span>)<span style="color:#f92672">&gt;</span></span></span></code></pre></div>
<p>We require the logical device to be able to create N semaphores and fences, along with the amount to create, and then we simply return a tuple containing:</p>
<ol>
<li>The semaphores to be used for the image being made available</li>
<li>The semaphores to be used for the command buffer having finished being processed</li>
<li>The fences to be used to allow the CPU to wait on a particular command buffer having been processed</li>
</ol>
<p>Note that Vulkan doesn&rsquo;t guarantee that creation of these semaphores or fences is actually successful, so we need to return a Result to indicate that an error has occurred.</p>
<p>We&rsquo;ll first go ahead and make the builders for these create infos. The semaphore builder will be straightforward as there is nothing to configure.</p>
<p>For the fences, Vulkan will initially create them in an <strong>unsignaled</strong> state. However, in our case, we want them to start off <strong>signaled</strong> so that waiting on them will pass immediately the first time.</p>
<p>In order to do this we can pass a flag to the fence creation via the SIGNALED bit</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> semaphore_builder <span style="color:#f92672">=</span> SemaphoreCreateInfo::builder();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> fence_builder <span style="color:#f92672">=</span> FenceCreateInfo::builder().flags(FenceCreateFlags::SIGNALED);</span></span></code></pre></div>
<p>For the actual creation we can only make a single semaphore or fence at a time with Vulkan unfortunately, so we need to iterate from 0 to N, creating a semaphore/fence each time.</p>
<p>This results in an iterator over results, which can then be collected into a result of a vec. Therefore this looks as follows</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> image_available_semaphores <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>amount)
</span></span><span style="display:flex;"><span>    .map(<span style="color:#f92672">|</span>_<span style="color:#f92672">|</span> <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>        device
</span></span><span style="display:flex;"><span>            .create_semaphore(<span style="color:#f92672">&amp;</span>semaphore_builder, None)
</span></span><span style="display:flex;"><span>            .context(<span style="color:#e6db74">&#34;Failed to create an image available semaphore.&#34;</span>)
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    .collect::<span style="color:#f92672">&lt;</span>Result<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;&gt;&gt;</span>()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> queue_submit_complete_semaphores <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>amount)
</span></span><span style="display:flex;"><span>    .map(<span style="color:#f92672">|</span>_<span style="color:#f92672">|</span> <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>        device
</span></span><span style="display:flex;"><span>            .create_semaphore(<span style="color:#f92672">&amp;</span>semaphore_builder, None)
</span></span><span style="display:flex;"><span>            .context(<span style="color:#e6db74">&#34;Failed to create a queue submit complete semaphore.&#34;</span>)
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    .collect::<span style="color:#f92672">&lt;</span>Result<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;&gt;&gt;</span>()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> queue_submit_complete_fences <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>amount)
</span></span><span style="display:flex;"><span>    .map(<span style="color:#f92672">|</span>_<span style="color:#f92672">|</span> <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>        device
</span></span><span style="display:flex;"><span>            .create_fence(<span style="color:#f92672">&amp;</span>fence_builder, None)
</span></span><span style="display:flex;"><span>            .context(<span style="color:#e6db74">&#34;Failed to create a queue submit complete fence.&#34;</span>)
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    .collect::<span style="color:#f92672">&lt;</span>Result<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;&gt;&gt;</span>()<span style="color:#f92672">?</span>;</span></span></code></pre></div>
<p>Finally we can go ahead and return these in a tuple if all were created successfully</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>Ok((
</span></span><span style="display:flex;"><span>    image_available_semaphores,
</span></span><span style="display:flex;"><span>    queue_submit_complete_semaphores,
</span></span><span style="display:flex;"><span>    queue_submit_complete_fences,
</span></span><span style="display:flex;"><span>))</span></span></code></pre></div>
<p>We&rsquo;ll have to remember to destroy these during cleanup too!</p>
<h1 id="passing-data-to-the-draw-function">Passing Data to the Draw Function<a hidden class="anchor" aria-hidden="true" href="#passing-data-to-the-draw-function">#</a></h1>
<p>Next we need to make sure that the main function passes along all the required data to the new draw function we&rsquo;ll make. In order to do this though, it first needs to be passed along to the run_event_loop function.</p>
<p>We update the signature to add all the additional parameters we need</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">run_event_loop</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">mut</span> event_loop: <span style="color:#a6e22e">EventLoop</span><span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    window: <span style="color:#a6e22e">Window</span>,
</span></span><span style="display:flex;"><span>    device: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Device</span>,
</span></span><span style="display:flex;"><span>    swapchain: <span style="color:#a6e22e">SwapchainKHR</span>,
</span></span><span style="display:flex;"><span>    image_available_semaphores: <span style="color:#66d9ef">&amp;</span>[Semaphore],
</span></span><span style="display:flex;"><span>    queue_submit_complete_semaphores: <span style="color:#66d9ef">&amp;</span>[Semaphore],
</span></span><span style="display:flex;"><span>    queue_submit_complete_fences: <span style="color:#66d9ef">&amp;</span>[Fence],
</span></span><span style="display:flex;"><span>    swapchain_ext: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Swapchain</span>,
</span></span><span style="display:flex;"><span>    graphics_queue: <span style="color:#a6e22e">Queue</span>,
</span></span><span style="display:flex;"><span>    present_queue: <span style="color:#a6e22e">Queue</span>,
</span></span><span style="display:flex;"><span>    command_buffers: <span style="color:#66d9ef">&amp;</span>[CommandBuffer],
</span></span><span style="display:flex;"><span>) -&gt; <span style="color:#66d9ef">i32</span></span></span></code></pre></div>
<p>The main job of the run_event_loop will be to cycle through the semaphores/fences to ensure that not too many frames are in flight at once.</p>
<p>In order to do this we start off at frame number 0, and the maximum frame count/index we can have is limited by the number of entries in the semaphores (or fences) lists.</p>
<p>Therefore we can just take the length of the image_available_semaphores slice to figure out how many frames we can have in flight at a time.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> current_frame <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> max_frames <span style="color:#f92672">=</span> image_available_semaphores.len();</span></span></code></pre></div>
<p>We essentially want to call draw each frame, with the current frame number. Then after drawing we want to update the current frame number to the next one, wrapping around when we reach max_frames.</p>
<p>The call to draw, and the current_frame update looks as follows</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>draw(
</span></span><span style="display:flex;"><span>    device,
</span></span><span style="display:flex;"><span>    swapchain,
</span></span><span style="display:flex;"><span>    image_available_semaphores[current_frame],
</span></span><span style="display:flex;"><span>    queue_submit_complete_semaphores[current_frame],
</span></span><span style="display:flex;"><span>    queue_submit_complete_fences[current_frame],
</span></span><span style="display:flex;"><span>    swapchain_ext,
</span></span><span style="display:flex;"><span>    graphics_queue,
</span></span><span style="display:flex;"><span>    present_queue,
</span></span><span style="display:flex;"><span>    command_buffers,
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>.unwrap();
</span></span><span style="display:flex;"><span>current_frame <span style="color:#f92672">=</span> (current_frame <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> max_frames;</span></span></code></pre></div>
<p>How do we ensure we do this every frame, or as fast as possible at least?. Winit actually provides a handy event type that we can hook into called <strong>MainEventsCleared</strong> so we put our logic in there.</p>
<h1 id="drawing">Drawing<a hidden class="anchor" aria-hidden="true" href="#drawing">#</a></h1>
<p>Finally we can implement our draw function body and get something shown on screen!</p>
<p>Each frame/draw function call, we follow the following sequence</p>
<figure class="align-center ">
    <img loading="lazy" src="render-loop.png#center"/> <figcaption>
            Render Loop<p>
                    <a href="https://www.intel.com/content/www/us/en/developer/articles/training/practical-approach-to-vulkan-part-1.html">Intel</a></p>
        </figcaption>
</figure>

<h2 id="on-the-fence">On the Fence<a hidden class="anchor" aria-hidden="true" href="#on-the-fence">#</a></h2>
<p>The <strong>very</strong> first thing that we need to do is to ensure that the command buffer we will be submitting to the queue for processing isn&rsquo;t still being processed from a previous frame.</p>
<p>We don&rsquo;t want a backlog of work being submitted, since doing so would cause memory to just keep increasing so we can use the fence to let the CPU wait until the appropriate frame is finished being processed.</p>
<p>Visually, this can be represented with the following timeline diagram</p>
<figure class="align-center ">
    <img loading="lazy" src="fence.png#center"/> <figcaption>
            Fence<p>
                    <a href="https://www.intel.com/content/www/us/en/developer/articles/training/practical-approach-to-vulkan-part-1.html">Intel</a></p>
        </figcaption>
</figure>

<p>Code-wise, we can use a Vulkan function to cause the CPU to block while waiting for a fence to be signaled via the GPU. Vulkan allows us to wait on multiple fences at a time so the invocation takes a slice</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>device
</span></span><span style="display:flex;"><span>    .wait_for_fences(<span style="color:#f92672">&amp;</span>[queue_submit_complete_fence], <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">u64</span>::MAX)
</span></span><span style="display:flex;"><span>    .context(<span style="color:#e6db74">&#34;Failed to wait for fence while drawing image.&#34;</span>)<span style="color:#f92672">?</span>;</span></span></code></pre></div>
<p>Parameters to the wait_for_fences function are</p>
<ol>
<li>The slice containing the fences we&rsquo;re waiting for</li>
<li>Whether we are waiting for <strong>all</strong> the fences to be signaled. If this is false, this function only blocks the CPU until <strong>one</strong> has been signaled.</li>
<li>A timeout to block the CPU for. In our case we just want to block for however long it takes.</li>
</ol>
<p>After having been signaled, we need to reset the fence manually for them to be re-usable next time</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>device
</span></span><span style="display:flex;"><span>    .reset_fences(<span style="color:#f92672">&amp;</span>[queue_submit_complete_fence])
</span></span><span style="display:flex;"><span>    .context(<span style="color:#e6db74">&#34;Failed to reset fence while drawing image.&#34;</span>)<span style="color:#f92672">?</span>;</span></span></code></pre></div>
<h2 id="acquiring-an-image">Acquiring an Image<a hidden class="anchor" aria-hidden="true" href="#acquiring-an-image">#</a></h2>
<p>The first step of our sequence, now that we&rsquo;re cleared to continue by the fence, is to acquire the next available image from the swapchain.</p>
<p>We can do this with the acquire_next_image function of the swapchain extension, and it will provide us the index of the image that we should use immediately.</p>
<p>However, we can&rsquo;t actually <em>use</em> the image until it&rsquo;s stopped being used potentially from a previous frame. In order to sequence the command buffer execution until after the image is available, we&rsquo;ll use the image_available_semaphore.</p>
<p>Note that we are able to pass a fence through to this method so that we can block the CPU if needed until the image is acquired. However, blocking the CPU is heavy-handed in this case, so we just pass a null handle for the fence.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> (image_index, _) <span style="color:#f92672">=</span> swapchain_ext
</span></span><span style="display:flex;"><span>    .acquire_next_image(
</span></span><span style="display:flex;"><span>        swapchain,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">u64</span>::MAX,
</span></span><span style="display:flex;"><span>        image_available_semaphore,
</span></span><span style="display:flex;"><span>        Fence::null(),
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    .context(<span style="color:#e6db74">&#34;Failed to acquire next image while drawing.&#34;</span>)<span style="color:#f92672">?</span>;</span></span></code></pre></div>
<p>Again, we set a timeout of u64::MAX since we want to block at least until Vulkan is able to tell us which image to use.</p>
<h2 id="submitting-command-buffer">Submitting Command Buffer<a hidden class="anchor" aria-hidden="true" href="#submitting-command-buffer">#</a></h2>
<p>Once we&rsquo;ve acquired the image index we&rsquo;ll use, we need to submit the command buffer associated with that swapchain image to the graphics queue.</p>
<p>However this requires a lot of setup for synchronization purposes to make sure Vulkan respects the correct dependencies as it processes the commands we give it.</p>
<p>In particular, to submit to a queue we need:</p>
<ol>
<li>A list of the semaphores that need to be triggered before this command buffer can start being processed.</li>
<li>A list of pipeline stages that we need to wait for before this command buffer can be processed.</li>
<li>A list of the command buffers that will be processed.</li>
<li>A list of semaphores that will be triggered/signaled when the command buffers have all finished being processing.</li>
</ol>
<p>These lists will be as follows</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> wait_semaphores <span style="color:#f92672">=</span> [image_available_semaphore];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> wait_dst_stages <span style="color:#f92672">=</span> [PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> command_buffers <span style="color:#f92672">=</span> [command_buffers[image_index <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>]];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> signal_semaphores <span style="color:#f92672">=</span> [queue_submit_complete_semaphore];</span></span></code></pre></div>
<p>The queue submission command can submit multiple things at once, so we will make an array but we only need a single submit info with the above</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> submit_infos <span style="color:#f92672">=</span> [<span style="color:#f92672">*</span>SubmitInfo::builder()
</span></span><span style="display:flex;"><span>    .wait_semaphores(<span style="color:#f92672">&amp;</span>wait_semaphores)
</span></span><span style="display:flex;"><span>    .wait_dst_stage_mask(<span style="color:#f92672">&amp;</span>wait_dst_stages)
</span></span><span style="display:flex;"><span>    .command_buffers(<span style="color:#f92672">&amp;</span>command_buffers)
</span></span><span style="display:flex;"><span>    .signal_semaphores(<span style="color:#f92672">&amp;</span>signal_semaphores)];</span></span></code></pre></div>
<p>Finally we can just go ahead and submit to the queue. We will submit to the <strong>graphics</strong> queue, and, equally importantly, we need to pass the fence through so that if the CPU spins around to this frame index again, they don&rsquo;t end up sending the same command buffer again while it&rsquo;s still being processed.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>device
</span></span><span style="display:flex;"><span>    .queue_submit(graphics_queue, <span style="color:#f92672">&amp;</span>submit_infos, queue_submit_complete_fence)
</span></span><span style="display:flex;"><span>    .context(<span style="color:#e6db74">&#34;Error while submitting command buffer to he queue during rendering.&#34;</span>)<span style="color:#f92672">?</span>;</span></span></code></pre></div>
<h2 id="presentation">Presentation<a hidden class="anchor" aria-hidden="true" href="#presentation">#</a></h2>
<p>The last step of the sequence after acquiring an image, and rendering to that image, is to present that image to be displayed.</p>
<p>To do this we need</p>
<ol>
<li>A list of semaphores that the GPU needs signaled before proceeding to present</li>
<li>A list of swapchains to present to</li>
<li>A list of image indices on those swapchains to present</li>
</ol>
<p>In our case we have only one of each again, so the code looks as follows</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> wait_semaphores <span style="color:#f92672">=</span> [queue_submit_complete_semaphore];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> swapchains <span style="color:#f92672">=</span> [swapchain];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> image_indices <span style="color:#f92672">=</span> [image_index];</span></span></code></pre></div>
<p>Then we submit to the queue!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>swapchain_ext
</span></span><span style="display:flex;"><span>    .queue_present(
</span></span><span style="display:flex;"><span>        present_queue,
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>PresentInfoKHR::builder()
</span></span><span style="display:flex;"><span>            .wait_semaphores(<span style="color:#f92672">&amp;</span>wait_semaphores)
</span></span><span style="display:flex;"><span>            .swapchains(<span style="color:#f92672">&amp;</span>swapchains)
</span></span><span style="display:flex;"><span>            .image_indices(<span style="color:#f92672">&amp;</span>image_indices),
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    .context(<span style="color:#e6db74">&#34;Error while presenting image to the swapchain.&#34;</span>)<span style="color:#f92672">?</span>;</span></span></code></pre></div>
<p>Vulkan will then ensure it waits for the command buffer to be finished processing (thanks to the semaphore), and then dutifully present the image to the screen for us.</p>
<h1 id="output">Output<a hidden class="anchor" aria-hidden="true" href="#output">#</a></h1>
<p>Finally!, after 1000 lines of code, setting up every component of the pipeline required by Vulkan, we can go ahead and see the fruits of our labour!</p>
<p>Running our program we can see that avacado background we expect and a multicolored tria&hellip;.wait, this doesn&rsquo;t look right</p>
<p><img loading="lazy" src="incorrect.png" alt="Incorrect Rendering"  />
</p>
<p>We don&rsquo;t see our triangle&hellip;.do we now have to go through 1000 lines of code to find the issue?</p>
<p>In this case, the reason was pretty simple to track down. We have enabled back face culling, and our viewport is rendered flipped over, thus the triangle is being culled out!</p>
<p>This is due to the coordinate systems in OpenGL and Vulkan being inverted.</p>
<p>OpenGL has the origin in the bottom left corner of the screen, and the y values going upwards toward the top of the screen, whereas Vulkan has the origin in the top left corner with the y axis running downwards.</p>
<p>Since we have our coordinates baked into our vertex shader at the moment which is written in GLSL, we&rsquo;re subject to OpenGL&rsquo;s coordinate system unfortunately.</p>
<p>The difference can be illustrated with the following diagram</p>
<figure class="align-center ">
    <img loading="lazy" src="coordinate-systems.png#center"/> <figcaption>
            Coordinate Systems<p>
                    <a href="https://www.saschawillems.de/blog/2019/03/29/flipping-the-vulkan-viewport/">Sascha Willems</a></p>
        </figcaption>
</figure>

<p>As detailed in the linked blog post, we can go ahead and flip our viewport over by specifying <strong>negative</strong> height to the viewport, causing it to grow <strong>upwards</strong>. However, due to the origin still being at the top left corner this would result in it being off-screen, thus we also need to offset the y position</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> viewports <span style="color:#f92672">=</span> [Viewport {
</span></span><span style="display:flex;"><span>    width: <span style="color:#a6e22e">swapchain_extents</span>.width <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f32</span>,
</span></span><span style="display:flex;"><span>    height: <span style="color:#f92672">-</span>(swapchain_extents.height <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f32</span>),
</span></span><span style="display:flex;"><span>    y: <span style="color:#a6e22e">swapchain_extents</span>.height <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f32</span>,
</span></span><span style="display:flex;"><span>    max_depth: <span style="color:#ae81ff">1.0</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">..</span>Viewport::default()
</span></span><span style="display:flex;"><span>}];</span></span></code></pre></div>
<p>Doing this change results in the front face of our triangle being correctly displayed and thus we can see that it&rsquo;s now worked correctly!</p>
<p><img loading="lazy" src="correct.png" alt="Correct Rendering"  />
</p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://forgottenmaster.github.io/">Robin Firth</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
