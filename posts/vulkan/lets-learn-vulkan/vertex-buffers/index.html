<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>10. Vertex Buffers | Robin Smith</title>
<meta name="keywords" content="">
<meta name="description" content="We now have a triangle rendering to the screen which proves that our setup is all correct and valid. However currently our vertex positions and colors are baked into our vertex shader.
The next step is to allow our application to define the vertex data to be passed into our graphics pipeline, which we can do with vertex buffers.
Vertex Data The first thing we want to do is to define how we will store our vertex data.">
<meta name="author" content="">
<link rel="canonical" href="https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/vertex-buffers/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://forgottenmaster.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://forgottenmaster.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://forgottenmaster.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://forgottenmaster.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://forgottenmaster.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/vertex-buffers/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="10. Vertex Buffers" />
<meta property="og:description" content="We now have a triangle rendering to the screen which proves that our setup is all correct and valid. However currently our vertex positions and colors are baked into our vertex shader.
The next step is to allow our application to define the vertex data to be passed into our graphics pipeline, which we can do with vertex buffers.
Vertex Data The first thing we want to do is to define how we will store our vertex data." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/vertex-buffers/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-01T17:26:02+00:00" />
<meta property="article:modified_time" content="2023-03-01T17:26:02+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="10. Vertex Buffers"/>
<meta name="twitter:description" content="We now have a triangle rendering to the screen which proves that our setup is all correct and valid. However currently our vertex positions and colors are baked into our vertex shader.
The next step is to allow our application to define the vertex data to be passed into our graphics pipeline, which we can do with vertex buffers.
Vertex Data The first thing we want to do is to define how we will store our vertex data."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://forgottenmaster.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Vulkan",
      "item": "https://forgottenmaster.github.io/posts/vulkan/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Let's Learn Vulkan",
      "item": "https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "10. Vertex Buffers",
      "item": "https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/vertex-buffers/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "10. Vertex Buffers",
  "name": "10. Vertex Buffers",
  "description": "We now have a triangle rendering to the screen which proves that our setup is all correct and valid. However currently our vertex positions and colors are baked into our vertex shader.\nThe next step is to allow our application to define the vertex data to be passed into our graphics pipeline, which we can do with vertex buffers.\nVertex Data The first thing we want to do is to define how we will store our vertex data.",
  "keywords": [
    
  ],
  "articleBody": "We now have a triangle rendering to the screen which proves that our setup is all correct and valid. However currently our vertex positions and colors are baked into our vertex shader.\nThe next step is to allow our application to define the vertex data to be passed into our graphics pipeline, which we can do with vertex buffers.\nVertex Data The first thing we want to do is to define how we will store our vertex data. Data for each vertex is stored bundled together and the vertex buffer will be an array of these structures tightly packed.\n#[repr(C)] struct Vertex { position: [f32; 3], // offset 0 color: [f32; 3], // offset 12 } We store a position and a color for each vertex, with each being an array of 3 elements, each of type f32. This matches up with the types we’ll define in our vertex shader.\nTagging the struct as repr(C) prevents Rust from re-ordering these fields, which Rust is usually allowed to do for optimisation purposes. We don’t want the position and color fields re-arranged because we rely on a particular layout in memory in order to be compatible with the vertex shader.\nVertex Shader Next, we need to update our vertex shader itself.\nPreviously, we had the arrays of positions and colors baked into the shader, and were using the gl_VertexID to index into those arrays. However we now replace those arrays with two in parameters in the Vertex shader\nlayout(location = 0) in vec3 position; layout(location = 1) in vec3 colour; Note that these need different location values, which will be indexes into the array of descriptors we will provide to our graphics pipeline shortly.\nWe can just go ahead and use these values directly in our shader. No gl_VertexID required!\nvoid main() { gl_Position = vec4(position, 1.0); fragColour = colour; } fragColour is our out parameter that will be passed along to the fragment shader as before.\nGraphics Pipeline Now that we’ve changed the app side to be able to represent this vertex data as an array of structs, and we’ve changed the vertex shader to define the data from those structs that it needs access to, we now need to tell the graphics pipeline how to map individual fields of the Vertex struct to the parameters of the shader.\nFirst of all, it would be helpful to visualise how these vertices are actually laid out in memory\nVertex Layout\rLearn OpenGL\nThis is how our vertices will be laid out in the buffer sequentially, but we need to tell the pipeline how to chunk this up, and how it knows the data for a single vertex.\nBindings Firstly though, there is the possibility to have multiple bindings which are completely separate data streams essentially. We defined our position for example in our vertex shader as\nlayout(location = 0) in vec3 position; But this is shorthand for using the default binding number of 0, so we could write this as\nlayout(binding = 0, location = 0) in vec3 position; We only have one stream of data (our vertex buffer) so we only need one binding. But this could be useful if we store positions and colors in separate buffers for example.\nIn order to define a binding, Vulkan needs to know the stride, and input rate of the data coming in.\nInput rate is either vertex or instance and defines the way in which the data is consumed from the buffers\nVertex identifies that the stride represents the size of an individual vertex, and each vertex will be pulled one at a time Instance identifies that the stride represents the total size of all an instances vertices In our case we just pick Vertex because of the way we define our stride.\nStride in our case, is simply the size of a Vertex struct instance. This is the number of bytes that Vulkan will skip forward by to get to the next vertex. As can be seen in the visual diagram above, the stride of a Vertex is the size of the position array plus the size of the color array. Both arrays are 12 bytes (3*4 byte floats) so the stride of the Vertex is 24.\nCoding this up, we can define an array of bindings, with a single binding (binding index 0)\nlet binding_descriptions = [*VertexInputBindingDescription::builder() .stride(mem::size_of::\u003cVertex\u003e().try_into().unwrap()) .input_rate(VertexInputRate::VERTEX)]; Attributes Now that we’ve defined our data streams and the strides within them, we now need to define how individual components within that stream are found, which shader locations they are bound to, and how they are interpreted.\nOnce again looking at the diagram above, we have\nPosition Binding: 0 Location: 0 Offset: 0 bytes Format: R32G32B32_SFLOAT (3-channel, 4-bytes-per-channel, signed float) Color Binding: 0 Location: 1 Offset: 12 bytes Format: R32G32B32_SFLOAT 0 is the default value for binding, location, and offset so we don’t have to mention it for the first attribute.\nCoding those attributes up we have\nlet attribute_descriptions = [ *VertexInputAttributeDescription::builder().format(Format::R32G32B32_SFLOAT), *VertexInputAttributeDescription::builder() .location(1) .format(Format::R32G32B32_SFLOAT) .offset(12), ]; Pipeline Now we can simply add these bindings and attributes to the pipeline by modifying the PipelineVertexInputStateCreateInfo\nlet vertex_input = PipelineVertexInputStateCreateInfo::builder() .vertex_binding_descriptions(\u0026binding_descriptions) .vertex_attribute_descriptions(\u0026attribute_descriptions); And the rest of the pipeline can stay the same.\nVertex Buffer Vulkan decouples the resources you’re using (buffers, images, etc.) from the actual memory allocated for those resources. This is so that the developer could allocate one large “slab” of memory and have it contain many resources using it as the following diagram indicates\nMemory Allocation\rVulkan Memory Management\nAlignment requirements as indicated in the image are resource specific so when we create a resource we are able to query from Vulkan what requirements on memory it has. As long as we provide memory that matches, Vulkan doesn’t care where it comes from.\nIdeally you would allocate a single allocation and use that for storing interleaved data with different offsets/strides as in the diagram below.\nOffsets\rVulkan Memory Management\nFor our use-case right now we’ll allocate a memory allocation for the vertex buffer only though. We’re only learning Vulkan so we can leave these “best practices” until later.\nFollowing are the steps involved in creating a Vulkan buffer, which we’ll follow to create a buffer for our vertex data.\nCreating the Buffer Resource Firstly, we need to tell Vulkan that we will be creating a buffer such that it can assign us an opaque handle to refer to that buffer. As mentioned above, there’s no memory connected to the buffer, we’re just telling Vulkan how the buffer will be used and what shape it has.\nCode is as follows\nlet buffer = unsafe { device .create_buffer( \u0026BufferCreateInfo::builder() .size((mem::size_of::\u003cVertex\u003e() * vertices.len()) as u64) .usage(BufferUsageFlags::VERTEX_BUFFER) .sharing_mode(SharingMode::EXCLUSIVE), None, ) .context(\"Failed to create a buffer.\")? }; There are 3 important arguments we’re giving to the BufferCreateInfo here\nThe size of the buffer (in bytes). This is the size of a single Vertex multiplied by the number of vertices. There’s no additional data to be stored so this is an easy calculation. The buffer usage. Vulkan doesn’t know what kind of buffer this is until we tell it, in this case we want a vertex buffer. The sharing mode. A buffer can either be exclusive to a queue family, or shared by multiple queue families much like when we created our image views (another resource). In our case we only use the buffer within the graphics queue family. Allocating Memory Vulkan gives us back an opaque Buffer handle after creation but we now need to allocate some memory for it.\nFirstly, Vulkan will only allow memory to be created from some memory types. We can access the memory properties that a Buffer requires by calling a simple function with the buffer handle\nlet memory_requirements = unsafe { device.get_buffer_memory_requirements(buffer) }; Now that we have the requirements, we need to know what is available on our physical device, which again is a simple call\nlet memory_properties = unsafe { instance.get_physical_device_memory_properties(physical_device) }; Now we need to locate a memory type from memory_properties which is supported for the created buffer. We’ll wrap this up into a function called find_valid_memory_type_index\nfn find_valid_memory_type_index( memory_properties: PhysicalDeviceMemoryProperties, memory_requirements: MemoryRequirements, flags: MemoryPropertyFlags, ) -\u003e Option\u003cusize\u003e We take in the memory_properties and memory_requirements we look up, but what’s this MemoryPropertyFlags we’re passing?.\nWell memory has other properties defining visibility to the CPU/GPU and we can specify what we would like. For our use case we use\nHost Visible - This means that the CPU can see the memory. It might not be located on the CPU, but could have special mapping so it’s visible to the CPU Host Coherent - This means that the memory doesn’t have any special caching so when we write to it, we don’t need to flush the cache for example The memory flags are easy to test - it’s a bitmask we can use to check against the memory type’s property_flags.\nThe memory requirements is also a bitset, but it’s a bitset where a bit set to 1 in the ith position (from the right hand side) means that the memory type at index i is valid.\nWe can therefore get an iterator over all the memory types, enumerate the iterator to get the index along with the type information, and then find the position of the first memory type that is supported, and matches our bitmask with the following code\nmemory_properties .memory_types .into_iter() .enumerate() .position(|(index, memory_type)| { (memory_requirements.memory_type_bits \u0026 (1 \u003c\u003c index as u32)) != 0 \u0026\u0026 memory_type.property_flags.contains(flags) }) After we find the index of a valid memory type, we can ask Vulkan to actually allocate the memory for us\nlet buffer_memory = unsafe { device .allocate_memory( \u0026MemoryAllocateInfo::builder() .allocation_size(memory_requirements.size) .memory_type_index(memory_type_index as u32), None, ) .context(\"Failed to allocate vertex buffer memory.\")? }; Note that we get the allocation size from memory_requirements.size rather than using the size we originally requested the buffer to have. This is because due to alignment or other requirements, Vulkan may end up requiring more bytes than we need for the buffer itself.\nFinally, we can bind the memory to the buffer. Vulkan lets us give an offset into the memory in case we’re using memory for multiple resources, but here we just say no offset\nunsafe { device .bind_buffer_memory(buffer, buffer_memory, 0) .context(\"Failed to bind the buffer memory to the vertex buffer.\")?; } Writing Vertex Data Finally we now have to get our Vertex data into the dedicated memory for the buffer to make it available and visible when we come to binding it to our shader.\nIn order to get a pointer through which we can write, we need to map the correct range of memory, Vulkan will then return us a pointer to write with\nlet write_ptr = unsafe { device .map_memory( buffer_memory, 0, memory_requirements.size, MemoryMapFlags::empty(), ) .context(\"Failed to map the buffer memory.\")? as *mut Vertex }; Again, we pass an offset of 0, and a size of memory_requirements.size because we just want to map the entire range.\nWe can now go ahead and copy our data into the provided mapped pointer, which in Rust we can do with the std::ptr::copy method which is like a memcpy in C\nunsafe { ptr::copy(vertices.as_ptr(), write_ptr, vertices.len()) }; And finally once we’re done writing to it, we unmap the memory which allows Vulkan to make use of it knowing we’re finished setting the memory\nunsafe { device.unmap_memory(buffer_memory) }; And with that, our vertex data is inside the newly allocated memory, and bound to the newly allocated Buffer handle!\nCleanup We also need to remember to clean this up on app shutdown. Specifically we need to free the memory, and destroy the buffer resource.\ndevice.free_memory(vertex_buffer_memory, None); device.destroy_buffer(vertex_buffer, None); Command Buffer The final thing we need to do is to update our code that is recording into the command buffer to set things up for the draw call.\nSpecifically we need two things:\nBind the vertex buffer(s) to make the data available for the draw call Pass the correct number of vertices into the draw call Firstly, there’s the binding. The command to bind the vertex buffer actually handles multiple so we can bind multiple at the same time.\nWe can also specify offsets to use in the buffers we provide, and the number of buffers we provide is going to determine the binding indices.\nIn our case we only bind one vertex buffer, with an offset of 0. We also tell Vulkan to start binding indices at 0, so the first vertex buffer has binding 0 and that matches up with what our shader expects.\ndevice.cmd_bind_vertex_buffers(*command_buffer, 0, \u0026[vertex_buffer], \u0026[0]); For the draw call we simply change from drawing 3 vertices to drawing however many we have in the list\ndevice.cmd_draw(*command_buffer, vertex_count.try_into().unwrap(), 1, 0, 0); Main Now we simply need to fill out our vertex buffer in main so it can be passed along as needed. The vertex data will look like this, moved from where we had it baked into the vertex shader.\nlet vertex_data = [ Vertex { position: [0.0, -0.4, 0.0], color: [1.0, 0.0, 0.0], }, Vertex { position: [0.4, 0.4, 0.0], color: [0.0, 1.0, 0.0], }, Vertex { position: [-0.4, 0.4, 0.0], color: [0.0, 0.0, 1.0], }, ]; Running the code to verify we have exactly the same output as before, we see that we do!\nNow lets try changing the vertex data to define a square, and check that the same shader can be used to render that too!\n",
  "wordCount" : "2234",
  "inLanguage": "en",
  "datePublished": "2023-03-01T17:26:02Z",
  "dateModified": "2023-03-01T17:26:02Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/vertex-buffers/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Robin Smith",
    "logo": {
      "@type": "ImageObject",
      "url": "https://forgottenmaster.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://forgottenmaster.github.io/" accesskey="h" title="Robin Smith (Alt + H)">Robin Smith</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://forgottenmaster.github.io/resume/" title="Résumé">
                    <span>Résumé</span>
                </a>
            </li>
            <li>
                <a href="https://forgottenmaster.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://forgottenmaster.github.io/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://forgottenmaster.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/vulkan/">Vulkan</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/">Let&#39;s Learn Vulkan</a></div>
    <h1 class="post-title entry-hint-parent">
      10. Vertex Buffers
    </h1>
    <div class="post-meta"><span title='2023-03-01 17:26:02 +0000 UTC'>March 1, 2023</span>&nbsp;·&nbsp;11 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#vertex-data" aria-label="Vertex Data">Vertex Data</a></li>
                <li>
                    <a href="#vertex-shader" aria-label="Vertex Shader">Vertex Shader</a></li>
                <li>
                    <a href="#graphics-pipeline" aria-label="Graphics Pipeline">Graphics Pipeline</a><ul>
                        
                <li>
                    <a href="#bindings" aria-label="Bindings">Bindings</a></li>
                <li>
                    <a href="#attributes" aria-label="Attributes">Attributes</a></li>
                <li>
                    <a href="#pipeline" aria-label="Pipeline">Pipeline</a></li></ul>
                </li>
                <li>
                    <a href="#vertex-buffer" aria-label="Vertex Buffer">Vertex Buffer</a><ul>
                        
                <li>
                    <a href="#creating-the-buffer-resource" aria-label="Creating the Buffer Resource">Creating the Buffer Resource</a></li>
                <li>
                    <a href="#allocating-memory" aria-label="Allocating Memory">Allocating Memory</a></li>
                <li>
                    <a href="#writing-vertex-data" aria-label="Writing Vertex Data">Writing Vertex Data</a></li>
                <li>
                    <a href="#cleanup" aria-label="Cleanup">Cleanup</a></li></ul>
                </li>
                <li>
                    <a href="#command-buffer" aria-label="Command Buffer">Command Buffer</a></li>
                <li>
                    <a href="#main" aria-label="Main">Main</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>We now have a triangle rendering to the screen which proves that our setup is all correct and valid. However currently our vertex positions and colors are baked into our vertex shader.</p>
<p>The next step is to allow our application to define the vertex data to be passed into our graphics pipeline, which we can do with <strong>vertex buffers</strong>.</p>
<h1 id="vertex-data">Vertex Data<a hidden class="anchor" aria-hidden="true" href="#vertex-data">#</a></h1>
<p>The first thing we want to do is to define how we will store our vertex data. Data for each vertex is stored bundled together and the vertex buffer will be an array of these structures tightly packed.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Vertex</span> {
</span></span><span style="display:flex;"><span>    position: [<span style="color:#66d9ef">f32</span>; <span style="color:#ae81ff">3</span>], <span style="color:#75715e">// offset 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    color: [<span style="color:#66d9ef">f32</span>; <span style="color:#ae81ff">3</span>],    <span style="color:#75715e">// offset 12
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}</span></span></code></pre></div>
<p>We store a position and a color for each vertex, with each being an array of 3 elements, each of type f32. This matches up with the types we&rsquo;ll define in our vertex shader.</p>
<p>Tagging the struct as repr(C) prevents Rust from re-ordering these fields, which Rust is usually allowed to do for optimisation purposes. We don&rsquo;t want the position and color fields re-arranged because we rely on a particular layout in memory in order to be compatible with the vertex shader.</p>
<h1 id="vertex-shader">Vertex Shader<a hidden class="anchor" aria-hidden="true" href="#vertex-shader">#</a></h1>
<p>Next, we need to update our vertex shader itself.</p>
<p>Previously, we had the arrays of positions and colors baked into the shader, and were using the gl_VertexID to index into those arrays. However we now replace those arrays with two <strong>in parameters</strong> in the Vertex shader</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-glsl" data-lang="glsl"><span style="display:flex;"><span>layout(location <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">vec3</span> position;
</span></span><span style="display:flex;"><span>layout(location <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">vec3</span> colour;</span></span></code></pre></div>
<p>Note that these need different <strong>location</strong> values, which will be indexes into the array of descriptors we will provide to our graphics pipeline shortly.</p>
<p>We can just go ahead and use these values directly in our shader. No gl_VertexID required!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-glsl" data-lang="glsl"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> main() {
</span></span><span style="display:flex;"><span>    gl_Position <span style="color:#f92672">=</span> <span style="color:#66d9ef">vec4</span>(position, <span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>    fragColour <span style="color:#f92672">=</span> colour;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>fragColour is our <strong>out parameter</strong> that will be passed along to the fragment shader as before.</p>
<h1 id="graphics-pipeline">Graphics Pipeline<a hidden class="anchor" aria-hidden="true" href="#graphics-pipeline">#</a></h1>
<p>Now that we&rsquo;ve changed the app side to be able to represent this vertex data as an array of structs, and we&rsquo;ve changed the vertex shader to define the data from those structs that it needs access to, we now need to tell the graphics pipeline <em>how</em> to map individual fields of the Vertex struct to the parameters of the shader.</p>
<p>First of all, it would be helpful to visualise how these vertices are actually laid out in memory</p>
<figure class="align-center ">
    <img loading="lazy" src="vertex-layout.png#center"/> <figcaption>
            Vertex Layout<p>
                    <a href="https://learnopengl.com/Getting-started/Shaders">Learn OpenGL</a></p>
        </figcaption>
</figure>

<p>This is how our vertices will be laid out in the buffer sequentially, but we need to tell the pipeline how to chunk this up, and how it knows the data for a single vertex.</p>
<h2 id="bindings">Bindings<a hidden class="anchor" aria-hidden="true" href="#bindings">#</a></h2>
<p>Firstly though, there is the possibility to have multiple <strong>bindings</strong> which are completely separate data streams essentially. We defined our position for example in our vertex shader as</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-glsl" data-lang="glsl"><span style="display:flex;"><span>layout(location <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">vec3</span> position;</span></span></code></pre></div>
<p>But this is shorthand for using the default binding number of 0, so we could write this as</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-glsl" data-lang="glsl"><span style="display:flex;"><span>layout(binding <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, location <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">vec3</span> position;</span></span></code></pre></div>
<p>We only have one stream of data (our vertex buffer) so we only need one binding. But this could be useful if we store positions and colors in separate buffers for example.</p>
<p>In order to define a binding, Vulkan needs to know the <strong>stride</strong>, and <strong>input rate</strong> of the data coming in.</p>
<p>Input rate is either vertex or instance and defines the way in which the data is consumed from the buffers</p>
<ul>
<li><strong>Vertex</strong> identifies that the stride represents the size of an individual vertex, and each vertex will be pulled one at a time</li>
<li><strong>Instance</strong> identifies that the stride represents the total size of all an instances vertices</li>
</ul>
<p>In our case we just pick Vertex because of the way we define our stride.</p>
<p>Stride in our case, is simply the size of a Vertex struct instance. This is the number of bytes that Vulkan will skip forward by to get to the next vertex. As can be seen in the visual diagram above, the stride of a Vertex is the size of the position array plus the size of the color array. Both arrays are 12 bytes (3*4 byte floats) so the stride of the Vertex is 24.</p>
<p>Coding this up, we can define an array of bindings, with a single binding (binding index 0)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> binding_descriptions <span style="color:#f92672">=</span> [<span style="color:#f92672">*</span>VertexInputBindingDescription::builder()
</span></span><span style="display:flex;"><span>    .stride(mem::size_of::<span style="color:#f92672">&lt;</span>Vertex<span style="color:#f92672">&gt;</span>().try_into().unwrap())
</span></span><span style="display:flex;"><span>    .input_rate(VertexInputRate::<span style="color:#66d9ef">VERTEX</span>)];</span></span></code></pre></div>
<h2 id="attributes">Attributes<a hidden class="anchor" aria-hidden="true" href="#attributes">#</a></h2>
<p>Now that we&rsquo;ve defined our data streams and the strides within them, we now need to define how individual components within that stream are found, <strong>which</strong> shader locations they are bound to, and <strong>how</strong> they are interpreted.</p>
<p>Once again looking at the diagram above, we have</p>
<ol>
<li>Position
<ul>
<li>Binding: 0</li>
<li>Location: 0</li>
<li>Offset: 0 bytes</li>
<li>Format: R32G32B32_SFLOAT (3-channel, 4-bytes-per-channel, signed float)</li>
</ul>
</li>
<li>Color
<ul>
<li>Binding: 0</li>
<li>Location: 1</li>
<li>Offset: 12 bytes</li>
<li>Format: R32G32B32_SFLOAT</li>
</ul>
</li>
</ol>
<p>0 is the default value for binding, location, and offset so we don&rsquo;t have to mention it for the first attribute.</p>
<p>Coding those attributes up we have</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> attribute_descriptions <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>VertexInputAttributeDescription::builder().format(Format::<span style="color:#66d9ef">R32G32B32_SFLOAT</span>),
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>VertexInputAttributeDescription::builder()
</span></span><span style="display:flex;"><span>        .location(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        .format(Format::<span style="color:#66d9ef">R32G32B32_SFLOAT</span>)
</span></span><span style="display:flex;"><span>        .offset(<span style="color:#ae81ff">12</span>),
</span></span><span style="display:flex;"><span>];</span></span></code></pre></div>
<h2 id="pipeline">Pipeline<a hidden class="anchor" aria-hidden="true" href="#pipeline">#</a></h2>
<p>Now we can simply add these bindings and attributes to the pipeline by modifying the <strong>PipelineVertexInputStateCreateInfo</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> vertex_input <span style="color:#f92672">=</span> PipelineVertexInputStateCreateInfo::builder()
</span></span><span style="display:flex;"><span>    .vertex_binding_descriptions(<span style="color:#f92672">&amp;</span>binding_descriptions)
</span></span><span style="display:flex;"><span>    .vertex_attribute_descriptions(<span style="color:#f92672">&amp;</span>attribute_descriptions);</span></span></code></pre></div>
<p>And the rest of the pipeline can stay the same.</p>
<h1 id="vertex-buffer">Vertex Buffer<a hidden class="anchor" aria-hidden="true" href="#vertex-buffer">#</a></h1>
<p>Vulkan decouples the resources you&rsquo;re using (buffers, images, etc.) from the actual memory allocated for those resources. This is so that the developer could allocate one large &ldquo;slab&rdquo; of memory and have it contain many resources using it as the following diagram indicates</p>
<figure class="align-center ">
    <img loading="lazy" src="memory-allocation.png#center"/> <figcaption>
            Memory Allocation<p>
                    <a href="https://developer.nvidia.com/vulkan-memory-management">Vulkan Memory Management</a></p>
        </figcaption>
</figure>

<p>Alignment requirements as indicated in the image are resource specific so when we create a resource we are able to query from Vulkan what requirements on memory it has. As long as we provide memory that matches, Vulkan doesn&rsquo;t care where it comes from.</p>
<p>Ideally you would allocate a single allocation and use that for storing interleaved data with different offsets/strides as in the diagram below.</p>
<figure class="align-center ">
    <img loading="lazy" src="buffer-offset.png#center"/> <figcaption>
            Offsets<p>
                    <a href="https://developer.nvidia.com/vulkan-memory-management">Vulkan Memory Management</a></p>
        </figcaption>
</figure>

<p>For our use-case right now we&rsquo;ll allocate a memory allocation for the vertex buffer only though. We&rsquo;re only learning Vulkan so we can leave these &ldquo;best practices&rdquo; until later.</p>
<p>Following are the steps involved in creating a Vulkan buffer, which we&rsquo;ll follow to create a buffer for our vertex data.</p>
<h2 id="creating-the-buffer-resource">Creating the Buffer Resource<a hidden class="anchor" aria-hidden="true" href="#creating-the-buffer-resource">#</a></h2>
<p>Firstly, we need to tell Vulkan that we will be creating a buffer such that it can assign us an opaque handle to refer to that buffer. As mentioned above, there&rsquo;s no memory connected to the buffer, we&rsquo;re just telling Vulkan how the buffer will be used and what shape it has.</p>
<p>Code is as follows</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> buffer <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>    device
</span></span><span style="display:flex;"><span>        .create_buffer(
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&amp;</span>BufferCreateInfo::builder()
</span></span><span style="display:flex;"><span>                .size((mem::size_of::<span style="color:#f92672">&lt;</span>Vertex<span style="color:#f92672">&gt;</span>() <span style="color:#f92672">*</span> vertices.len()) <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u64</span>)
</span></span><span style="display:flex;"><span>                .usage(BufferUsageFlags::<span style="color:#66d9ef">VERTEX_BUFFER</span>)
</span></span><span style="display:flex;"><span>                .sharing_mode(SharingMode::<span style="color:#66d9ef">EXCLUSIVE</span>),
</span></span><span style="display:flex;"><span>            None,
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>        .context(<span style="color:#e6db74">&#34;Failed to create a buffer.&#34;</span>)<span style="color:#f92672">?</span>
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p>There are 3 important arguments we&rsquo;re giving to the BufferCreateInfo here</p>
<ol>
<li>The size of the buffer (in bytes). This is the size of a single Vertex multiplied by the number of vertices. There&rsquo;s no additional data to be stored so this is an easy calculation.</li>
<li>The buffer usage. Vulkan doesn&rsquo;t know what kind of buffer this is until we tell it, in this case we want a vertex buffer.</li>
<li>The sharing mode. A buffer can either be exclusive to a queue family, or shared by multiple queue families much like when we created our image views (another resource). In our case we only use the buffer within the graphics queue family.</li>
</ol>
<h2 id="allocating-memory">Allocating Memory<a hidden class="anchor" aria-hidden="true" href="#allocating-memory">#</a></h2>
<p>Vulkan gives us back an opaque Buffer handle after creation but we now need to allocate some memory for it.</p>
<p>Firstly, Vulkan will only allow memory to be created from some memory types. We can access the memory properties that a Buffer requires by calling a simple function with the buffer handle</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> memory_requirements <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { device.get_buffer_memory_requirements(buffer) };</span></span></code></pre></div>
<p>Now that we have the requirements, we need to know what is available on our <strong>physical</strong> device, which again is a simple call</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> memory_properties <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsafe</span> { instance.get_physical_device_memory_properties(physical_device) };</span></span></code></pre></div>
<p>Now we need to locate a memory type from memory_properties which is supported for the created buffer. We&rsquo;ll wrap this up into a function called find_valid_memory_type_index</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">find_valid_memory_type_index</span>(
</span></span><span style="display:flex;"><span>    memory_properties: <span style="color:#a6e22e">PhysicalDeviceMemoryProperties</span>,
</span></span><span style="display:flex;"><span>    memory_requirements: <span style="color:#a6e22e">MemoryRequirements</span>,
</span></span><span style="display:flex;"><span>    flags: <span style="color:#a6e22e">MemoryPropertyFlags</span>,
</span></span><span style="display:flex;"><span>) -&gt; Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;</span></span></span></code></pre></div>
<p>We take in the memory_properties and memory_requirements we look up, but what&rsquo;s this <strong>MemoryPropertyFlags</strong> we&rsquo;re passing?.</p>
<p>Well memory has other properties defining visibility to the CPU/GPU and we can specify what we would like. For our use case we use</p>
<ol>
<li><strong>Host Visible</strong> - This means that the CPU can see the memory. It might not be located on the CPU, but could have special mapping so it&rsquo;s visible to the CPU</li>
<li><strong>Host Coherent</strong> - This means that the memory doesn&rsquo;t have any special caching so when we write to it, we don&rsquo;t need to flush the cache for example</li>
</ol>
<p>The memory flags are easy to test - it&rsquo;s a bitmask we can use to check against the memory type&rsquo;s <strong>property_flags</strong>.</p>
<p>The memory requirements is also a bitset, but it&rsquo;s a bitset where a bit set to 1 in the ith position (from the right hand side) means that the memory type at index i is valid.</p>
<p>We can therefore get an iterator over all the memory types, enumerate the iterator to get the index along with the type information, and then find the position of the first memory type that is supported, and matches our bitmask with the following code</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>memory_properties
</span></span><span style="display:flex;"><span>    .memory_types
</span></span><span style="display:flex;"><span>    .into_iter()
</span></span><span style="display:flex;"><span>    .enumerate()
</span></span><span style="display:flex;"><span>    .position(<span style="color:#f92672">|</span>(index, memory_type)<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>        (memory_requirements.memory_type_bits <span style="color:#f92672">&amp;</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> index <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u32</span>)) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&amp;&amp;</span> memory_type.property_flags.contains(flags)
</span></span><span style="display:flex;"><span>    })</span></span></code></pre></div>
<p>After we find the index of a valid memory type, we can ask Vulkan to actually allocate the memory for us</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> buffer_memory <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>    device
</span></span><span style="display:flex;"><span>        .allocate_memory(
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&amp;</span>MemoryAllocateInfo::builder()
</span></span><span style="display:flex;"><span>                .allocation_size(memory_requirements.size)
</span></span><span style="display:flex;"><span>                .memory_type_index(memory_type_index <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u32</span>),
</span></span><span style="display:flex;"><span>            None,
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>        .context(<span style="color:#e6db74">&#34;Failed to allocate vertex buffer memory.&#34;</span>)<span style="color:#f92672">?</span>
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p>Note that we get the allocation size from memory_requirements.size rather than using the size we originally requested the buffer to have. This is because due to alignment or other requirements, Vulkan may end up requiring more bytes than we need for the buffer itself.</p>
<p>Finally, we can bind the memory to the buffer. Vulkan lets us give an offset into the memory in case we&rsquo;re using memory for multiple resources, but here we just say no offset</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>    device
</span></span><span style="display:flex;"><span>        .bind_buffer_memory(buffer, buffer_memory, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        .context(<span style="color:#e6db74">&#34;Failed to bind the buffer memory to the vertex buffer.&#34;</span>)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h2 id="writing-vertex-data">Writing Vertex Data<a hidden class="anchor" aria-hidden="true" href="#writing-vertex-data">#</a></h2>
<p>Finally we now have to get our Vertex data into the dedicated memory for the buffer to make it available and visible when we come to binding it to our shader.</p>
<p>In order to get a pointer through which we can write, we need to <strong>map</strong> the correct range of memory, Vulkan will then return us a pointer to write with</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> write_ptr <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>    device
</span></span><span style="display:flex;"><span>        .map_memory(
</span></span><span style="display:flex;"><span>            buffer_memory,
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>            memory_requirements.size,
</span></span><span style="display:flex;"><span>            MemoryMapFlags::empty(),
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>        .context(<span style="color:#e6db74">&#34;Failed to map the buffer memory.&#34;</span>)<span style="color:#f92672">?</span> <span style="color:#66d9ef">as</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">mut</span> Vertex
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p>Again, we pass an offset of 0, and a size of memory_requirements.size because we just want to map the entire range.</p>
<p>We can now go ahead and copy our data into the provided mapped pointer, which in Rust we can do with the std::ptr::copy method which is like a memcpy in C</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">unsafe</span> { ptr::copy(vertices.as_ptr(), write_ptr, vertices.len()) };</span></span></code></pre></div>
<p>And finally once we&rsquo;re done writing to it, we unmap the memory which allows Vulkan to make use of it knowing we&rsquo;re finished setting the memory</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">unsafe</span> { device.unmap_memory(buffer_memory) };</span></span></code></pre></div>
<p>And with that, our vertex data is inside the newly allocated memory, and bound to the newly allocated Buffer handle!</p>
<h2 id="cleanup">Cleanup<a hidden class="anchor" aria-hidden="true" href="#cleanup">#</a></h2>
<p>We also need to remember to clean this up on app shutdown. Specifically we need to <em>free</em> the memory, and <em>destroy</em> the buffer resource.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>device.free_memory(vertex_buffer_memory, None);
</span></span><span style="display:flex;"><span>device.destroy_buffer(vertex_buffer, None);</span></span></code></pre></div>
<h1 id="command-buffer">Command Buffer<a hidden class="anchor" aria-hidden="true" href="#command-buffer">#</a></h1>
<p>The final thing we need to do is to update our code that is recording into the command buffer to set things up for the draw call.</p>
<p>Specifically we need two things:</p>
<ol>
<li>Bind the vertex buffer(s) to make the data available for the draw call</li>
<li>Pass the correct number of vertices into the draw call</li>
</ol>
<p>Firstly, there&rsquo;s the binding. The command to bind the vertex buffer actually handles multiple so we can bind multiple at the same time.</p>
<p>We can also specify offsets to use in the buffers we provide, and the number of buffers we provide is going to determine the binding indices.</p>
<p>In our case we only bind one vertex buffer, with an offset of 0. We also tell Vulkan to start binding indices at 0, so the first vertex buffer has binding 0 and that matches up with what our shader expects.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>device.cmd_bind_vertex_buffers(<span style="color:#f92672">*</span>command_buffer, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">&amp;</span>[vertex_buffer], <span style="color:#f92672">&amp;</span>[<span style="color:#ae81ff">0</span>]);</span></span></code></pre></div>
<p>For the draw call we simply change from drawing 3 vertices to drawing however many we have in the list</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>device.cmd_draw(<span style="color:#f92672">*</span>command_buffer, vertex_count.try_into().unwrap(), <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);</span></span></code></pre></div>
<h1 id="main">Main<a hidden class="anchor" aria-hidden="true" href="#main">#</a></h1>
<p>Now we simply need to fill out our vertex buffer in main so it can be passed along as needed. The vertex data will look like this, moved from where we had it baked into the vertex shader.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> vertex_data <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>    Vertex {
</span></span><span style="display:flex;"><span>        position: [<span style="color:#ae81ff">0.0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">0.4</span>, <span style="color:#ae81ff">0.0</span>],
</span></span><span style="display:flex;"><span>        color: [<span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>],
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    Vertex {
</span></span><span style="display:flex;"><span>        position: [<span style="color:#ae81ff">0.4</span>, <span style="color:#ae81ff">0.4</span>, <span style="color:#ae81ff">0.0</span>],
</span></span><span style="display:flex;"><span>        color: [<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">0.0</span>],
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    Vertex {
</span></span><span style="display:flex;"><span>        position: [<span style="color:#f92672">-</span><span style="color:#ae81ff">0.4</span>, <span style="color:#ae81ff">0.4</span>, <span style="color:#ae81ff">0.0</span>],
</span></span><span style="display:flex;"><span>        color: [<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">1.0</span>],
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>];</span></span></code></pre></div>
<p>Running the code to verify we have exactly the same output as before, we see that we do!</p>
<p><img loading="lazy" src="triangle.png" alt="Triangle"  />
</p>
<p>Now lets try changing the vertex data to define a square, and check that the same shader can be used to render that too!</p>
<p><img loading="lazy" src="square.png" alt="Square"  />
</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://forgottenmaster.github.io/">Robin Smith</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body>

</html>
