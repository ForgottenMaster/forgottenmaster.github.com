<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>5. Swapchain | Robin Firth</title>
<meta name="keywords" content="" />
<meta name="description" content="Now that we&rsquo;ve been able to create the device surface, and get appropriate information about what formats, color spaces, and presentation modes are available, we are ready to tackle the next step in setting up a rendering environment. This next step will be what&rsquo;s called a swapchain
What is screen tearing? On the front-end side of things, the device surface represents the rendering context and can be considered &ldquo;the window&rdquo; for our purposes.">
<meta name="author" content="">
<link rel="canonical" href="https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/swapchain/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.6f60056d44d3f7eb69a4bc6c332b59960f3a995802bded244750232f33713c49.css" integrity="sha256-b2AFbUTT9&#43;tppLxsMytZlg86mVgCve0kR1AjLzNxPEk=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js" integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://forgottenmaster.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://forgottenmaster.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://forgottenmaster.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://forgottenmaster.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://forgottenmaster.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.96.0" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta property="og:title" content="5. Swapchain" />
<meta property="og:description" content="Now that we&rsquo;ve been able to create the device surface, and get appropriate information about what formats, color spaces, and presentation modes are available, we are ready to tackle the next step in setting up a rendering environment. This next step will be what&rsquo;s called a swapchain
What is screen tearing? On the front-end side of things, the device surface represents the rendering context and can be considered &ldquo;the window&rdquo; for our purposes." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/swapchain/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-19T12:21:42&#43;00:00" />
<meta property="article:modified_time" content="2023-02-19T12:21:42&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="5. Swapchain"/>
<meta name="twitter:description" content="Now that we&rsquo;ve been able to create the device surface, and get appropriate information about what formats, color spaces, and presentation modes are available, we are ready to tackle the next step in setting up a rendering environment. This next step will be what&rsquo;s called a swapchain
What is screen tearing? On the front-end side of things, the device surface represents the rendering context and can be considered &ldquo;the window&rdquo; for our purposes."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://forgottenmaster.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Vulkan",
      "item": "https://forgottenmaster.github.io/posts/vulkan/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Let's Learn Vulkan",
      "item": "https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "5. Swapchain",
      "item": "https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/swapchain/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "5. Swapchain",
  "name": "5. Swapchain",
  "description": "Now that we\u0026rsquo;ve been able to create the device surface, and get appropriate information about what formats, color spaces, and presentation modes are available, we are ready to tackle the next step in setting up a rendering environment. This next step will be what\u0026rsquo;s called a swapchain\nWhat is screen tearing? On the front-end side of things, the device surface represents the rendering context and can be considered \u0026ldquo;the window\u0026rdquo; for our purposes.",
  "keywords": [
    
  ],
  "articleBody": "Now that we’ve been able to create the device surface, and get appropriate information about what formats, color spaces, and presentation modes are available, we are ready to tackle the next step in setting up a rendering environment. This next step will be what’s called a swapchain\nWhat is screen tearing? On the front-end side of things, the device surface represents the rendering context and can be considered “the window” for our purposes. The surface is only able to show one buffer of data at a time, and that buffer is submitted to it by the Vulkan API.\nHowever on the back-end side of things, we won’t render directly into the surface, but instead will render into an image and then submit that image to the surface for presentation.\nHowever, if we were to submit directly the image after we’ve finished rendering with it, then the device could be halfway through rendering the previous image and will just continue reading the rest from the new image, resulting in a half-old, half-new render as illustrated below\nTherefore we would ideally like to render to a different image while the previous one is being presented, and to have the new one presented at an appropriate time.\nWhat is a swap chain? A swap chain handles for us a queue of images, and provides a way to give us the image to which we are supposed to render to, before submitting it back to the chain and getting another one. In effect it handles us swapping through the images we’ll be rendering to.\nIt also handles synchronization with the surface for presenting the next image to the surface either immediately, or during the vertical blank depending on the presentation mode.\nThe swap chain can be visualised with the following image\nPresentation modes The swap chain is generally a queue of images as mentioned, and handles coordination with the presentation engine either waiting for, or not waiting for a vertical blank.\nThere are 4 main presentation modes we can use - 2 of which may result in screen tearing because they update the presented image in the middle of presenting the previous image. These 4 modes are:\n Immediate: This mode causes the swapchain to have no internal queue of images. It will take the image to be presented and immediately update it in the presentation engine, resulting in potential screen tearing. Mailbox: This mode causes the swapchain to have an internal buffer of one image. When receiving the submitted image from the application, the swapchain will hold onto it until the next vertical blank, at which point it presents it to the presentation engine. No screen tearing can occur here because the swapchain always waits for a vertical blank before presenting the new image. If another image is given to the swapchain in the meantime, it just updates the one it’s holding. FIFO: This mode also cannot result in screen tearing because the images in the queue are all presented during a vertical blank. The difference between this and mailbox is that with mailbox, if a new image is submitted by the application before an old one is presented, the old on is never presented. In FIFO, all submitted images are presented. This means that the application may end up waiting for a free image as all are stuck in the queue. Note that this presentation mode is required to be supported by the Vulkan spec. FIFO Relaxed: This is similar to FIFO except that the swapchain submits a new image in the queue to the presentation engine when it’s submitted by the application. It recognizes that the view on the surface is stale, and it’s getting a new incoming image from the application so it presents it immediately - can result in screen tearing.  Choosing the best color format The first thing we need to do is to look at the color formats that are available to the surface we’ve constructed, and choose one of them with which to construct our swap chain.\nA color format is actually constructed from 2 pieces of information:\n The actual format, which describes how many bytes/bits per pixel there are in the images of the swapchain, and how those bits are interpreted. The color space, which describes a color palette of sorts and how to map the bytes in the image to colors.  The most common color format is going to be R8G8B8A8_UNORM which will be a standard 1-byte-per-channel, normalised RGBA pixel. This will be the one we’ll try to go for in fact, and as a fallback if that isn’t found we’ll look at BGRA which is more or less the same but with the R and B channels flipped.\nFor color space, the most common is SRGB_NONLINEAR.\nWe’ll create an accessor function on our SurfaceInfo struct that can search for the best format for us to use and return it. The signature will look like\nfn choose_best_color_format(\u0026self) - SurfaceFormatKHR Within the function we’ll define the desired format (and alt format), along with the desired color space\nconst DESIRED_FORMAT: Format = Format::R8G8B8A8_UNORM; const DESIRED_FORMAT_ALT: Format = Format::B8G8R8A8_UNORM; const DESIRED_COLOR_SPACE: ColorSpaceKHR = ColorSpaceKHR::SRGB_NONLINEAR; Vulkan has a shorthand method of reporting that all formats are supported in fact, which is to report only a single format, with type UNIDENTIFIED. If we get this, then we know the device supports any and all format/color space combinations so we can ask for our desired one\nif self.surface_formats.len() == 1 \u0026\u0026 self.surface_formats[0].format == Format::UNDEFINED {  SurfaceFormatKHR {  format: DESIRED_FORMAT,  color_space: DESIRED_COLOR_SPACE  } } else {  // calculate other branch } If not, then we can look through the supported formats list, and try to find one that matches our desired formats/color space\nfor format in \u0026self.surface_formats {  if (format.format == DESIRED_FORMAT || format.format == DESIRED_FORMAT_ALT)  \u0026\u0026 format.color_space == DESIRED_COLOR_SPACE  {  return *format;  } } If we manage to get through the entire list without finding a match then we can just go ahead and return the very first supported format arbitrarily as a backup\nself.surface_formats[0] Choosing the best presentation mode As mentioned previously - 2 of the presentation modes don’t introduce screen tearing, at the cost of a little latency in the display. Furthermore mailbox introduces no overhead of waiting for a free image for the application to continue rendering because new images just replace the existing one in the mailbox.\nSince we don’t want screen tearing, and don’t care about every single frame being displayed we’ll use mailbox if it’s available.\nIf not, luckily the Vulkan spec guarantees that FIFO is available so we use that. The function then in its entirety is pretty simple\nfn choose_best_present_mode(\u0026self) - PresentModeKHR {  const DESIRED_MODE: PresentModeKHR = PresentModeKHR::MAILBOX;  if self.present_modes.contains(\u0026DESIRED_MODE) {  DESIRED_MODE  } else {  PresentModeKHR::FIFO  } } Choosing swapchain extents The final thing we need to do is to get the size of the images that the swapchain will make for us.\nVulkan may have gotten the current image size from the window handles that were used to create the surface and so if the current_extent is set in our surface capabilities, we can use that.\nHowever, in the case that the image size is controllable by us, Vulkan sets width/height to be u32::MAX and in that case we’ll need to calculate it ourselves.\nThe signature of this function then shows that we need to accept the window in case we do need to look up the size of the surface\nfn choose_swapchain_extents(\u0026self, window: \u0026Window) - Extent2D  So, we first check if the width is set to anything other than u32::MAX\nlet current_extent = self.surface_capabilities.current_extent; if current_extent.width != u32::MAX {  current_extent } else {  // need to calculate it ourselves } In the case that we need to calculate ourselves we can get the width/height of the images we need to make from the window by using the inner_size function.\nWe may need to clamp the width/height to the min and max supported values though just in case (although, I can’t think of how the window itself is able to present anything higher than Vulkan itself supports…)\nThe code for the path where we calculate it ourselves then looks as follows\nlet window_size = window.inner_size(); let (width, height) = (window_size.width, window_size.height); let (min_width, min_height) = (  self.surface_capabilities.min_image_extent.width,  self.surface_capabilities.min_image_extent.height, ); let (max_width, max_height) = (  self.surface_capabilities.max_image_extent.width,  self.surface_capabilities.max_image_extent.height, ); let width = cmp::min(cmp::max(width, min_width), max_width); let height = cmp::min(cmp::max(height, min_height), max_height); Extent2D { width, height } Creating the swapchain Now that we have the helpers to get the best color format, color space, and present mode, along with the other capabilities for the surface, we can go ahead and create the swap chain we’ll be using.\nWe’ll go ahead and define a create_swapchain function we can use that will have the following signature\nfn create_swapchain(  swapchain_ext: \u0026Swapchain,  surface: SurfaceKHR,  surface_info: \u0026SurfaceInfo,  queue_family_indices: \u0026QueueFamilyIndices,  window: \u0026Window, ) - ResultSwapchainKHR We need the information for the following purposes:\n swapchain_ext - Ash bundles all the extension functions into a type with the same name as the extension. Specifically, we need this to access the create_swapchain function surface - Swapchain creation requires a handle to the surface surface_info - We get the capabilities, and best present mode, and format from this queue_family_indices - We need these for setting up the swapchain either as a concurrent, or exclusive chain depending on if the graphics and present families are the same or different window - This is required when getting the extents because if the extents aren’t already encoded in the surface info, we need to get them from the window  The first thing we need is to work out how many images we need to make. In order for presentation to work correctly, the surface is able to require a lower bound minimum number of images we need in the chain, however to give us a bit of leeway and implement triple buffering, we’ll try to add one on to the minimum required.\nHowever the surface also dictates an upper bound maximum number of images that can be used, so we need to clamp to this min/max range\nlet min_image_count = cmp::min(  surface_info.surface_capabilities.max_image_count,  surface_info.surface_capabilities.min_image_count + 1, ); We get the best format and shove that into a variable, because the builder for the swapchain creation info actually takes both parts of the format individually and we don’t want to call choose_best_color_format twice\nlet best_format = surface_info.choose_best_color_format(); In order to determine if this swapchain requires multiple families to be able to access the images at the same time (and thus introducing additional synchronization overhead), we need to look at the graphics and present families we found. If they are the same, we don’t need concurrent access. If they’re different then we do!\nlet queue_family_indices = [  queue_family_indices.graphics_family.unwrap(),  queue_family_indices.presentation_family.unwrap(), ]; let is_concurrent = queue_family_indices[0] != queue_family_indices[1]; The bulk of the builder setup here is common\nlet create_info = SwapchainCreateInfoKHR::builder()  .surface(surface)  .min_image_count(min_image_count)  .image_format(best_format.format)  .image_color_space(best_format.color_space)  .image_extent(surface_info.choose_swapchain_extents(window))  .image_array_layers(1)  .image_usage(ImageUsageFlags::COLOR_ATTACHMENT)  .pre_transform(surface_info.surface_capabilities.current_transform)  .composite_alpha(CompositeAlphaFlagsKHR::OPAQUE)  .present_mode(surface_info.choose_best_present_mode())  .clipped(true); A few notes on the new parameters though:\n image_array_layers: Each image in the chain can have multiple layers, however we only use 1 layer per image so this is set to 1 image_usage: We need to tell Vulkan how the images are going to be used. In our case we use them to render color attachments into pre_transform: A transform that’s applied to the images before being presented. We just get this from the surface capabilities directly composite_alpha: This is the behaviour we want for when the surface is partially occluded with another window. In our case we don’t want any blending so just set to opaque clipped: This is whether we still want to draw to portions of the surface hiddedn behind other windows for example. In our case we want to clip them so it doesn’t bother trying to draw occluded portions  Next we can finish off setting up the builder by specifying either concurrent or exclusive image access mode. If concurrent mode then we need to pass along the indices of the families that are allowed to access it\nlet create_info = if is_concurrent {  create_info  .image_sharing_mode(SharingMode::CONCURRENT)  .queue_family_indices(\u0026queue_family_indices) } else {  create_info.image_sharing_mode(SharingMode::EXCLUSIVE) }; Finally, we can just call create_swapchain and pass the builder through\nswapchain_ext  .create_swapchain(\u0026create_info, None)  .context(\"Error while creating a swapchain.\") Destroying a swapchain We have to remember to destroy the swapchain once it’s not in use anymore, which we’ll do by passing to the cleanup function to consume and destroy. We also need to pass the object used to access the extension function pointers so we can access the destroy_swapchain function.\nWe make sure the swapchain is destroyed before the logical device also. The cleanup function then looks like this now\nfn cleanup(  instance: Instance,  device: Device,  debug_utils: DebugUtils,  messenger: DebugUtilsMessengerEXT,  surface_ext: Surface,  surface: SurfaceKHR,  swapchain_ext: Swapchain,  swapchain: SwapchainKHR, ) {  unsafe {  swapchain_ext.destroy_swapchain(swapchain, None);  device.destroy_device(None);  debug_utils.destroy_debug_utils_messenger(messenger, None);  surface_ext.destroy_surface(surface, None);  instance.destroy_instance(None);  } } Creating the image views After creating the swapchain and getting a handle to it, Vulkan will have set it up to create the images for use by the swapchain. However, much like when we created our logical device and didn’t get back the queue handles automatically, we need to query for the swapchain image handles now.\nHowever, we also need to create image views for each image because we don’t submit draw operations directly to the images but to these views which we must create and destroy manually.\nWe’ll first create a struct for storing an image and image view pairing\nstruct SwapchainImage {  image: Image,  image_view: ImageView, } We’ll then create a function that can create the image views and fill out a vector of these pairings for us for later use. This will have the following signature\nfn get_swapchain_images(  swapchain_ext: \u0026Swapchain,  swapchain: SwapchainKHR,  format: Format,  device: \u0026Device, ) - ResultVecSwapchainImage We need the swapchain extension object because it provides us with the function to retrieve the images allocated for a given swapchain. We need the device handle because it provides us the ability to create an image view. We need the format because we need to ensure the image views are created with the same format.\nFor retrieval of the swapchain image handles themselves, this is just a simple call. We’ll also then allocate a Vec of the same size for our output\nlet swapchain_images = swapchain_ext.get_swapchain_images(swapchain)?; let mut swapchain_images_output = Vec::with_capacity(swapchain_images.len()); We then just need to go through each of the images we’ve been given and create an image view for it, before wrapping both up into a SwapchainImage to push into the Vec\nfor image in swapchain_images {  let image_view = create_image_view(image, format, ImageAspectFlags::COLOR, device)?;  swapchain_images_output.push(SwapchainImage { image, image_view }) } Notice that we’ve delegated the functionality to make an image view to a create_image_view function so it might get reused later.\nThat function has the following signature\nfn create_image_view(  image: Image,  format: Format,  aspect_flags: ImageAspectFlags,  device: \u0026Device, ) - ResultImageView Where image is the handle to the image we’re making a view for, format is the data format of that image, the aspect flags tell Vulkan which parts of the image the view will use (in the swapchain case it’s a color buffer), and the device is needed for actual view creation.\nThe first thing we’ll need is to make what’s called a component mapping which tells Vulkan which, if any, swizzling operation to do to a channel when it’s accessed. In our case we’ll just always use identity, which keeps the data in the channel the same as it should be\nlet component_mapping_builder = ComponentMapping::builder()  .r(ComponentSwizzle::IDENTITY)  .g(ComponentSwizzle::IDENTITY)  .b(ComponentSwizzle::IDENTITY)  .a(ComponentSwizzle::IDENTITY); The second thing we need to make is something to tell Vulkan which parts of the image the view will be using. In our case we’re taking the aspect flags in to the function for flexibility. We also need to tell the image view which MIP levels it is caring about, and also which layers of the image.\nSince we told the swapchain to only generate 1 layer per image already, then we can just look at that 1 layer. Similarly, we’re not generating mips so we just look at the 1 level.\nlet subresource_range_builder = ImageSubresourceRange::builder()  .aspect_mask(aspect_flags)  .base_mip_level(0)  .level_count(1)  .base_array_layer(0)  .layer_count(1); Finally we can make the creation parameters. We’ll hard code these image views to be 2D images\nlet builder = ImageViewCreateInfo::builder()  .image(image)  .view_type(ImageViewType::TYPE_2D)  .format(format)  .components(*component_mapping_builder)  .subresource_range(*subresource_range_builder); Finally!, we can tell Vulkan to make the image view for us\nunsafe { device.create_image_view(\u0026builder, None) }  .context(\"Error while trying to create an image view.\") Destroying image views Since image views were something we manually asked Vulkan to make for us, we also need to manually ask Vulkan to destroy them for us.\nWe’ll modify the cleanup function to accept Vec to destroy, and add this loop into the function body, destroying the image views before we destroy the swapchain (since destroying swapchain takes the images with it).\nfor swapchain_image in swapchain_images {  device.destroy_image_view(swapchain_image.image_view, None); } ",
  "wordCount" : "2806",
  "inLanguage": "en",
  "datePublished": "2023-02-19T12:21:42Z",
  "dateModified": "2023-02-19T12:21:42Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/swapchain/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Robin Firth",
    "logo": {
      "@type": "ImageObject",
      "url": "https://forgottenmaster.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://forgottenmaster.github.io/" accesskey="h" title="Robin Firth (Alt + H)">Robin Firth</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://forgottenmaster.github.io/resume/" title="Résumé">
                    <span>Résumé</span>
                </a>
            </li>
            <li>
                <a href="https://forgottenmaster.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://forgottenmaster.github.io/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://forgottenmaster.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/vulkan/">Vulkan</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/vulkan/lets-learn-vulkan/">Let&#39;s Learn Vulkan</a></div>
    <h1 class="post-title">
      5. Swapchain
    </h1>
    <div class="post-meta"><span title='2023-02-19 12:21:42 +0000 UTC'>February 19, 2023</span>&nbsp;·&nbsp;14 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#what-is-screen-tearing" aria-label="What is screen tearing?">What is screen tearing?</a></li>
                <li>
                    <a href="#what-is-a-swap-chain" aria-label="What is a swap chain?">What is a swap chain?</a></li>
                <li>
                    <a href="#presentation-modes" aria-label="Presentation modes">Presentation modes</a></li>
                <li>
                    <a href="#choosing-the-best-color-format" aria-label="Choosing the best color format">Choosing the best color format</a></li>
                <li>
                    <a href="#choosing-the-best-presentation-mode" aria-label="Choosing the best presentation mode">Choosing the best presentation mode</a></li>
                <li>
                    <a href="#choosing-swapchain-extents" aria-label="Choosing swapchain extents">Choosing swapchain extents</a></li>
                <li>
                    <a href="#creating-the-swapchain" aria-label="Creating the swapchain">Creating the swapchain</a></li>
                <li>
                    <a href="#destroying-a-swapchain" aria-label="Destroying a swapchain">Destroying a swapchain</a></li>
                <li>
                    <a href="#creating-the-image-views" aria-label="Creating the image views">Creating the image views</a></li>
                <li>
                    <a href="#destroying-image-views" aria-label="Destroying image views">Destroying image views</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Now that we&rsquo;ve been able to create the device surface, and get appropriate information about what formats, color spaces, and presentation modes are available, we are ready to tackle the next step in setting up a rendering environment. This next step will be what&rsquo;s called a <strong>swapchain</strong></p>
<h1 id="what-is-screen-tearing">What is screen tearing?<a hidden class="anchor" aria-hidden="true" href="#what-is-screen-tearing">#</a></h1>
<p>On the front-end side of things, the device surface represents the rendering context and can be considered &ldquo;the window&rdquo; for our purposes. The surface is only able to show one buffer of data at a time, and that buffer is submitted to it by the Vulkan API.</p>
<p>However on the back-end side of things, we won&rsquo;t render directly into the surface, but instead will render into an image and then <strong>submit</strong> that image to the surface for presentation.</p>
<p>However, if we were to submit directly the image after we&rsquo;ve finished rendering with it, then the device could be halfway through rendering the previous image and will just continue reading the rest from the new image, resulting in a half-old, half-new render as illustrated below</p>
<p><img loading="lazy" src="tearing.jpg" alt="Screen Tearing"  />
</p>
<p>Therefore we would ideally like to render to a <em>different</em> image while the previous one is being presented, and to have the new one presented at an appropriate time.</p>
<h1 id="what-is-a-swap-chain">What is a swap chain?<a hidden class="anchor" aria-hidden="true" href="#what-is-a-swap-chain">#</a></h1>
<p>A swap chain handles for us a queue of images, and provides a way to give us the image to which we are supposed to render to, before submitting it back to the chain and getting another one. In effect it handles us <em>swapping</em> through the images we&rsquo;ll be rendering to.</p>
<p>It also handles synchronization with the surface for presenting the next image to the surface either immediately, or during the vertical blank depending on the presentation mode.</p>
<p>The swap chain can be visualised with the following image</p>
<p><img loading="lazy" src="swapchain.png" alt="Swap Chain"  />
</p>
<h1 id="presentation-modes">Presentation modes<a hidden class="anchor" aria-hidden="true" href="#presentation-modes">#</a></h1>
<p>The swap chain is generally a queue of images as mentioned, and handles coordination with the presentation engine either waiting for, or not waiting for a vertical blank.</p>
<p>There are 4 main presentation modes we can use - 2 of which <strong>may</strong> result in screen tearing because they update the presented image in the middle of presenting the previous image. These 4 modes are:</p>
<ul>
<li><strong>Immediate</strong>: This mode causes the swapchain to have no internal queue of images. It will take the image to be presented and immediately update it in the presentation engine, resulting in potential screen tearing.</li>
<li><strong>Mailbox</strong>: This mode causes the swapchain to have an internal buffer of one image. When receiving the submitted image from the application, the swapchain will hold onto it until the next vertical blank, at which point it presents it to the presentation engine. No screen tearing can occur here because the swapchain always waits for a vertical blank before presenting the new image. If another image is given to the swapchain in the meantime, it just updates the one it&rsquo;s holding.</li>
<li><strong>FIFO</strong>: This mode also cannot result in screen tearing because the images in the queue are all presented during a vertical blank. The difference between this and mailbox is that with mailbox, if a new image is submitted by the application before an old one is presented, the old on is never presented. In FIFO, all submitted images are presented. This means that the application may end up waiting for a free image as all are stuck in the queue. Note that this presentation mode is <strong>required</strong> to be supported by the Vulkan spec.</li>
<li><strong>FIFO Relaxed</strong>: This is similar to FIFO except that the swapchain submits a new image in the queue to the presentation engine when it&rsquo;s submitted by the application. It recognizes that the view on the surface is stale, and it&rsquo;s getting a new incoming image from the application so it presents it immediately - can result in screen tearing.</li>
</ul>
<h1 id="choosing-the-best-color-format">Choosing the best color format<a hidden class="anchor" aria-hidden="true" href="#choosing-the-best-color-format">#</a></h1>
<p>The first thing we need to do is to look at the color formats that are available to the surface we&rsquo;ve constructed, and choose one of them with which to construct our swap chain.</p>
<p>A color format is actually constructed from 2 pieces of information:</p>
<ol>
<li>The actual format, which describes how many bytes/bits per pixel there are in the images of the swapchain, and how those bits are interpreted.</li>
<li>The color space, which describes a color palette of sorts and how to map the bytes in the image to colors.</li>
</ol>
<p>The most common color format is going to be <strong>R8G8B8A8_UNORM</strong> which will be a standard 1-byte-per-channel, normalised RGBA pixel. This will be the one we&rsquo;ll try to go for in fact, and as a fallback if that isn&rsquo;t found we&rsquo;ll look at BGRA which is more or less the same but with the R and B channels flipped.</p>
<p>For color space, the most common is <strong>SRGB_NONLINEAR</strong>.</p>
<p>We&rsquo;ll create an accessor function on our SurfaceInfo struct that can search for the best format for us to use and return it. The signature will look like</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">choose_best_color_format</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">SurfaceFormatKHR</span></span></span></code></pre></div>
<p>Within the function we&rsquo;ll define the desired format (and alt format), along with the desired color space</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> DESIRED_FORMAT: <span style="color:#a6e22e">Format</span> <span style="color:#f92672">=</span> Format::R8G8B8A8_UNORM;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> DESIRED_FORMAT_ALT: <span style="color:#a6e22e">Format</span> <span style="color:#f92672">=</span> Format::B8G8R8A8_UNORM;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> DESIRED_COLOR_SPACE: <span style="color:#a6e22e">ColorSpaceKHR</span> <span style="color:#f92672">=</span> ColorSpaceKHR::SRGB_NONLINEAR;</span></span></code></pre></div>
<p>Vulkan has a shorthand method of reporting that <strong>all</strong> formats are supported in fact, which is to report only a single format, with type UNIDENTIFIED. If we get this, then we know the device supports any and all format/color space combinations so we can ask for our desired one</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> self.surface_formats.len() <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> self.surface_formats[<span style="color:#ae81ff">0</span>].format <span style="color:#f92672">==</span> Format::UNDEFINED {
</span></span><span style="display:flex;"><span>    SurfaceFormatKHR {
</span></span><span style="display:flex;"><span>        format: <span style="color:#a6e22e">DESIRED_FORMAT</span>,
</span></span><span style="display:flex;"><span>        color_space: <span style="color:#a6e22e">DESIRED_COLOR_SPACE</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// calculate other branch
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}</span></span></code></pre></div>
<p>If not, then we can look through the supported formats list, and try to find one that matches our desired formats/color space</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> format <span style="color:#66d9ef">in</span> <span style="color:#f92672">&amp;</span>self.surface_formats {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (format.format <span style="color:#f92672">==</span> DESIRED_FORMAT <span style="color:#f92672">||</span> format.format <span style="color:#f92672">==</span> DESIRED_FORMAT_ALT)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;&amp;</span> format.color_space <span style="color:#f92672">==</span> DESIRED_COLOR_SPACE
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>format;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>If we manage to get through the entire list without finding a match then we can just go ahead and return the very first supported format arbitrarily as a backup</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>self.surface_formats[<span style="color:#ae81ff">0</span>]</span></span></code></pre></div>
<h1 id="choosing-the-best-presentation-mode">Choosing the best presentation mode<a hidden class="anchor" aria-hidden="true" href="#choosing-the-best-presentation-mode">#</a></h1>
<p>As mentioned previously - 2 of the presentation modes don&rsquo;t introduce screen tearing, at the cost of a little latency in the display. Furthermore mailbox introduces no overhead of waiting for a free image for the application to continue rendering because new images just replace the existing one in the mailbox.</p>
<p>Since we don&rsquo;t want screen tearing, and don&rsquo;t care about every single frame being displayed we&rsquo;ll use mailbox if it&rsquo;s available.</p>
<p>If not, luckily the Vulkan spec guarantees that FIFO is available so we use that. The function then in its entirety is pretty simple</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">choose_best_present_mode</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">PresentModeKHR</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> DESIRED_MODE: <span style="color:#a6e22e">PresentModeKHR</span> <span style="color:#f92672">=</span> PresentModeKHR::MAILBOX;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> self.present_modes.contains(<span style="color:#f92672">&amp;</span>DESIRED_MODE) {
</span></span><span style="display:flex;"><span>        DESIRED_MODE
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        PresentModeKHR::FIFO
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h1 id="choosing-swapchain-extents">Choosing swapchain extents<a hidden class="anchor" aria-hidden="true" href="#choosing-swapchain-extents">#</a></h1>
<p>The final thing we need to do is to get the size of the images that the swapchain will make for us.</p>
<p>Vulkan may have gotten the current image size from the window handles that were used to create the surface and so if the current_extent is set in our surface capabilities, we can use that.</p>
<p>However, in the case that the image size is controllable by us, Vulkan sets width/height to be u32::MAX and in that case we&rsquo;ll need to calculate it ourselves.</p>
<p>The signature of this function then shows that we need to accept the window in case we do need to look up the size of the surface</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">choose_swapchain_extents</span>(<span style="color:#f92672">&amp;</span>self, window: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Window</span>) -&gt; <span style="color:#a6e22e">Extent2D</span> 
</span></span></code></pre></div>
<p>So, we first check if the width is set to anything other than u32::MAX</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> current_extent <span style="color:#f92672">=</span> self.surface_capabilities.current_extent;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> current_extent.width <span style="color:#f92672">!=</span> <span style="color:#66d9ef">u32</span>::MAX {
</span></span><span style="display:flex;"><span>    current_extent
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// need to calculate it ourselves
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}</span></span></code></pre></div>
<p>In the case that we need to calculate ourselves we can get the width/height of the images we need to make from the window by using the <strong>inner_size</strong> function.</p>
<p>We may need to clamp the width/height to the min and max supported values though just in case (although, I can&rsquo;t think of how the window itself is able to present anything higher than Vulkan itself supports&hellip;)</p>
<p>The code for the path where we calculate it ourselves then looks as follows</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> window_size <span style="color:#f92672">=</span> window.inner_size();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> (width, height) <span style="color:#f92672">=</span> (window_size.width, window_size.height);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> (min_width, min_height) <span style="color:#f92672">=</span> (
</span></span><span style="display:flex;"><span>    self.surface_capabilities.min_image_extent.width,
</span></span><span style="display:flex;"><span>    self.surface_capabilities.min_image_extent.height,
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> (max_width, max_height) <span style="color:#f92672">=</span> (
</span></span><span style="display:flex;"><span>    self.surface_capabilities.max_image_extent.width,
</span></span><span style="display:flex;"><span>    self.surface_capabilities.max_image_extent.height,
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> width <span style="color:#f92672">=</span> cmp::min(cmp::max(width, min_width), max_width);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> height <span style="color:#f92672">=</span> cmp::min(cmp::max(height, min_height), max_height);
</span></span><span style="display:flex;"><span>Extent2D { width, height }</span></span></code></pre></div>
<h1 id="creating-the-swapchain">Creating the swapchain<a hidden class="anchor" aria-hidden="true" href="#creating-the-swapchain">#</a></h1>
<p>Now that we have the helpers to get the best color format, color space, and present mode, along with the other capabilities for the surface, we can go ahead and create the swap chain we&rsquo;ll be using.</p>
<p>We&rsquo;ll go ahead and define a create_swapchain function we can use that will have the following signature</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">create_swapchain</span>(
</span></span><span style="display:flex;"><span>    swapchain_ext: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Swapchain</span>,
</span></span><span style="display:flex;"><span>    surface: <span style="color:#a6e22e">SurfaceKHR</span>,
</span></span><span style="display:flex;"><span>    surface_info: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">SurfaceInfo</span>,
</span></span><span style="display:flex;"><span>    queue_family_indices: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">QueueFamilyIndices</span>,
</span></span><span style="display:flex;"><span>    window: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Window</span>,
</span></span><span style="display:flex;"><span>) -&gt; Result<span style="color:#f92672">&lt;</span>SwapchainKHR<span style="color:#f92672">&gt;</span></span></span></code></pre></div>
<p>We need the information for the following purposes:</p>
<ul>
<li><strong>swapchain_ext</strong> - Ash bundles all the extension functions into a type with the same name as the extension. Specifically, we need this to access the create_swapchain function</li>
<li><strong>surface</strong> - Swapchain creation requires a handle to the surface</li>
<li><strong>surface_info</strong> - We get the capabilities, and best present mode, and format from this</li>
<li><strong>queue_family_indices</strong> - We need these for setting up the swapchain either as a concurrent, or exclusive chain depending on if the graphics and present families are the same or different</li>
<li><strong>window</strong> - This is required when getting the extents because if the extents aren&rsquo;t already encoded in the surface info, we need to get them from the window</li>
</ul>
<p>The first thing we need is to work out how many images we need to make. In order for presentation to work correctly, the surface is able to require a lower bound minimum number of images we need in the chain, however to give us a bit of leeway and implement triple buffering, we&rsquo;ll try to add one on to the minimum required.</p>
<p>However the surface also dictates an upper bound maximum number of images that can be used, so we need to clamp to this min/max range</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> min_image_count <span style="color:#f92672">=</span> cmp::min(
</span></span><span style="display:flex;"><span>    surface_info.surface_capabilities.max_image_count,
</span></span><span style="display:flex;"><span>    surface_info.surface_capabilities.min_image_count <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>);</span></span></code></pre></div>
<p>We get the best format and shove that into a variable, because the builder for the swapchain creation info actually takes both parts of the format individually and we don&rsquo;t want to call choose_best_color_format twice</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> best_format <span style="color:#f92672">=</span> surface_info.choose_best_color_format();</span></span></code></pre></div>
<p>In order to determine if this swapchain requires multiple families to be able to access the images at the same time (and thus introducing additional synchronization overhead), we need to look at the graphics and present families we found. If they are the same, we don&rsquo;t need concurrent access. If they&rsquo;re different then we do!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> queue_family_indices <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>    queue_family_indices.graphics_family.unwrap(),
</span></span><span style="display:flex;"><span>    queue_family_indices.presentation_family.unwrap(),
</span></span><span style="display:flex;"><span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> is_concurrent <span style="color:#f92672">=</span> queue_family_indices[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">!=</span> queue_family_indices[<span style="color:#ae81ff">1</span>];</span></span></code></pre></div>
<p>The bulk of the builder setup here is common</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> create_info <span style="color:#f92672">=</span> SwapchainCreateInfoKHR::builder()
</span></span><span style="display:flex;"><span>    .surface(surface)
</span></span><span style="display:flex;"><span>    .min_image_count(min_image_count)
</span></span><span style="display:flex;"><span>    .image_format(best_format.format)
</span></span><span style="display:flex;"><span>    .image_color_space(best_format.color_space)
</span></span><span style="display:flex;"><span>    .image_extent(surface_info.choose_swapchain_extents(window))
</span></span><span style="display:flex;"><span>    .image_array_layers(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    .image_usage(ImageUsageFlags::COLOR_ATTACHMENT)
</span></span><span style="display:flex;"><span>    .pre_transform(surface_info.surface_capabilities.current_transform)
</span></span><span style="display:flex;"><span>    .composite_alpha(CompositeAlphaFlagsKHR::OPAQUE)
</span></span><span style="display:flex;"><span>    .present_mode(surface_info.choose_best_present_mode())
</span></span><span style="display:flex;"><span>    .clipped(<span style="color:#66d9ef">true</span>);</span></span></code></pre></div>
<p>A few notes on the new parameters though:</p>
<ul>
<li><strong>image_array_layers</strong>: Each image in the chain can have multiple layers, however we only use 1 layer per image so this is set to 1</li>
<li><strong>image_usage</strong>: We need to tell Vulkan how the images are going to be used. In our case we use them to render color attachments into</li>
<li><strong>pre_transform</strong>: A transform that&rsquo;s applied to the images before being presented. We just get this from the surface capabilities directly</li>
<li><strong>composite_alpha</strong>: This is the behaviour we want for when the surface is partially occluded with another window. In our case we don&rsquo;t want any blending so just set to opaque</li>
<li><strong>clipped</strong>: This is whether we still want to draw to portions of the surface hiddedn behind other windows for example. In our case we want to clip them so it doesn&rsquo;t bother trying to draw occluded portions</li>
</ul>
<p>Next we can finish off setting up the builder by specifying either concurrent or exclusive image access mode. If concurrent mode then we need to pass along the indices of the families that are allowed to access it</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> create_info <span style="color:#f92672">=</span> <span style="color:#66d9ef">if</span> is_concurrent {
</span></span><span style="display:flex;"><span>    create_info
</span></span><span style="display:flex;"><span>        .image_sharing_mode(SharingMode::CONCURRENT)
</span></span><span style="display:flex;"><span>        .queue_family_indices(<span style="color:#f92672">&amp;</span>queue_family_indices)
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    create_info.image_sharing_mode(SharingMode::EXCLUSIVE)
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p>Finally, we can just call create_swapchain and pass the builder through</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>swapchain_ext
</span></span><span style="display:flex;"><span>    .create_swapchain(<span style="color:#f92672">&amp;</span>create_info, None)
</span></span><span style="display:flex;"><span>    .context(<span style="color:#e6db74">&#34;Error while creating a swapchain.&#34;</span>)</span></span></code></pre></div>
<h1 id="destroying-a-swapchain">Destroying a swapchain<a hidden class="anchor" aria-hidden="true" href="#destroying-a-swapchain">#</a></h1>
<p>We have to remember to destroy the swapchain once it&rsquo;s not in use anymore, which we&rsquo;ll do by passing to the cleanup function to consume and destroy. We also need to pass the object used to access the extension function pointers so we can access the destroy_swapchain function.</p>
<p>We make sure the swapchain is destroyed before the logical device also. The cleanup function then looks like this now</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">cleanup</span>(
</span></span><span style="display:flex;"><span>    instance: <span style="color:#a6e22e">Instance</span>,
</span></span><span style="display:flex;"><span>    device: <span style="color:#a6e22e">Device</span>,
</span></span><span style="display:flex;"><span>    debug_utils: <span style="color:#a6e22e">DebugUtils</span>,
</span></span><span style="display:flex;"><span>    messenger: <span style="color:#a6e22e">DebugUtilsMessengerEXT</span>,
</span></span><span style="display:flex;"><span>    surface_ext: <span style="color:#a6e22e">Surface</span>,
</span></span><span style="display:flex;"><span>    surface: <span style="color:#a6e22e">SurfaceKHR</span>,
</span></span><span style="display:flex;"><span>    swapchain_ext: <span style="color:#a6e22e">Swapchain</span>,
</span></span><span style="display:flex;"><span>    swapchain: <span style="color:#a6e22e">SwapchainKHR</span>,
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>        swapchain_ext.destroy_swapchain(swapchain, None);
</span></span><span style="display:flex;"><span>        device.destroy_device(None);
</span></span><span style="display:flex;"><span>        debug_utils.destroy_debug_utils_messenger(messenger, None);
</span></span><span style="display:flex;"><span>        surface_ext.destroy_surface(surface, None);
</span></span><span style="display:flex;"><span>        instance.destroy_instance(None);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h1 id="creating-the-image-views">Creating the image views<a hidden class="anchor" aria-hidden="true" href="#creating-the-image-views">#</a></h1>
<p>After creating the swapchain and getting a handle to it, Vulkan will have set it up to create the images for use by the swapchain. However, much like when we created our logical device and didn&rsquo;t get back the queue handles automatically, we need to query for the swapchain image handles now.</p>
<p>However, we <em>also</em> need to create image <em>views</em> for each image because we don&rsquo;t submit draw operations directly to the images but to these views which we must create and destroy manually.</p>
<p>We&rsquo;ll first create a struct for storing an image and image view pairing</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SwapchainImage</span> {
</span></span><span style="display:flex;"><span>    image: <span style="color:#a6e22e">Image</span>,
</span></span><span style="display:flex;"><span>    image_view: <span style="color:#a6e22e">ImageView</span>,
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>We&rsquo;ll then create a function that can create the image views and fill out a vector of these pairings for us for later use. This will have the following signature</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_swapchain_images</span>(
</span></span><span style="display:flex;"><span>    swapchain_ext: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Swapchain</span>,
</span></span><span style="display:flex;"><span>    swapchain: <span style="color:#a6e22e">SwapchainKHR</span>,
</span></span><span style="display:flex;"><span>    format: <span style="color:#a6e22e">Format</span>,
</span></span><span style="display:flex;"><span>    device: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Device</span>,
</span></span><span style="display:flex;"><span>) -&gt; Result<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>SwapchainImage<span style="color:#f92672">&gt;&gt;</span></span></span></code></pre></div>
<p>We need the swapchain extension object because it provides us with the function to retrieve the images allocated for a given swapchain. We need the device handle because it provides us the ability to create an image view. We need the format because we need to ensure the image views are created with the same format.</p>
<p>For retrieval of the swapchain image handles themselves, this is just a simple call. We&rsquo;ll also then allocate a Vec&lt;SwapchainImage&gt; of the same size for our output</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> swapchain_images <span style="color:#f92672">=</span> swapchain_ext.get_swapchain_images(swapchain)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> swapchain_images_output <span style="color:#f92672">=</span> Vec::with_capacity(swapchain_images.len());</span></span></code></pre></div>
<p>We then just need to go through each of the images we&rsquo;ve been given and create an image view for it, before wrapping both up into a SwapchainImage to push into the Vec</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> image <span style="color:#66d9ef">in</span> swapchain_images {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> image_view <span style="color:#f92672">=</span> create_image_view(image, format, ImageAspectFlags::COLOR, device)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>    swapchain_images_output.push(SwapchainImage { image, image_view })
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Notice that we&rsquo;ve delegated the functionality to make an image view to a create_image_view function so it might get reused later.</p>
<p>That function has the following signature</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">create_image_view</span>(
</span></span><span style="display:flex;"><span>    image: <span style="color:#a6e22e">Image</span>,
</span></span><span style="display:flex;"><span>    format: <span style="color:#a6e22e">Format</span>,
</span></span><span style="display:flex;"><span>    aspect_flags: <span style="color:#a6e22e">ImageAspectFlags</span>,
</span></span><span style="display:flex;"><span>    device: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Device</span>,
</span></span><span style="display:flex;"><span>) -&gt; Result<span style="color:#f92672">&lt;</span>ImageView<span style="color:#f92672">&gt;</span></span></span></code></pre></div>
<p>Where image is the handle to the image we&rsquo;re making a view for, format is the data format of that image, the aspect flags tell Vulkan which parts of the image the view will use (in the swapchain case it&rsquo;s a color buffer), and the device is needed for actual view creation.</p>
<p>The first thing we&rsquo;ll need is to make what&rsquo;s called a <strong>component mapping</strong> which tells Vulkan which, if any, swizzling operation to do to a channel when it&rsquo;s accessed. In our case we&rsquo;ll just always use identity, which keeps the data in the channel the same as it should be</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> component_mapping_builder <span style="color:#f92672">=</span> ComponentMapping::builder()
</span></span><span style="display:flex;"><span>    .r(ComponentSwizzle::IDENTITY)
</span></span><span style="display:flex;"><span>    .g(ComponentSwizzle::IDENTITY)
</span></span><span style="display:flex;"><span>    .b(ComponentSwizzle::IDENTITY)
</span></span><span style="display:flex;"><span>    .a(ComponentSwizzle::IDENTITY);</span></span></code></pre></div>
<p>The second thing we need to make is something to tell Vulkan which parts of the image the view will be using. In our case we&rsquo;re taking the aspect flags in to the function for flexibility. We also need to tell the image view which MIP levels it is caring about, and also which layers of the image.</p>
<p>Since we told the swapchain to only generate 1 layer per image already, then we can just look at that 1 layer. Similarly, we&rsquo;re not generating mips so we just look at the 1 level.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> subresource_range_builder <span style="color:#f92672">=</span> ImageSubresourceRange::builder()
</span></span><span style="display:flex;"><span>    .aspect_mask(aspect_flags)
</span></span><span style="display:flex;"><span>    .base_mip_level(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    .level_count(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    .base_array_layer(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    .layer_count(<span style="color:#ae81ff">1</span>);</span></span></code></pre></div>
<p>Finally we can make the creation parameters. We&rsquo;ll hard code these image views to be 2D images</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> builder <span style="color:#f92672">=</span> ImageViewCreateInfo::builder()
</span></span><span style="display:flex;"><span>    .image(image)
</span></span><span style="display:flex;"><span>    .view_type(ImageViewType::TYPE_2D)
</span></span><span style="display:flex;"><span>    .format(format)
</span></span><span style="display:flex;"><span>    .components(<span style="color:#f92672">*</span>component_mapping_builder)
</span></span><span style="display:flex;"><span>    .subresource_range(<span style="color:#f92672">*</span>subresource_range_builder);</span></span></code></pre></div>
<p>Finally!, we can tell Vulkan to make the image view for us</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">unsafe</span> { device.create_image_view(<span style="color:#f92672">&amp;</span>builder, None) }
</span></span><span style="display:flex;"><span>        .context(<span style="color:#e6db74">&#34;Error while trying to create an image view.&#34;</span>)</span></span></code></pre></div>
<h1 id="destroying-image-views">Destroying image views<a hidden class="anchor" aria-hidden="true" href="#destroying-image-views">#</a></h1>
<p>Since image views were something we manually asked Vulkan to make for us, we also need to manually ask Vulkan to destroy them for us.</p>
<p>We&rsquo;ll modify the cleanup function to accept <strong>Vec&lt;SwapchainImage&gt;</strong> to destroy, and add this loop into the function body, destroying the image views before we destroy the swapchain (since destroying swapchain takes the images with it).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> swapchain_image <span style="color:#66d9ef">in</span> swapchain_images {
</span></span><span style="display:flex;"><span>    device.destroy_image_view(swapchain_image.image_view, None);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://forgottenmaster.github.io/">Robin Firth</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
