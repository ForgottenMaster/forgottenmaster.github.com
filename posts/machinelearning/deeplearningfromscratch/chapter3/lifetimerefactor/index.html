<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>3.4 - Lifetime Refactor | Robin Smith</title>
<meta name="keywords" content="">
<meta name="description" content="After trying to make a start on the next level of abstraction with the NeuralNetwork class, it&rsquo;s becoming apparent that dealing with lifetimes at the lower levels of abstraction (Operation and Layer trait objects) is causing it more difficult to make a nice abstraction at the upper level. We will take a brief interlude to look at what the problem is, and why we need to do a refactor at this point.">
<meta name="author" content="">
<link rel="canonical" href="https://forgottenmaster.github.io/posts/machinelearning/deeplearningfromscratch/chapter3/lifetimerefactor/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.4599eadb9eb2ad3d0a8d6827b41a8fda8f2f4af226b63466c09c5fddbc8706b7.css" integrity="sha256-RZnq256yrT0KjWgntBqP2o8vSvImtjRmwJxf3byHBrc=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://forgottenmaster.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://forgottenmaster.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://forgottenmaster.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://forgottenmaster.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://forgottenmaster.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://forgottenmaster.github.io/posts/machinelearning/deeplearningfromscratch/chapter3/lifetimerefactor/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="3.4 - Lifetime Refactor" />
<meta property="og:description" content="After trying to make a start on the next level of abstraction with the NeuralNetwork class, it&rsquo;s becoming apparent that dealing with lifetimes at the lower levels of abstraction (Operation and Layer trait objects) is causing it more difficult to make a nice abstraction at the upper level. We will take a brief interlude to look at what the problem is, and why we need to do a refactor at this point." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://forgottenmaster.github.io/posts/machinelearning/deeplearningfromscratch/chapter3/lifetimerefactor/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-19T17:45:27+00:00" />
<meta property="article:modified_time" content="2022-03-19T17:45:27+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="3.4 - Lifetime Refactor"/>
<meta name="twitter:description" content="After trying to make a start on the next level of abstraction with the NeuralNetwork class, it&rsquo;s becoming apparent that dealing with lifetimes at the lower levels of abstraction (Operation and Layer trait objects) is causing it more difficult to make a nice abstraction at the upper level. We will take a brief interlude to look at what the problem is, and why we need to do a refactor at this point."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://forgottenmaster.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Machine Learning",
      "item": "https://forgottenmaster.github.io/posts/machinelearning/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Deep Learning From Scratch",
      "item": "https://forgottenmaster.github.io/posts/machinelearning/deeplearningfromscratch/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "Chapter 3 - Deep Learning",
      "item": "https://forgottenmaster.github.io/posts/machinelearning/deeplearningfromscratch/chapter3/"
    }, 
    {
      "@type": "ListItem",
      "position":  5 ,
      "name": "3.4 - Lifetime Refactor",
      "item": "https://forgottenmaster.github.io/posts/machinelearning/deeplearningfromscratch/chapter3/lifetimerefactor/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "3.4 - Lifetime Refactor",
  "name": "3.4 - Lifetime Refactor",
  "description": "After trying to make a start on the next level of abstraction with the NeuralNetwork class, it\u0026rsquo;s becoming apparent that dealing with lifetimes at the lower levels of abstraction (Operation and Layer trait objects) is causing it more difficult to make a nice abstraction at the upper level. We will take a brief interlude to look at what the problem is, and why we need to do a refactor at this point.",
  "keywords": [
    
  ],
  "articleBody": "After trying to make a start on the next level of abstraction with the NeuralNetwork class, it’s becoming apparent that dealing with lifetimes at the lower levels of abstraction (Operation and Layer trait objects) is causing it more difficult to make a nice abstraction at the upper level. We will take a brief interlude to look at what the problem is, and why we need to do a refactor at this point.\nThe Problem The problem we run into with lifetimes is that we are required to keep the items for which we are borrowing around at least as long as the struct we’re instantiating and when we use the literal reference extension “feature” of Rust, it’s simply syntactic sugar.\nFor example, taking an example from one of the previous tests if we have a line such as:\nlet net = \u0026mut [ Operation::new_parameter(\u0026WeightMultiply, weights), Operation::new_parameter(\u0026BiasAdd, bias), Operation::new_basic(\u0026Sigmoid), Operation::new_basic(\u0026Linear), ]; Rust compiler will see that this is using temporary literals, and everything is all in the same scope, it can see that net here is a mutable reference, which means that nothing else can modify it, and more importantly it knows that net can’t be moved due to the reference. The compiler is fine with this because it can desugar it by putting all these temporaries inside let bindings:\nlet _1 = WeightMultiply; let _2 = BiasAdd; let _3 = Sigmoid; let _4 = Linear; let mut _5 = [ Operation::new_parameter(\u0026_1, weights), Operation::new_parameter(\u0026_2, bias), Operation::new_basic(\u0026_3), Operation::new_basic(\u0026_4) ]; let net = \u0026mut _5; And everything is happy here because the temporaries are literals and can be evaluated/verified to exist at compile time. It can be desugared into local variables, and doesn’t have to worry about the network moving without the data inside because it can’t be moved due to us only having access to a borrow.\nHowever if we take a look at the following snippet, which is a very stripped down version what we would like to have for the next abstraction (the neural network):\nstruct Network\u003c'a, T\u003e { layers: Vec\u003cLayer\u003c'a, T\u003e\u003e } #[test] fn test_throwaway() { let n: Network\u003c'_, f64\u003e = Network { layers: vec![Layer::new(1, \u0026DenseLayerSetup::new(\u0026Sigmoid))] }; println!(\"{:?}\", n.layers.len()); } As we can see, we simply would like a Vec of Layers in our Network. However the important thing here is the following:\n\u0026DenseLayerSetup::new(\u0026Sigmoid) As mentioned in the previous test, Sigmoid is a literal and so the Rust compiler will extend it with the reference. However, in our case we aren’t creating a DenseLayerSetup literal. To do so, we would need access, and specify all the fields inside a DenseLayerSetup, but we don’t want to do this as it’s exposing implementation details and can cause code to break if the structure of the…..structure changes.\nInstead, we use the “new” associated method to create a new instance. The problem here then, is this is no longer a literal, it returns an instance of DenseLayerSetup created at runtime and not (as in the case of the above test with literal extension) at compile time.\nSince it’s a runtime expression, Rust can no longer use its lifetime extension desugaring to store off the temporary.\nIf we try to compile this code, we get the following error message indicating that the temporary returned from the new function doesn’t live long enough:\nSolution #1 - Get the API user to store intermediate values The first of the two solutions we can use to get around this is simply to not care, continue using lifetimes all the way up the abstraction tree, and instead of having a Vec of layer instances, we instead have a slice of layer instances. In this solution we would change the definition of the Network structure to be thus:\nstruct Network\u003c'a, T\u003e { layers: \u0026'a mut [Layer\u003c'a, T\u003e] } This will work, for sure, but it requires that the caller ensure that the storage for the slice is as long as the Network itself. This leads to code that isn’t as succinct, such as:\nlet dense_layer_setup = DenseLayerSetup::new(\u0026Sigmoid); let mut layers = [Layer::new(1, \u0026dense_layer_setup)]; let n: Network\u003c'_, f64\u003e = Network { layers: \u0026mut layers }; Which has a couple of issues:\nIt’s not exactly nice to write. We would like to be able to write the whole network construct as a single expression. We can’t move the network around. Since it doesn’t own the data, it’s kind of pinned in place by virtue of the fact that the data it’s borrowing is not movable (can’t be moved while borrowed). Note that neither is necessarily a problem, and in environments where we have no heap allocation it might even be necessarily to give stack control to the caller. However, we are trying to write a nice, usable API and as such, these limitations are not really acceptable for us.\nSolution #2 - Use boxing instead of borrows The other option is for the structures to own their component parts instead of borrowing them. This will also remove the requirement to have an explicit lifetime annotation since owning the data means it is guaranteed to live as long as the object itself.\nIn order to do this with Rust, we simply use the Box type. We can use the Box::new constructor to get a boxed/owned trait object rather than taking a reference to it. We can also use Vec rather than slice to get an owned collection of things. Thus, instead of doing the following:\nlet dense_layer_setup = DenseLayerSetup::new(\u0026Sigmoid); let mut layers = [Layer::new(1, \u0026dense_layer_setup)]; let n: Network\u003c'_, f64\u003e = Network { layers: \u0026mut layers }; We would simply like to be able to do:\nlet n: Network\u003cf64\u003e = Network { layers: vec![Layer::new( 1, Box::new(DenseLayerSetup::new(Box::new(Sigmoid))), )], }; Replacing the references with boxed and owned instances. However, we can do one better by having the new function return the new instance already boxed. However, to make it explicit, we’ll call it new_boxed as it’s good practice for a function named “new” to return an instance of the exact type it’s called on. The proposed API would then be something like:\nlet n: Network\u003cf64\u003e = Network { layers: vec![Layer::new( 1, DenseLayerSetup::new_boxed(Sigmoid::new_boxed()), )], }; We could go one step further and have the DenseLayerSetup internally construct the Sigmoid activation function trait object here for storage, and rely on generics. This would result in code looking like the following:\nlet n: Network\u003cf64\u003e = Network { layers: vec![Layer::new( 1, DenseLayerSetup::new_boxed::\u003cSigmoid\u003e(), )], }; However there are a couple of issues with this:\nIt doesn’t support operations/activation functions with additional setup. It relies entirely on the presence of the Default trait/method. It requires all types implementing BasicOperation to then implement Default, which might not be wanted (they might want to ensure that data is provided to construct an instance). Therefore we won’t take this step, and stick with having it passed in.\nSolution #3 - Insanity There is a third solution which allows the network to be constructed with the nice syntax, and which can be moved around and such, however the code becomes much less readable, especially when looking at the types of layers/operations.\nThis solution is of course to use generics such that the type of the neural network overall statically encodes the concrete setup of the network.\nI will be ignoring this as a viable solution, at least until finishing going through the book with a more traditional runtime solution, however I may revisit it in the future as a fun exercise.\nSolution Choice All things considered the best choice for this API for the time being is solution number 2. We are assuming we’re running on hardware that has an allocator setup in some fashion, and we’re assuming that the allocations will be very small.\nAdditionally, we only allocate once up front when constructing the neural network and after that don’t need any further allocations. This solution also allows for easy API usage, especially if we add the new_boxed methods to remove the visual clutter of Box::new calls.\nFollowing is a brief overview of the changes that need to be made.\nOperationData/Operation We change the OperationData structure so as to not accept a reference trait object but a boxed one. These BasicOperation and ParameterOperation instances are usually (if not always) going to be zero sized types, since they don’t store any state themselves and only exist to act as a vtable for the actual calculations of the operation.\nIn Rust, boxing a ZST is guaranteed to not cause an allocation, therefore we introduce no allocations at this level (in general, but someone could still theoretically provide a BasicOperation or ParameterOperation that does have data).\nWe are able to remove the lifetime annotations since the trait object will now be owned rather than borrowed. Operation data will then change from:\nenum OperationData\u003c'a, T\u003e { Basic(\u0026'a dyn BasicOperation\u003cT\u003e), Parameter { operation: \u0026'a dyn ParameterOperation\u003cT\u003e, parameter: Array\u003cT, Ix2\u003e, parameter_gradient: Option\u003cArray\u003cT, Ix2\u003e\u003e, }, } To:\nenum OperationData\u003cT\u003e { Basic(Box\u003cdyn BasicOperation\u003cT\u003e\u003e), Parameter { operation: Box\u003cdyn ParameterOperation\u003cT\u003e\u003e, parameter: Array\u003cT, Ix2\u003e, parameter_gradient: Option\u003cArray\u003cT, Ix2\u003e\u003e, }, } Which then also lets us remove the explicit lifetime annotation from Operation as well, since it only existed to relay that information into the OperationData type being used. Therefore the new Operation will become:\npub struct Operation\u003cT\u003e { input: Option\u003cArray\u003cT, Ix2\u003e\u003e, input_gradient: Option\u003cArray\u003cT, Ix2\u003e\u003e, output: Option\u003cArray\u003cT, Ix2\u003e\u003e, data: OperationData\u003cT\u003e, } We also replace the references with boxed trait objects in the new_basic and new_parameter functions, but we don’t need to show this here.\nLayerSetup The LayerSetup trait previously had an explicit lifetime parameter so as to be able to return a Vec of Operation with the correct lifetime. However we wish to remove this lifetime annotation which we now can do since Operation no longer takes one.\nThe new definition of the LayerSetup trait then becomes:\npub trait LayerSetup\u003cT\u003e { fn layer_setup( \u0026self, num_neurons: usize, input: \u0026Array\u003cT, Ix2\u003e, seed: \u0026Option\u003cu64\u003e, ) -\u003e Vec\u003cOperation\u003cT\u003e\u003e; } DenseLayerSetup Previously this took a borrow to a BasicOperation to be used at the end of the layer (mimicking how OperationData::Basic had a borrow to one). As part of this lifetime annotation removal, we wish to hold a boxed instance (which doesn’t cause an allocation generally if BasicOperation is a ZST).\nThe new definition of DenseLayerSetup then is simply:\npub struct DenseLayerSetup\u003cT\u003e(Box\u003cdyn BasicOperation\u003cT\u003e\u003e); Layer Previously the Layer struct held a borrow to the LayerSetup trait object like in the other cases, but we will replace this with a boxed trait object and can then remove the lifetime annotation as it’s no longer needed.\nThe new definition of Layer then becomes:\npub struct Layer\u003cT\u003e { num_neurons: usize, operations: Option\u003cVec\u003cOperation\u003cT\u003e\u003e\u003e, setup: Box\u003cdyn LayerSetup\u003cT\u003e\u003e, output: Option\u003cArray\u003cT, Ix2\u003e\u003e, seed: Option\u003cu64\u003e, } Loss Finally, the Loss struct is also storing its vtable/trait object by borrow. We can do the same kind of replacement as elsewhere there too and end up with:\npub struct Loss\u003cT\u003e { implementation: Box\u003cdyn LossImpl\u003cT\u003e\u003e, prediction: Option\u003cArray\u003cT, Ix2\u003e\u003e, target: Option\u003cArray\u003cT, Ix2\u003e\u003e, } Conclusion After changing these types, we then need to go through the compiler errors that we now get as a result of the change from reference to owned box. While we’re doing this, we will make it so that all the appropriate types have a “new_boxed” associated method for convenience.\nThis means that instead of writing Box::new(Foo::new()) people can then just write Foo::new_boxed() which is a little leaner.\nAfter these changes we can now use the API in a way we expect, for example the following code now compiles where it wouldn’t in the previous version:\nstruct Network\u003cT\u003e { layers: Vec\u003cLayer\u003cT\u003e\u003e, } #[test] fn test_throwaway() { let n: Network\u003cf64\u003e = Network { layers: vec![Layer::new( 1, DenseLayerSetup::new_boxed(Sigmoid::new_boxed()), )], }; println!(\"{:?}\", n.layers.len()); } ",
  "wordCount" : "1929",
  "inLanguage": "en",
  "datePublished": "2022-03-19T17:45:27Z",
  "dateModified": "2022-03-19T17:45:27Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://forgottenmaster.github.io/posts/machinelearning/deeplearningfromscratch/chapter3/lifetimerefactor/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Robin Smith",
    "logo": {
      "@type": "ImageObject",
      "url": "https://forgottenmaster.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://forgottenmaster.github.io/" accesskey="h" title="Robin Smith (Alt + H)">Robin Smith</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://forgottenmaster.github.io/resume/" title="Résumé">
                    <span>Résumé</span>
                </a>
            </li>
            <li>
                <a href="https://forgottenmaster.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://forgottenmaster.github.io/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://forgottenmaster.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/machinelearning/">Machine Learning</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/machinelearning/deeplearningfromscratch/">Deep Learning From Scratch</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/machinelearning/deeplearningfromscratch/chapter3/">Chapter 3 - Deep Learning</a></div>
    <h1 class="post-title entry-hint-parent">
      3.4 - Lifetime Refactor
    </h1>
    <div class="post-meta"><span title='2022-03-19 17:45:27 +0000 UTC'>March 19, 2022</span>&nbsp;·&nbsp;10 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#the-problem" aria-label="The Problem">The Problem</a></li>
                <li>
                    <a href="#solution-1---get-the-api-user-to-store-intermediate-values" aria-label="Solution #1 - Get the API user to store intermediate values">Solution #1 - Get the API user to store intermediate values</a></li>
                <li>
                    <a href="#solution-2---use-boxing-instead-of-borrows" aria-label="Solution #2 - Use boxing instead of borrows">Solution #2 - Use boxing instead of borrows</a></li>
                <li>
                    <a href="#solution-3---insanity" aria-label="Solution #3 - Insanity">Solution #3 - Insanity</a></li>
                <li>
                    <a href="#solution-choice" aria-label="Solution Choice">Solution Choice</a><ul>
                        
                <li>
                    <a href="#operationdataoperation" aria-label="OperationData/Operation">OperationData/Operation</a></li>
                <li>
                    <a href="#layersetup" aria-label="LayerSetup">LayerSetup</a></li>
                <li>
                    <a href="#denselayersetup" aria-label="DenseLayerSetup">DenseLayerSetup</a></li>
                <li>
                    <a href="#layer" aria-label="Layer">Layer</a></li>
                <li>
                    <a href="#loss" aria-label="Loss">Loss</a></li></ul>
                </li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>After trying to make a start on the next level of abstraction with the NeuralNetwork class, it&rsquo;s becoming apparent that dealing with lifetimes at the lower levels of abstraction (Operation and Layer trait objects) is causing it more difficult to make a nice abstraction at the upper level. We will take a brief interlude to look at what the problem is, and why we need to do a refactor at this point.</p>
<h3 id="the-problem">The Problem<a hidden class="anchor" aria-hidden="true" href="#the-problem">#</a></h3>
<p>The problem we run into with lifetimes is that we are required to keep the items for which we are borrowing around at least as long as the struct we&rsquo;re instantiating and when we use the literal reference extension &ldquo;feature&rdquo; of Rust, it&rsquo;s simply syntactic sugar.</p>
<p>For example, taking an example from one of the previous tests if we have a line such as:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> net <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> [
</span></span><span style="display:flex;"><span>    Operation::new_parameter(<span style="color:#f92672">&amp;</span>WeightMultiply, weights),
</span></span><span style="display:flex;"><span>    Operation::new_parameter(<span style="color:#f92672">&amp;</span>BiasAdd, bias),
</span></span><span style="display:flex;"><span>    Operation::new_basic(<span style="color:#f92672">&amp;</span>Sigmoid),
</span></span><span style="display:flex;"><span>    Operation::new_basic(<span style="color:#f92672">&amp;</span>Linear),
</span></span><span style="display:flex;"><span>];</span></span></code></pre></div>
<p>Rust compiler will see that this is using temporary <strong>literals</strong>, and everything is all in the same scope, it can see that net here is a mutable reference, which means that nothing else can modify it, and more importantly it knows that <strong>net can&rsquo;t be moved</strong> due to the reference. The compiler is fine with this because it can desugar it by putting all these temporaries inside let bindings:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> _1 <span style="color:#f92672">=</span> WeightMultiply;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> _2 <span style="color:#f92672">=</span> BiasAdd;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> _3 <span style="color:#f92672">=</span> Sigmoid;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> _4 <span style="color:#f92672">=</span> Linear;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> _5 <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>    Operation::new_parameter(<span style="color:#f92672">&amp;</span>_1, weights),
</span></span><span style="display:flex;"><span>    Operation::new_parameter(<span style="color:#f92672">&amp;</span>_2, bias),
</span></span><span style="display:flex;"><span>    Operation::new_basic(<span style="color:#f92672">&amp;</span>_3),
</span></span><span style="display:flex;"><span>    Operation::new_basic(<span style="color:#f92672">&amp;</span>_4)
</span></span><span style="display:flex;"><span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> net <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> _5;</span></span></code></pre></div>
<p>And everything is happy here because the temporaries are literals and can be evaluated/verified to exist at <strong>compile time</strong>. It can be desugared into local variables, and doesn&rsquo;t have to worry about the network moving without the data inside because it can&rsquo;t be moved due to us only having access to a borrow.</p>
<p>However if we take a look at the following snippet, which is a very stripped down version what we would <em>like</em> to have for the next abstraction (the neural network):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Network</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span>, T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    layers: Vec<span style="color:#f92672">&lt;</span>Layer<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span>, T<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[test]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">test_throwaway</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> n: <span style="color:#a6e22e">Network</span><span style="color:#f92672">&lt;</span>&#39;_, <span style="color:#66d9ef">f64</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> Network {
</span></span><span style="display:flex;"><span>        layers: <span style="color:#a6e22e">vec</span><span style="color:#f92672">!</span>[Layer::new(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>DenseLayerSetup::new(<span style="color:#f92672">&amp;</span>Sigmoid))]
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, n.layers.len());
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>As we can see, we simply would like a Vec of Layers in our Network. However the important thing here is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#f92672">&amp;</span>DenseLayerSetup::new(<span style="color:#f92672">&amp;</span>Sigmoid)</span></span></code></pre></div>
<p>As mentioned in the previous test, Sigmoid is a <strong>literal</strong> and so the Rust compiler will extend it with the reference. However, in our case we aren&rsquo;t creating a DenseLayerSetup literal. To do so, we would need access, and specify all the fields inside a DenseLayerSetup, but we don&rsquo;t want to do this as it&rsquo;s exposing implementation details and can cause code to break if the structure of the&hellip;..structure changes.</p>
<p>Instead, we use the &ldquo;new&rdquo; associated method to create a new instance. The problem here then, is this is no longer a literal, it returns an instance of DenseLayerSetup created at <em>runtime</em> and not (as in the case of the above test with literal extension) at <em>compile time</em>.</p>
<p>Since it&rsquo;s a runtime expression, Rust can no longer use its lifetime extension desugaring to store off the temporary.</p>
<p>If we try to compile this code, we get the following error message indicating that the temporary returned from the new function doesn&rsquo;t live long enough:</p>
<p><img loading="lazy" src="error.PNG" alt="Error Message"  />
</p>
<h3 id="solution-1---get-the-api-user-to-store-intermediate-values">Solution #1 - Get the API user to store intermediate values<a hidden class="anchor" aria-hidden="true" href="#solution-1---get-the-api-user-to-store-intermediate-values">#</a></h3>
<p>The first of the two solutions we can use to get around this is simply to not care, continue using lifetimes all the way up the abstraction tree, and instead of having a <em>Vec</em> of layer instances, we instead have a <em>slice</em> of layer instances. In this solution we would change the definition of the Network structure to be thus:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Network</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span>, T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    layers: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#a6e22e">mut</span> [Layer<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span>, T<span style="color:#f92672">&gt;</span>]
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>This will work, for sure, but it requires that the <strong>caller</strong> ensure that the storage for the slice is as long as the Network itself. This leads to code that isn&rsquo;t as succinct, such as:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dense_layer_setup <span style="color:#f92672">=</span> DenseLayerSetup::new(<span style="color:#f92672">&amp;</span>Sigmoid);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> layers <span style="color:#f92672">=</span> [Layer::new(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>dense_layer_setup)];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> n: <span style="color:#a6e22e">Network</span><span style="color:#f92672">&lt;</span>&#39;_, <span style="color:#66d9ef">f64</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> Network {
</span></span><span style="display:flex;"><span>    layers: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> layers
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p>Which has a couple of issues:</p>
<ol>
<li>It&rsquo;s not exactly nice to write. We would like to be able to write the whole network construct as a single expression.</li>
<li>We can&rsquo;t move the network around. Since it doesn&rsquo;t own the data, it&rsquo;s kind of pinned in place by virtue of the fact that the data it&rsquo;s borrowing is not movable (can&rsquo;t be moved while borrowed).</li>
</ol>
<p>Note that neither is necessarily a <em>problem</em>, and in environments where we have no heap allocation it might even be necessarily to give stack control to the caller. However, we are trying to write a nice, usable API and as such, these limitations are not really acceptable for us.</p>
<h3 id="solution-2---use-boxing-instead-of-borrows">Solution #2 - Use boxing instead of borrows<a hidden class="anchor" aria-hidden="true" href="#solution-2---use-boxing-instead-of-borrows">#</a></h3>
<p>The other option is for the structures to <em>own</em> their component parts instead of borrowing them. This will also remove the requirement to have an explicit lifetime annotation since owning the data means it is guaranteed to live as long as the object itself.</p>
<p>In order to do this with Rust, we simply use the Box type. We can use the Box::new constructor to get a boxed/owned trait object rather than taking a reference to it. We can also use Vec rather than slice to get an owned collection of things. Thus, instead of doing the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dense_layer_setup <span style="color:#f92672">=</span> DenseLayerSetup::new(<span style="color:#f92672">&amp;</span>Sigmoid);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> layers <span style="color:#f92672">=</span> [Layer::new(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>dense_layer_setup)];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> n: <span style="color:#a6e22e">Network</span><span style="color:#f92672">&lt;</span>&#39;_, <span style="color:#66d9ef">f64</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> Network {
</span></span><span style="display:flex;"><span>    layers: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> layers
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p>We would simply like to be able to do:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> n: <span style="color:#a6e22e">Network</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f64</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> Network {
</span></span><span style="display:flex;"><span>    layers: <span style="color:#a6e22e">vec</span><span style="color:#f92672">!</span>[Layer::new(
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>        Box::new(DenseLayerSetup::new(Box::new(Sigmoid))),
</span></span><span style="display:flex;"><span>    )],
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p>Replacing the references with boxed and owned instances. However, we can do one better by having the new function return the new instance already boxed. However, to make it explicit, we&rsquo;ll call it new_boxed as it&rsquo;s good practice for a function named &ldquo;new&rdquo; to return an instance of the exact type it&rsquo;s called on. The proposed API would then be something like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> n: <span style="color:#a6e22e">Network</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f64</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> Network {
</span></span><span style="display:flex;"><span>    layers: <span style="color:#a6e22e">vec</span><span style="color:#f92672">!</span>[Layer::new(
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>        DenseLayerSetup::new_boxed(Sigmoid::new_boxed()),
</span></span><span style="display:flex;"><span>    )],
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p>We could go one step further and have the DenseLayerSetup internally construct the Sigmoid activation function trait object here for storage, and rely on generics. This would result in code looking like the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> n: <span style="color:#a6e22e">Network</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f64</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> Network {
</span></span><span style="display:flex;"><span>    layers: <span style="color:#a6e22e">vec</span><span style="color:#f92672">!</span>[Layer::new(
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>        DenseLayerSetup::new_boxed::<span style="color:#f92672">&lt;</span>Sigmoid<span style="color:#f92672">&gt;</span>(),
</span></span><span style="display:flex;"><span>    )],
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p>However there are a couple of issues with this:</p>
<ol>
<li>It doesn&rsquo;t support operations/activation functions with additional setup. It relies entirely on the presence of the Default trait/method.</li>
<li>It requires all types implementing BasicOperation to then implement Default, which might not be wanted (they might want to ensure that data is provided to construct an instance).</li>
</ol>
<p>Therefore we won&rsquo;t take this step, and stick with having it passed in.</p>
<h3 id="solution-3---insanity">Solution #3 - Insanity<a hidden class="anchor" aria-hidden="true" href="#solution-3---insanity">#</a></h3>
<p>There is a third solution which allows the network to be constructed with the nice syntax, and which can be moved around and such, however the code becomes much less readable, especially when looking at the types of layers/operations.</p>
<p>This solution is of course to use generics such that the type of the neural network overall statically encodes the concrete setup of the network.</p>
<p>I will be ignoring this as a viable solution, at least until finishing going through the book with a more traditional runtime solution, however I may revisit it in the future as a fun exercise.</p>
<h3 id="solution-choice">Solution Choice<a hidden class="anchor" aria-hidden="true" href="#solution-choice">#</a></h3>
<p>All things considered the best choice for this API for the time being is solution number 2. We are assuming we&rsquo;re running on hardware that has an allocator setup in some fashion, and we&rsquo;re assuming that the allocations will be very small.</p>
<p>Additionally, we only allocate once up front when constructing the neural network and after that don&rsquo;t need any further allocations. This solution also allows for easy API usage, especially if we add the new_boxed methods to remove the visual clutter of Box::new calls.</p>
<p>Following is a brief overview of the changes that need to be made.</p>
<h4 id="operationdataoperation">OperationData/Operation<a hidden class="anchor" aria-hidden="true" href="#operationdataoperation">#</a></h4>
<p>We change the OperationData structure so as to not accept a reference trait object but a boxed one. These BasicOperation and ParameterOperation instances are usually (if not always) going to be zero sized types, since they don&rsquo;t store any state themselves and only exist to act as a vtable for the actual calculations of the operation.</p>
<p>In Rust, boxing a ZST is guaranteed to <strong>not</strong> cause an allocation, therefore we introduce no allocations at this level (in general, but someone could still theoretically provide a BasicOperation or ParameterOperation that does have data).</p>
<p>We are able to remove the lifetime annotations since the trait object will now be owned rather than borrowed. Operation data will then change from:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">OperationData</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span>, T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    Basic(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">dyn</span> BasicOperation<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>),
</span></span><span style="display:flex;"><span>    Parameter {
</span></span><span style="display:flex;"><span>        operation: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#a6e22e">dyn</span> ParameterOperation<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>        parameter: <span style="color:#a6e22e">Array</span><span style="color:#f92672">&lt;</span>T, Ix2<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>        parameter_gradient: Option<span style="color:#f92672">&lt;</span>Array<span style="color:#f92672">&lt;</span>T, Ix2<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>To:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">OperationData</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    Basic(Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> BasicOperation<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>),
</span></span><span style="display:flex;"><span>    Parameter {
</span></span><span style="display:flex;"><span>        operation: Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> ParameterOperation<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>        parameter: <span style="color:#a6e22e">Array</span><span style="color:#f92672">&lt;</span>T, Ix2<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>        parameter_gradient: Option<span style="color:#f92672">&lt;</span>Array<span style="color:#f92672">&lt;</span>T, Ix2<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Which then also lets us remove the explicit lifetime annotation from Operation as well, since it only existed to relay that information into the OperationData type being used. Therefore the new Operation will become:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Operation</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    input: Option<span style="color:#f92672">&lt;</span>Array<span style="color:#f92672">&lt;</span>T, Ix2<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>    input_gradient: Option<span style="color:#f92672">&lt;</span>Array<span style="color:#f92672">&lt;</span>T, Ix2<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>    output: Option<span style="color:#f92672">&lt;</span>Array<span style="color:#f92672">&lt;</span>T, Ix2<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>    data: <span style="color:#a6e22e">OperationData</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>We also replace the references with boxed trait objects in the new_basic and new_parameter functions, but we don&rsquo;t need to show this here.</p>
<h4 id="layersetup">LayerSetup<a hidden class="anchor" aria-hidden="true" href="#layersetup">#</a></h4>
<p>The LayerSetup trait previously had an explicit lifetime parameter so as to be able to return a Vec of Operation with the correct lifetime. However we wish to remove this lifetime annotation which we now can do since Operation no longer takes one.</p>
<p>The new definition of the LayerSetup trait then becomes:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> LayerSetup<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">layer_setup</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>self,
</span></span><span style="display:flex;"><span>        num_neurons: <span style="color:#66d9ef">usize</span>,
</span></span><span style="display:flex;"><span>        input: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Array</span><span style="color:#f92672">&lt;</span>T, Ix2<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>        seed: <span style="color:#66d9ef">&amp;</span>Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u64</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    ) -&gt; Vec<span style="color:#f92672">&lt;</span>Operation<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h4 id="denselayersetup">DenseLayerSetup<a hidden class="anchor" aria-hidden="true" href="#denselayersetup">#</a></h4>
<p>Previously this took a borrow to a BasicOperation to be used at the end of the layer (mimicking how OperationData::Basic had a borrow to one). As part of this lifetime annotation removal, we wish to hold a boxed instance (which doesn&rsquo;t cause an allocation generally if BasicOperation is a ZST).</p>
<p>The new definition of DenseLayerSetup then is simply:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">DenseLayerSetup</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> BasicOperation<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>);</span></span></code></pre></div>
<h4 id="layer">Layer<a hidden class="anchor" aria-hidden="true" href="#layer">#</a></h4>
<p>Previously the Layer struct held a borrow to the LayerSetup trait object like in the other cases, but we will replace this with a boxed trait object and can then remove the lifetime annotation as it&rsquo;s no longer needed.</p>
<p>The new definition of Layer then becomes:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Layer</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    num_neurons: <span style="color:#66d9ef">usize</span>,
</span></span><span style="display:flex;"><span>    operations: Option<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>Operation<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>    setup: Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> LayerSetup<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>    output: Option<span style="color:#f92672">&lt;</span>Array<span style="color:#f92672">&lt;</span>T, Ix2<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>    seed: Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u64</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h4 id="loss">Loss<a hidden class="anchor" aria-hidden="true" href="#loss">#</a></h4>
<p>Finally, the Loss struct is also storing its vtable/trait object by borrow. We can do the same kind of replacement as elsewhere there too and end up with:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Loss</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    implementation: Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> LossImpl<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>    prediction: Option<span style="color:#f92672">&lt;</span>Array<span style="color:#f92672">&lt;</span>T, Ix2<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>    target: Option<span style="color:#f92672">&lt;</span>Array<span style="color:#f92672">&lt;</span>T, Ix2<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h3>
<p>After changing these types, we then need to go through the compiler errors that we now get as a result of the change from reference to owned box. While we&rsquo;re doing this, we will make it so that all the appropriate types have a &ldquo;new_boxed&rdquo; associated method for convenience.</p>
<p>This means that instead of writing <strong>Box::new(Foo::new())</strong> people can then just write <strong>Foo::new_boxed()</strong> which is a little leaner.</p>
<p>After these changes we can now use the API in a way we expect, for example the following code now compiles where it wouldn&rsquo;t in the previous version:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Network</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    layers: Vec<span style="color:#f92672">&lt;</span>Layer<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[test]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">test_throwaway</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> n: <span style="color:#a6e22e">Network</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f64</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> Network {
</span></span><span style="display:flex;"><span>        layers: <span style="color:#a6e22e">vec</span><span style="color:#f92672">!</span>[Layer::new(
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>            DenseLayerSetup::new_boxed(Sigmoid::new_boxed()),
</span></span><span style="display:flex;"><span>        )],
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, n.layers.len());
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://forgottenmaster.github.io/">Robin Smith</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
