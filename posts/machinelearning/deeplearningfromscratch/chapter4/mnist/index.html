<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Extra - Training on the MNIST | Robin Firth</title>
<meta name="keywords" content="" />
<meta name="description" content="At this point we&rsquo;ve successfully coded a neural network library that should be extensible enough to create various architectures of densely connected layers. We&rsquo;ve also implemented various techniques that can be used to potentially get better results from the network.
The next chapters will be about entirely new network architectures, namely Convolutional Neural Networks (CNNs) and Recurrent Neural Networks (RNNs), but now that we have enough pieces for training a standard feed forward network, I want to try out training on something more substantial and meaningful than just a simple mathematical formula or comparison operation such as we&rsquo;ve seen so far.">
<meta name="author" content="">
<link rel="canonical" href="https://forgottenmaster.github.io/posts/machinelearning/deeplearningfromscratch/chapter4/mnist/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.6f60056d44d3f7eb69a4bc6c332b59960f3a995802bded244750232f33713c49.css" integrity="sha256-b2AFbUTT9&#43;tppLxsMytZlg86mVgCve0kR1AjLzNxPEk=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js" integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://forgottenmaster.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://forgottenmaster.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://forgottenmaster.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://forgottenmaster.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://forgottenmaster.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.96.0" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta property="og:title" content="Extra - Training on the MNIST" />
<meta property="og:description" content="At this point we&rsquo;ve successfully coded a neural network library that should be extensible enough to create various architectures of densely connected layers. We&rsquo;ve also implemented various techniques that can be used to potentially get better results from the network.
The next chapters will be about entirely new network architectures, namely Convolutional Neural Networks (CNNs) and Recurrent Neural Networks (RNNs), but now that we have enough pieces for training a standard feed forward network, I want to try out training on something more substantial and meaningful than just a simple mathematical formula or comparison operation such as we&rsquo;ve seen so far." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://forgottenmaster.github.io/posts/machinelearning/deeplearningfromscratch/chapter4/mnist/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-10T23:38:37&#43;01:00" />
<meta property="article:modified_time" content="2022-05-10T23:38:37&#43;01:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Extra - Training on the MNIST"/>
<meta name="twitter:description" content="At this point we&rsquo;ve successfully coded a neural network library that should be extensible enough to create various architectures of densely connected layers. We&rsquo;ve also implemented various techniques that can be used to potentially get better results from the network.
The next chapters will be about entirely new network architectures, namely Convolutional Neural Networks (CNNs) and Recurrent Neural Networks (RNNs), but now that we have enough pieces for training a standard feed forward network, I want to try out training on something more substantial and meaningful than just a simple mathematical formula or comparison operation such as we&rsquo;ve seen so far."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://forgottenmaster.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Machine Learning",
      "item": "https://forgottenmaster.github.io/posts/machinelearning/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Deep Learning From Scratch",
      "item": "https://forgottenmaster.github.io/posts/machinelearning/deeplearningfromscratch/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "Chapter 4 - Extensions",
      "item": "https://forgottenmaster.github.io/posts/machinelearning/deeplearningfromscratch/chapter4/"
    }, 
    {
      "@type": "ListItem",
      "position":  5 ,
      "name": "Extra - Training on the MNIST",
      "item": "https://forgottenmaster.github.io/posts/machinelearning/deeplearningfromscratch/chapter4/mnist/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Extra - Training on the MNIST",
  "name": "Extra - Training on the MNIST",
  "description": "At this point we\u0026rsquo;ve successfully coded a neural network library that should be extensible enough to create various architectures of densely connected layers. We\u0026rsquo;ve also implemented various techniques that can be used to potentially get better results from the network.\nThe next chapters will be about entirely new network architectures, namely Convolutional Neural Networks (CNNs) and Recurrent Neural Networks (RNNs), but now that we have enough pieces for training a standard feed forward network, I want to try out training on something more substantial and meaningful than just a simple mathematical formula or comparison operation such as we\u0026rsquo;ve seen so far.",
  "keywords": [
    
  ],
  "articleBody": "At this point we’ve successfully coded a neural network library that should be extensible enough to create various architectures of densely connected layers. We’ve also implemented various techniques that can be used to potentially get better results from the network.\nThe next chapters will be about entirely new network architectures, namely Convolutional Neural Networks (CNNs) and Recurrent Neural Networks (RNNs), but now that we have enough pieces for training a standard feed forward network, I want to try out training on something more substantial and meaningful than just a simple mathematical formula or comparison operation such as we’ve seen so far.\nThis post will cover using the library we’ve made to train a feed forward network that can recognize handwritten numbers from small images. Specifically, using the MNIST data set.\nWhat is the MNIST data set? The details of the MNIST data set can be read on the Wikipedia page but basically it’s a curated data set from several earlier image data sets, curated to be ideal for machine learning.\nThe images in the set are all handwritten digits, examples of the images are below for the digits 0-9:\nThe actual files are located here and there are 4 files, grouped into testing and training data. The files beginning with train are the ones corresponding to the training data, and the ones beginning with t10k are the testing ones. Among these two pairs, the ones labelled with images are the actual input image data, and the ones labelled with labels are the correct answers in the same order as the images.\nThe images are each 28x28 pixels, and the labels are simply numbers from 0-9 indicating the target value. However, these files are in a custom binary file format so we will first have to be able to parse them.\nThe IDX file format This is detailed nicely on the website but the IDX file format that the images and labels are in is a nice simple binary format for storing N-dimensional data with varying data types/element sizes.\nThe data format is as follows:\n(0x0000) magic number (4 bytes) (0x0004) size in dimension 0 (4 bytes) (0x0008) size in dimension 1 (4 bytes) (0x000c) size in dimension 1 (4 bytes) ... (0x????) size in dimension N (4 bytes) (0x????) data element 1 (varying) (0x????) data element 2 (varying) ... (0x????) data element N (varying) That is, there’s a fixed size magic number followed by the sizes of the dimensions, and then finally the data follows.\nThe magic number is a 4 byte integer with the first 2 bytes always 0.\nThe third byte encodes the data type of the elements in the data segment which can be:\n 0x08: u8 (1 byte) 0x09: i8 (1 byte) 0x0B: i16 (2 bytes) 0x0C: i32 (4 bytes) 0x0D: f32 (4 bytes) 0x0E: f64 (8 bytes)  The last byte tells us how many dimensions there are in the data (e.g. 1 for vector, 2 for matrix, etc.)\nAll integers are encoded as big endian in the byte stream (most significant bit first).\nAs for coordinates, the index of the last dimension in the data changes the fastest (for example if storing a 2 dimensional matrix then the first row is read, then the second row, and so on).\nIn the following sections in this post we’ll implement a parser in Rust that can take a byte slice and produce a nicely parsed data structure that can then be used by our code to turn it into an ndarray::Array for processing for example.\nData type Starting out with the most basic type which is an enumeration that indicates the type of the data in the file, from the set detailed above. Firstly we’ll need to make some constants (not strictly necessary but always good to have something the compiler can verify, and collect them at the top of the file). These are simply encoded as u8’s:\nconst U8: u8 = 0x08; const I8: u8 = 0x09; const I16: u8 = 0x0B; const I32: u8 = 0x0C; const F32: u8 = 0x0D; const F64: u8 = 0x0E; For the actual data type, we know we’ll have the small well-defined set above and an enumeration type in Rust is perfect to represent this. We’ll need the Clone, Debug, and PartialEq traits for later, so we will make sure to tell the compiler to automatically derive implementations for these:\n#[derive(Clone, Debug, PartialEq)] pub enum DataType {  U8,  I8,  I16,  I32,  F32,  F64, } As far as functionality goes, we will need to be able to do the following two things with DataTypes:\n Ask an instance of DataType how many bytes it takes up, for when we read the data Be able to convert a u8 into a DataType  For now we’ll just assume that the u8 = DataType conversion is infallible and panic if a value is given that can’t be converted. In a more robust library we should use TryFrom instead to allow better error handling. I don’t mind this just terminating the program if the data is malformed.\nFor #1, we simply need to use a match with the value and return the appropriate number of bytes which will either be 1, 2, 4, or 8:\npub fn number_of_bytes(\u0026self) - u8 {  match self {  Self::U8 | Self::I8 = 1,  Self::I16 = 2,  Self::I32 | Self::F32 = 4,  Self::F64 = 8,  } } For #2, we can use a match also - we’ll use the constants we defined for readability. We’ll use the panic! macro with a message if the u8 we’re converting from isn’t a valid data type value:\nimpl Fromu8 for DataType {  fn from(byte: u8) - Self {  match byte {  U8 = Self::U8,  I8 = Self::I8,  I16 = Self::I16,  I32 = Self::I32,  F32 = Self::F32,  F64 = Self::F64,  _ = panic!(\"Invalid byte given to be converted into a data type: {byte}\"),  }  } } Value We now have the ability to determine what the type of the data is, but no way to represent the actual data that has been read.\nFor this we’ll use another enum type called Value which will hold the actual value as a rust primitive type. However, because there are a range of DataType variants, we likewise need to define the same variants here. The definition is as follows (again we need to derive the Debug and PartialEq types):\n#[derive(Debug, PartialEq)] pub enum Value {  U8(u8),  I8(i8),  I16(i16),  I32(i32),  F32(f32),  F64(f64), } The first conversion we require is a conversion from a byte sequence/slice into a Value instance however if we’re just given a slice of bytes, how do we know how many we’re supposed to read and interpret or what data type to interpret as?.\nWe can’t is the short answer, we need another piece of information which is the data type. Conveniently, we’ve just added a way to represent the data type.\nThe conversion then, is not from a byte slice to Value, but from a tuple of byte slice and DataType.\nAgain, we’ll assume an infallible conversion hence implementing From rather than TryFrom, but in a more robust library we’d want to handle failure nicely.\nThe conversion itself will simply match on the data type, then depending on the length of the data type we will want to ensure there’s enough bytes to take, and then take those bytes and construct the appropriate data type from them, assuming a big endian ordering.\nRust has an associated method from_be_bytes for all primitive types, which will take the bytes and construct an instance of the appropriate type with them.\nThe one thing to be aware of is from_be_bytes takes a byte array however we have a byte slice. Helpfully though, there’s a fallible conversion from slice to fixed array, so we can use try_into. However since we ourselves are not handling errors, we’ll just unwrap this. The whole implementation then is as follows:\nimpl From(\u0026[u8], DataType) for Value {  fn from(tuple: (\u0026[u8], DataType)) - Self {  let (data, data_type) = tuple;  match data_type {  DataType::U8 = {  assert!(data.len() = 1);  Value::U8(data[0])  }  DataType::I8 = {  assert!(data.len() = 1);  Value::I8(i8::from_be_bytes(data[0..1].try_into().unwrap()))  }  DataType::I16 = {  assert!(data.len() = 2);  Value::I16(i16::from_be_bytes(data[0..2].try_into().unwrap()))  }  DataType::I32 = {  assert!(data.len() = 4);  Value::I32(i32::from_be_bytes(data[0..4].try_into().unwrap()))  }  DataType::F32 = {  assert!(data.len() = 4);  Value::F32(f32::from_be_bytes(data[0..4].try_into().unwrap()))  }  DataType::F64 = {  assert!(data.len() = 8);  Value::F64(f64::from_be_bytes(data[0..8].try_into().unwrap()))  }  }  } } As far as extracting out the contained value, we actually only end up needing the u8 variant since the MNIST data is only bytes.\nWell therefore only implement for now the conversion into u8, but in a real package, we’d make sure there was a way to access the other variants too. Implementation is simply matching on variant and if it’s U8 then we can pull out the value inside:\nimpl FromValue for u8 {  fn from(value: \u0026Value) - Self {  match value {  Value::U8(value) = *value,  _ = unimplemented!(),  }  } } Magic number The first item in an IDX file is a “magic number” which indicates both the type of the data elements, and the number of dimensions.\nThe data type we have an enumeration for, and the number of dimensions is encoded in a single byte of the magic number, so we use a u8 for storage.\nThe definition then is:\n#[derive(Debug)] pub struct MagicNumber {  data_type: DataType,  num_dimensions: u8, } For conversions, we will need to:\n Convert from a 4 byte array to a MagicNumber Decompose a MagicNumber into its data type and number of dimensions  For #1, we need to implement the Fromtrait for MagicNumber, and the implementation will do the following:\n Check that bytes 0 and 1 are 0 Convert byte at index 2 into a DataType Construct and return the MagicNumber struct  This functionality is coded up as:\nimpl From[u8; 4] for MagicNumber {  fn from(bytes: [u8; 4]) - Self {  assert_eq!(bytes[0], 0);  assert_eq!(bytes[1], 0);  let data_type = bytes[2].into();  let num_dimensions = bytes[3];  Self {  data_type,  num_dimensions,  }  } } Conversion #2 can be implemented also with a From trait, this time From, and we implement it on the type (DataType, u8).\nWe just return our fields, so the implementation is simple enough:\nimpl FromMagicNumber for (DataType, u8) {  fn from(magic_number: MagicNumber) - Self {  (magic_number.data_type, magic_number.num_dimensions)  } } File contents Now we have the ability to parse the magic number containing the data type and number of dimensions, we can go ahead and parse the file contents as a whole. Once we’ve parsed the magic number from the beginning of the buffer, we need to:\n Read the next N groups of 4 bytes. Each one represents an unsigned integer indicating the size of one of the dimensions. After reading the dimension sizes, read the rest of the data into a buffer (as the appropriate Value type).  The structure we’ll be using to store everything in will be called the FileContents struct and will just need to store a Vec of sizes (for the dimensions - a Vec because we don’t know in advance how many dimensions there are), along with a Vec of Value type holding the data linearly.\nThe struct definition looks as follows:\n#[derive(Debug, PartialEq)] pub struct FileContents {  sizes: Vecu32, // vector of dimension sizes  data: VecValue, } We make readonly accessors for these, pretty simple:\nimpl FileContents {  pub fn sizes(\u0026self) - \u0026[u32] {  \u0026self.sizes  }   pub fn data(\u0026self) - \u0026[Value] {  \u0026self.data  } } One thing to note here is we’re returning a reference to a slice not a Vec, to indicate that we’re not transferring ownership and also to leave us open in future for modification (anything that is coerced to a slice can be returned/stored in the struct).\nThe first major task we want is parsing. We have a slice of bytes (u8’s) of arbitrary length and we need to parse this using the IDX protocol. Assuming we’re giving data in the correct format (and in this case for our toy library we don’t care about error handling and should just crash if something is wrong), then we can just use the From trait:\nimpl From[u8] for FileContents {  fn from(bytes: \u0026[u8]) - Self {  // implementation goes here  } } As for the implementation, we need to do the following sequence of actions:\n Parse the first 4 bytes as the magic number. Get the data type and number of dimensions from the magic number. For each dimension, read the next 4 bytes from the slice, giving us the size in that dimension. Read the rest of the data, parsing into the correct data type.  We’ll look at these one at a time.\nFor step #1, we have the MagicNumber type, so we’ll delegate our actual parsing to that type, but first we need to take the first 4 bytes from the slice. We can do this in Rust with a method on slices called split_at which takes an index and returns all elements below that index as one slice, and the rest as a second slice.\nOnce we’ve split the slice, we need to turn that first (now 4 byte long) slice into an array, specifically [u8; 4]. This is because we’ve implemented Fromfor MagicNumber so we need to convert before we can turn it into a MagicNumber. We can do this in Rust with the try_into implementation (which we just unwrap).\nFinally we can use the From implementation to turn it into a MagicNumber instance, which will fail if the slice isn’t right. Overall the code to cover step 1 is:\nlet (magic_number, bytes) = bytes.split_at(4); let magic_number: [u8; 4] = magic_number.try_into().unwrap(); let magic_number: MagicNumber = magic_number.into(); For step #2, we implemented Fromfor (DataType, u8), as in we already implemented a way to decompose the struct into its parts, so we can just do:\nlet (data_type, num_dimensions) = magic_number.into(); Step #3 is to read the sizes of the dimensions. We can do this as a fold actually, we take the iterator that runs from 0 to the number of dimensions and call fold on it, with a preallocated Vec. In the callback function we take the sizes Vec and the remaining bytes slice. This part looks as follows:\nlet (sizes, bytes) = (0..num_dimensions).fold(  (Vec::with_capacity(num_dimensions as usize), bytes),  |(mut sizes, bytes), _| {  // update sizes and bytes and return here  } }; To take off the first 4 bytes, we use the split_at function again, assert that it’s the correct length, then parse it as a u32 before pushing it to the sizes vector.\nThe structure from what we already know then is:\nlet (size, bytes) = bytes.split_at(4); assert!(size.len() == 4); ??? sizes.push(size); (sizes, bytes) In the ??? line, we just need to know how to convert the size (which is a byte slice) into a u32. Rust helpfully provides an associated method for this called from_be_bytes which takes a [u8; 4] that it assumes is in big endian ordering and reinterprets it as a u32. This function only runs on a fixed 4 element array, and we have a slice so we need to use the try_into implementation thusly:\nlet size = u32::from_be_bytes(size.try_into().unwrap()); Now we have a vector of sizes for the dimensions, which is half the battle!. We just need to read the data in now.\nFirstly we need to know how many values we’re reading. We know that the data is basically an N-dimensional array and each instance of a given dimension is the same length, which means that the total number of elements in the vector/matrix/etc. is the product of all the sizes.\nWe can do this in Rust easily with the Iterator API:\nlet number_values: u32 = sizes.iter().cloned().product(); We can then get the number of bytes per value (which tells us how we need to split the slice), from the DataType:\nlet bytes_per_value: u8 = data_type.number_of_bytes(); For parsing the data, we are essentially following the same pattern as we did for parsing the dimension sizes, that is:\n Fold from 0 to number_values For each, we split the byte slice so that we break off bytes_per_value bytes Assert that the split off byte slice is the correct length Parse the bytes as the appropriate DataType, parse using the Fromimplementation of Value Push this into the fold state which is returned  In its entirety this looks as follows:\nlet (data, _) = (0..number_values).fold(  (Vec::with_capacity(number_values as usize), bytes),  |(mut data, bytes), _| {  let (value, bytes) = bytes.split_at(bytes_per_value as usize);  assert!(value.len() == bytes_per_value as usize);  let value: Value = (value, data_type.clone()).into();  data.push(value);  (data, bytes)  }, ); That’s it, we can now construct FileContents from the sizes and data we parsed!\nThere is however another thing we will need to be able to do, we need to be able to index into this data. Not strictly necessary because we can access the flat data slice, but it will let us instead of writing in calling code:\nfile_contents.data()[(image_index * width * height) + (y * width) + x] we want to simply be able to write:\nfile_contents[(image_index, y, x)] In Rust this operation, as with all other operations, is implemented via a trait. In this case, it’s the Index trait which takes a generic parameter indicating the type of key, and requires two items:\n The type of output An index function that takes a key of the key type, and returns a reference to the output type.  We can only index correctly into a 3 dimensional data, since we’re giving a key with 3 parts, so we need to assert the sizes vector is 3.\nWe then assert that each individual index is less than the corresponding dimension’s size.\nIf the provided key passes these assertions then the index into the flat data can be calculated as:\n$$ index(idx1, idx2, idx3) = (idx1 \\times size(2) \\times size(1)) + (idx2 \\times size(1)) + idx3 $$\nAnd finally we can index into the data array to get a reference to the value at that point.\nIn its entirety it looks like follows:\nimpl Index(u32, u32, u32) for FileContents {  type Output = Value;   fn index(\u0026self, idx: (u32, u32, u32)) - \u0026Self::Output {  assert_eq!(self.sizes.len(), 3);  let (idx1, idx2, idx3) = idx;  assert!(self.sizes[0]  idx1);  assert!(self.sizes[1]  idx2);  assert!(self.sizes[2]  idx3);  let idx = (idx1 * self.sizes[2] * self.sizes[1]) + (idx2 * self.sizes[1]) + idx3;  \u0026self.data[idx as usize]  } } Converting FileContents to input array Now we’ve been able to load the IDX files and have FileContents structures for all 4 of them. 2 of them will be 3-dimensional (the images) and 2 of them will be 1-dimensional (the labels).\nWe need to convert these into ndarray::Array types for use with our network, and this first function will be focussed on converting the image data to an Array of f64 elements.\nFirstly we can assign meaning to the dimensions in the FileContents structure. The dimensions for the images are:\n Dimension 0 = the image axis, allows selecting the image we’re referring to Dimension 1 = the y coordinate, allows selecting a row in the image Dimension 2 = the x coordinate, allows selecting an individual element inside a row  So in code we do:\nlet number_images = contents.sizes()[0] as usize; let height = contents.sizes()[1] as usize; let width = contents.sizes()[2] as usize; Next we need to take the data and transform them into a Vecso that we can construct an array from them. We can do this by getting an iterator to the data, then mapping the iterator using a function, then collecting the results into a Vec.\nFor the mapping function, it will take a Value (which we know will be Value::U8), extracts the u8 from inside the enum, and then converts that from a 0-255 integer into a 0.0-1.0 float by dividing by 255.0. The whole procedure looks as follows:\nlet data = contents  .data()  .into_iter()  .map(|value| {  let value: u8 = value.into();  value as f64 / 255.0  })  .collect(); Now we have the Vec, we can create an Array from it with the standard from_shape_vec function we’ve been using. The number of rows is the number of images, and the number of columns will be the image width multiplied by the image height:\nArray::from_shape_vec((number_images, width * height), data).unwrap() Converting FileContents to target array Parsing the 1-dimensional FileContents that contain the labels is both simpler but also more complex. Simpler because there’s only one dimension to worry about, but more complex because the labels are given as integers in the range 0-9, however for a classification network to do a good job, we want to one-hot encode the labels.\nWhat this means is that we need to take the single value, and create 10 columns for it. In those columns, they’ll all be 0, except for the one column at the correct index.\nBelow we can show this mapping:\n 0 = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0] 1 = [0, 1, 0, 0, 0, 0, 0, 0, 0, 0] 2 = [0, 0, 1, 0, 0, 0, 0, 0, 0, 0] 3 = [0, 0, 0, 1, 0, 0, 0, 0, 0, 0] 4 = [0, 0, 0, 0, 1, 0, 0, 0, 0, 0] 5 = [0, 0, 0, 0, 0, 1, 0, 0, 0, 0] 6 = [0, 0, 0, 0, 0, 0, 1, 0, 0, 0] 7 = [0, 0, 0, 0, 0, 0, 0, 1, 0, 0] 8 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 0] 9 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]  What we want is a mapping where each element of the file contents maps to 10 elements in the output vector. We can do this by using the flat_map function instead of a regular map, and returning an iterator that produces 10 elements for each input element.\nIn order to create an iterator we can use the chain function to chain together 10 iterators. Each of the iterators will produce only a single value which will be either a 0 or a 1 indicating whether the input value is the associated value.\nThen we collect into an array again, this time with 10 columns.\nThe whole thing looks like follows:\nlet number_images = contents.sizes()[0] as usize; let data = contents  .data()  .into_iter()  .flat_map(|value| {  let value: u8 = value.into();  let value_0 = std::iter::once((value == 0) as u8 as f64);  let value_1 = std::iter::once((value == 1) as u8 as f64);  let value_2 = std::iter::once((value == 2) as u8 as f64);  let value_3 = std::iter::once((value == 3) as u8 as f64);  let value_4 = std::iter::once((value == 4) as u8 as f64);  let value_5 = std::iter::once((value == 5) as u8 as f64);  let value_6 = std::iter::once((value == 6) as u8 as f64);  let value_7 = std::iter::once((value == 7) as u8 as f64);  let value_8 = std::iter::once((value == 8) as u8 as f64);  let value_9 = std::iter::once((value == 9) as u8 as f64);  value_0  .chain(value_1)  .chain(value_2)  .chain(value_3)  .chain(value_4)  .chain(value_5)  .chain(value_6)  .chain(value_7)  .chain(value_8)  .chain(value_9)  })  .collect(); Array::from_shape_vec((number_images, 10), data).unwrap() Building the network Now we have the data prepared and can build and train the network!\nSince we’ve seen several networks so far, it should be fairly obvious if I just paste the whole setup code:\n// hyperparameters const LEARNING_RATE: f64 = 0.001; const EPOCHS: u32 = 100000; const EVAL_EVERY: u32 = 2; const BATCH_SIZE: usize = 256; const SEED: u64 = 42;  // Prepare Network let mut network = Network::new(  vec![  Layer::new_with_seed(65, DenseLayerSetup::new_boxed(Tanh::new_boxed()), SEED),  Layer::new_with_seed(10, DenseLayerSetup::new_boxed(Linear::new_boxed()), SEED),  ],  Loss::new(SoftmaxCrossEntropy::new_boxed()), ); let mut optimiser = SGD::new(LearningRateFixed::new(LEARNING_RATE)); We’re using a fixed learning rate with standard SGD optimiser. We use SoftmaxCrossEntropy loss because this is a classification problem.\nThis network uses two layers only, one with 65 neurons and an output layer with 10.\nCalculating accuracy In order to determine the accuracy of the network, we need to look at each of the rows of the predictions, alongside the targets for those predictions that we expect, we can use a zip for this. Then we need to filter the zipped iterator of tuples to only include elements where the prediction matches the target. We can then use the count function on the iterator to count the correct predictions:\nlet correct_count = predictions  .rows()  .into_iter()  .zip(targets.rows().into_iter())  .filter(|(prediction, target)| {  // perform check here  })  .count(); We can’t however just do (prediction == target) here, because the targets are guaranteed to be 0 and 1 values (and only have a single 1), but the predictions are more fuzzy than that.\nFrom the predictions, what we actually want to do is take the highest element as the guess. So to get the predicted number, we need to go over the elements and indices of the prediction row and track the index of the maximum element, which is done as so:\nlet mut predicted_max = f64::MIN; let mut predicted_number = 0; prediction.iter().enumerate().for_each(|(idx, value)| {  if *value  predicted_max {  predicted_max = *value;  predicted_number = idx;  } }); Finding the target number is easier, we’re just looking for the index that corresponds to the 1. This can be done with the following code:\nlet target_number = target  .iter()  .enumerate()  .filter(|(_, value)| **value == 1.0)  .map(|(idx, _)| idx)  .next()  .unwrap(); And finally we can check the two for equality.\nThe accuracy then is calculated using the standard percentage calculation of (correct/total) * 100.\nResults After coding all of this up and running it, we can see that it performs incredibly well on the training data, and not bad on the testing data:\nAccuracy (training): 99.61833333333333% Accuracy (testing): 97.59% This is using only a simple feed forward neural network so once we learn about convolutional networks we should be able to achieve even greater accuracy!\n",
  "wordCount" : "4268",
  "inLanguage": "en",
  "datePublished": "2022-05-10T23:38:37+01:00",
  "dateModified": "2022-05-10T23:38:37+01:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://forgottenmaster.github.io/posts/machinelearning/deeplearningfromscratch/chapter4/mnist/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Robin Firth",
    "logo": {
      "@type": "ImageObject",
      "url": "https://forgottenmaster.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://forgottenmaster.github.io/" accesskey="h" title="Robin Firth (Alt + H)">Robin Firth</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://forgottenmaster.github.io/resume/" title="Résumé">
                    <span>Résumé</span>
                </a>
            </li>
            <li>
                <a href="https://forgottenmaster.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://forgottenmaster.github.io/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://forgottenmaster.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/machinelearning/">Machine Learning</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/machinelearning/deeplearningfromscratch/">Deep Learning From Scratch</a>&nbsp;»&nbsp;<a href="https://forgottenmaster.github.io/posts/machinelearning/deeplearningfromscratch/chapter4/">Chapter 4 - Extensions</a></div>
    <h1 class="post-title">
      Extra - Training on the MNIST
    </h1>
    <div class="post-meta"><span title='2022-05-10 23:38:37 +0100 BST'>May 10, 2022</span>&nbsp;·&nbsp;21 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#what-is-the-mnist-data-set" aria-label="What is the MNIST data set?">What is the MNIST data set?</a></li>
                <li>
                    <a href="#the-idx-file-format" aria-label="The IDX file format">The IDX file format</a></li>
                <li>
                    <a href="#data-type" aria-label="Data type">Data type</a></li>
                <li>
                    <a href="#value" aria-label="Value">Value</a></li>
                <li>
                    <a href="#magic-number" aria-label="Magic number">Magic number</a></li>
                <li>
                    <a href="#file-contents" aria-label="File contents">File contents</a></li>
                <li>
                    <a href="#converting-filecontents-to-input-array" aria-label="Converting FileContents to input array">Converting FileContents to input array</a></li>
                <li>
                    <a href="#converting-filecontents-to-target-array" aria-label="Converting FileContents to target array">Converting FileContents to target array</a></li>
                <li>
                    <a href="#building-the-network" aria-label="Building the network">Building the network</a></li>
                <li>
                    <a href="#calculating-accuracy" aria-label="Calculating accuracy">Calculating accuracy</a></li>
                <li>
                    <a href="#results" aria-label="Results">Results</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>At this point we&rsquo;ve successfully coded a neural network library that should be extensible enough to create various architectures of <strong>densely connected</strong> layers. We&rsquo;ve also implemented various techniques that can be used to potentially get better results from the network.</p>
<p>The next chapters will be about entirely new network architectures, namely <strong>Convolutional Neural Networks</strong> (CNNs) and <strong>Recurrent Neural Networks</strong> (RNNs), but now that we have enough pieces for training a standard feed forward network, I want to try out training on something more substantial and meaningful than just a simple mathematical formula or comparison operation such as we&rsquo;ve seen so far.</p>
<p>This post will cover using the library we&rsquo;ve made to train a feed forward network that can recognize handwritten numbers from small images. Specifically, using the MNIST data set.</p>
<h3 id="what-is-the-mnist-data-set">What is the MNIST data set?<a hidden class="anchor" aria-hidden="true" href="#what-is-the-mnist-data-set">#</a></h3>
<p>The details of the MNIST data set can be read on the <a href="https://en.wikipedia.org/wiki/MNIST_database">Wikipedia page</a> but basically it&rsquo;s a curated data set from several earlier image data sets, curated to be ideal for machine learning.</p>
<p>The images in the set are all handwritten digits, examples of the images are below for the digits 0-9:</p>
<p><img loading="lazy" src="mnist_samples.PNG" alt="MNIST samples"  />
</p>
<p>The actual files are located <a href="http://yann.lecun.com/exdb/mnist/">here</a> and there are 4 files, grouped into testing and training data. The files beginning with <strong>train</strong> are the ones corresponding to the training data, and the ones beginning with <strong>t10k</strong> are the testing ones. Among these two pairs, the ones labelled with <strong>images</strong> are the actual input image data, and the ones labelled with <strong>labels</strong> are the correct answers in the same order as the images.</p>
<p>The images are each 28x28 pixels, and the labels are simply numbers from 0-9 indicating the target value. However, these files are in a custom binary file format so we will first have to be able to parse them.</p>
<h3 id="the-idx-file-format">The IDX file format<a hidden class="anchor" aria-hidden="true" href="#the-idx-file-format">#</a></h3>
<p>This is detailed nicely on the website but the IDX file format that the images and labels are in is a nice simple binary format for storing N-dimensional data with varying data types/element sizes.</p>
<p>The data format is as follows:</p>
<pre tabindex="0"><code>(0x0000) magic number (4 bytes)
(0x0004) size in dimension 0 (4 bytes)
(0x0008) size in dimension 1 (4 bytes)
(0x000c) size in dimension 1 (4 bytes)
...
(0x????) size in dimension N (4 bytes)
(0x????) data element 1 (varying)
(0x????) data element 2 (varying)
...
(0x????) data element N (varying)
</code></pre><p>That is, there&rsquo;s a fixed size magic number followed by the sizes of the dimensions, and then finally the data follows.</p>
<p>The magic number is a <strong>4 byte</strong> integer with the first 2 bytes always <strong>0</strong>.</p>
<p>The third byte encodes the data type of the elements in the data segment which can be:</p>
<ul>
<li><strong>0x08</strong>: u8  (1 byte)</li>
<li><strong>0x09</strong>: i8  (1 byte)</li>
<li><strong>0x0B</strong>: i16 (2 bytes)</li>
<li><strong>0x0C</strong>: i32 (4 bytes)</li>
<li><strong>0x0D</strong>: f32 (4 bytes)</li>
<li><strong>0x0E</strong>: f64 (8 bytes)</li>
</ul>
<p>The last byte tells us how many dimensions there are in the data (e.g. 1 for vector, 2 for matrix, etc.)</p>
<p>All integers are encoded as big endian in the byte stream (most significant bit first).</p>
<p>As for coordinates, the index of the last dimension in the data changes the fastest (for example if storing a 2 dimensional matrix then the first row is read, then the second row, and so on).</p>
<p>In the following sections in this post we&rsquo;ll implement a parser in Rust that can take a <strong>byte slice</strong> and produce a nicely parsed data structure that can then be used by our code to turn it into an ndarray::Array for processing for example.</p>
<h3 id="data-type">Data type<a hidden class="anchor" aria-hidden="true" href="#data-type">#</a></h3>
<p>Starting out with the most basic type which is an enumeration that indicates the <strong>type</strong> of the data in the file, from the set detailed above. Firstly we&rsquo;ll need to make some constants (not strictly necessary but always good to have something the compiler can verify, and collect them at the top of the file). These are simply encoded as u8&rsquo;s:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> U8: <span style="color:#66d9ef">u8</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x08</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> I8: <span style="color:#66d9ef">u8</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x09</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> I16: <span style="color:#66d9ef">u8</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0B</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> I32: <span style="color:#66d9ef">u8</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0C</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> F32: <span style="color:#66d9ef">u8</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0D</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> F64: <span style="color:#66d9ef">u8</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0E</span>;</span></span></code></pre></div>
<p>For the actual data type, we know we&rsquo;ll have the small well-defined set above and an enumeration type in Rust is perfect to represent this. We&rsquo;ll need the <strong>Clone, Debug, and PartialEq</strong> traits for later, so we will make sure to tell the compiler to automatically derive implementations for these:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Clone, Debug, PartialEq)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">DataType</span> {
</span></span><span style="display:flex;"><span>    U8,
</span></span><span style="display:flex;"><span>    I8,
</span></span><span style="display:flex;"><span>    I16,
</span></span><span style="display:flex;"><span>    I32,
</span></span><span style="display:flex;"><span>    F32,
</span></span><span style="display:flex;"><span>    F64,
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>As far as functionality goes, we will need to be able to do the following two things with DataTypes:</p>
<ol>
<li>Ask an instance of DataType how many bytes it takes up, for when we read the data</li>
<li>Be able to convert a u8 into a DataType</li>
</ol>
<p>For now we&rsquo;ll just assume that the u8 =&gt; DataType conversion is infallible and panic if a value is given that can&rsquo;t be converted. In a more robust library we should use TryFrom instead to allow better error handling. I don&rsquo;t mind this just terminating the program if the data is malformed.</p>
<p>For #1, we simply need to use a match with the value and return the appropriate number of bytes which will either be 1, 2, 4, or 8:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">number_of_bytes</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">u8</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> self {
</span></span><span style="display:flex;"><span>        Self::U8 <span style="color:#f92672">|</span> Self::I8 <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>        Self::I16 <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">2</span>,
</span></span><span style="display:flex;"><span>        Self::I32 <span style="color:#f92672">|</span> Self::F32 <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">4</span>,
</span></span><span style="display:flex;"><span>        Self::F64 <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">8</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>For #2, we can use a match also - we&rsquo;ll use the constants we defined for readability. We&rsquo;ll use the panic! macro with a message if the u8 we&rsquo;re converting from isn&rsquo;t a valid data type value:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> From<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> DataType {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">from</span>(byte: <span style="color:#66d9ef">u8</span>) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> byte {
</span></span><span style="display:flex;"><span>            U8 <span style="color:#f92672">=&gt;</span> Self::U8,
</span></span><span style="display:flex;"><span>            I8 <span style="color:#f92672">=&gt;</span> Self::I8,
</span></span><span style="display:flex;"><span>            I16 <span style="color:#f92672">=&gt;</span> Self::I16,
</span></span><span style="display:flex;"><span>            I32 <span style="color:#f92672">=&gt;</span> Self::I32,
</span></span><span style="display:flex;"><span>            F32 <span style="color:#f92672">=&gt;</span> Self::F32,
</span></span><span style="display:flex;"><span>            F64 <span style="color:#f92672">=&gt;</span> Self::F64,
</span></span><span style="display:flex;"><span>            _ <span style="color:#f92672">=&gt;</span> panic!(<span style="color:#e6db74">&#34;Invalid byte given to be converted into a data type: {byte}&#34;</span>),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="value">Value<a hidden class="anchor" aria-hidden="true" href="#value">#</a></h3>
<p>We now have the ability to determine what the type of the data is, but no way to represent the <strong>actual</strong> data that has been read.</p>
<p>For this we&rsquo;ll use another enum type called Value which will hold the actual value as a rust primitive type. However, because there are a range of DataType variants, we likewise need to define the same variants here. The definition is as follows (again we need to derive the Debug and PartialEq types):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug, PartialEq)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Value</span> {
</span></span><span style="display:flex;"><span>    U8(<span style="color:#66d9ef">u8</span>),
</span></span><span style="display:flex;"><span>    I8(<span style="color:#66d9ef">i8</span>),
</span></span><span style="display:flex;"><span>    I16(<span style="color:#66d9ef">i16</span>),
</span></span><span style="display:flex;"><span>    I32(<span style="color:#66d9ef">i32</span>),
</span></span><span style="display:flex;"><span>    F32(<span style="color:#66d9ef">f32</span>),
</span></span><span style="display:flex;"><span>    F64(<span style="color:#66d9ef">f64</span>),
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>The first conversion we require is a conversion from a byte sequence/slice into a Value instance however if we&rsquo;re just given a slice of bytes, how do we know how many we&rsquo;re supposed to read and interpret or what data type to interpret as?.</p>
<p>We can&rsquo;t is the short answer, we need another piece of information which is the <strong>data type</strong>. Conveniently, we&rsquo;ve just added a way to represent the data type.</p>
<p>The conversion then, is not from a byte slice to Value, but from a <strong>tuple</strong> of byte slice <strong>and</strong> DataType.</p>
<p>Again, we&rsquo;ll assume an infallible conversion hence implementing From rather than TryFrom, but in a more robust library we&rsquo;d want to handle failure nicely.</p>
<p>The conversion itself will simply match on the data type, then depending on the length of the data type we will want to ensure there&rsquo;s enough bytes to take, and then take those bytes and construct the appropriate data type from them, assuming a big endian ordering.</p>
<p>Rust has an associated method <strong>from_be_bytes</strong> for all primitive types, which will take the bytes and construct an instance of the appropriate type with them.</p>
<p>The one thing to be aware of is from_be_bytes takes a byte <strong>array</strong> however we have a byte <strong>slice</strong>. Helpfully though, there&rsquo;s a fallible conversion from slice to fixed array, so we can use try_into. However since we ourselves are not handling errors, we&rsquo;ll just unwrap this. The whole implementation then is as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> From<span style="color:#f92672">&lt;</span>(<span style="color:#f92672">&amp;</span>[<span style="color:#66d9ef">u8</span>], DataType)<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> Value {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">from</span>(tuple: (<span style="color:#f92672">&amp;</span>[<span style="color:#66d9ef">u8</span>], DataType)) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> (data, data_type) <span style="color:#f92672">=</span> tuple;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> data_type {
</span></span><span style="display:flex;"><span>            DataType::U8 <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                assert!(data.len() <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>                Value::U8(data[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            DataType::I8 <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                assert!(data.len() <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>                Value::I8(<span style="color:#66d9ef">i8</span>::from_be_bytes(data[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">1</span>].try_into().unwrap()))
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            DataType::I16 <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                assert!(data.len() <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>                Value::I16(<span style="color:#66d9ef">i16</span>::from_be_bytes(data[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">2</span>].try_into().unwrap()))
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            DataType::I32 <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                assert!(data.len() <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>                Value::I32(<span style="color:#66d9ef">i32</span>::from_be_bytes(data[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">4</span>].try_into().unwrap()))
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            DataType::F32 <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                assert!(data.len() <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>                Value::F32(<span style="color:#66d9ef">f32</span>::from_be_bytes(data[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">4</span>].try_into().unwrap()))
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            DataType::F64 <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                assert!(data.len() <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span>                Value::F64(<span style="color:#66d9ef">f64</span>::from_be_bytes(data[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">8</span>].try_into().unwrap()))
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>As far as extracting out the contained value, we actually only end up needing the u8 variant since the MNIST data is only bytes.</p>
<p>Well therefore only implement for now the conversion into u8, but in a real package, we&rsquo;d make sure there was a way to access the other variants too. Implementation is simply matching on variant and if it&rsquo;s U8 then we can pull out the value inside:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> From<span style="color:#f92672">&lt;&amp;</span>Value<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">u8</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">from</span>(value: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Value</span>) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> value {
</span></span><span style="display:flex;"><span>            Value::U8(value) <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">*</span>value,
</span></span><span style="display:flex;"><span>            _ <span style="color:#f92672">=&gt;</span> unimplemented!(),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="magic-number">Magic number<a hidden class="anchor" aria-hidden="true" href="#magic-number">#</a></h3>
<p>The first item in an IDX file is a &ldquo;magic number&rdquo; which indicates both the type of the data elements, and the number of dimensions.</p>
<p>The data type we have an enumeration for, and the number of dimensions is encoded in a single byte of the magic number, so we use a u8 for storage.</p>
<p>The definition then is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MagicNumber</span> {
</span></span><span style="display:flex;"><span>    data_type: <span style="color:#a6e22e">DataType</span>,
</span></span><span style="display:flex;"><span>    num_dimensions: <span style="color:#66d9ef">u8</span>,
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>For conversions, we will need to:</p>
<ol>
<li>Convert from a 4 byte array to a MagicNumber</li>
<li>Decompose a MagicNumber into its data type and number of dimensions</li>
</ol>
<p>For #1, we need to implement the From&lt;[u8; 4]&gt; trait for MagicNumber, and the implementation will do the following:</p>
<ol>
<li>Check that bytes 0 and 1 are 0</li>
<li>Convert byte at index 2 into a DataType</li>
<li>Construct and return the MagicNumber struct</li>
</ol>
<p>This functionality is coded up as:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> From<span style="color:#f92672">&lt;</span>[<span style="color:#66d9ef">u8</span>; <span style="color:#ae81ff">4</span>]<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> MagicNumber {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">from</span>(bytes: [<span style="color:#66d9ef">u8</span>; <span style="color:#ae81ff">4</span>]) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>        assert_eq!(bytes[<span style="color:#ae81ff">0</span>], <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        assert_eq!(bytes[<span style="color:#ae81ff">1</span>], <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> data_type <span style="color:#f92672">=</span> bytes[<span style="color:#ae81ff">2</span>].into();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> num_dimensions <span style="color:#f92672">=</span> bytes[<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>        Self {
</span></span><span style="display:flex;"><span>            data_type,
</span></span><span style="display:flex;"><span>            num_dimensions,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Conversion #2 can be implemented also with a From trait, this time From<!-- raw HTML omitted -->, and we implement it on the type (DataType, u8).</p>
<p>We just return our fields, so the implementation is simple enough:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> From<span style="color:#f92672">&lt;</span>MagicNumber<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> (DataType, <span style="color:#66d9ef">u8</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">from</span>(magic_number: <span style="color:#a6e22e">MagicNumber</span>) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>        (magic_number.data_type, magic_number.num_dimensions)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="file-contents">File contents<a hidden class="anchor" aria-hidden="true" href="#file-contents">#</a></h3>
<p>Now we have the ability to parse the magic number containing the data type and number of dimensions, we can go ahead and parse the file contents as a whole. Once we&rsquo;ve parsed the magic number from the beginning of the buffer, we need to:</p>
<ol>
<li>Read the next N groups of 4 bytes. Each one represents an unsigned integer indicating the size of one of the dimensions.</li>
<li>After reading the dimension sizes, read the rest of the data into a buffer (as the appropriate Value type).</li>
</ol>
<p>The structure we&rsquo;ll be using to store everything in will be called the FileContents struct and will just need to store a Vec of sizes (for the dimensions - a Vec because we don&rsquo;t know in advance how many dimensions there are), along with a Vec of Value type holding the data linearly.</p>
<p>The struct definition looks as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug, PartialEq)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">FileContents</span> {
</span></span><span style="display:flex;"><span>    sizes: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u32</span><span style="color:#f92672">&gt;</span>, <span style="color:#75715e">// vector of dimension sizes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    data: Vec<span style="color:#f92672">&lt;</span>Value<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>We make readonly accessors for these, pretty simple:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> FileContents {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">sizes</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">&amp;</span>[<span style="color:#66d9ef">u32</span>] {
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>self.sizes
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">data</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">&amp;</span>[Value] {
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>self.data
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>One thing to note here is we&rsquo;re returning a reference to a <strong>slice</strong> not a Vec, to indicate that we&rsquo;re not transferring ownership and also to leave us open in future for modification (anything that is coerced to a slice can be returned/stored in the struct).</p>
<p>The first major task we want is parsing. We have a slice of bytes (u8&rsquo;s) of arbitrary length and we need to parse this using the IDX protocol. Assuming we&rsquo;re giving data in the correct format (and in this case for our toy library we don&rsquo;t care about error handling and should just crash if something is wrong), then we can just use the <strong>From&lt;&amp;[u8]&gt;</strong> trait:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> From<span style="color:#f92672">&lt;&amp;</span>[<span style="color:#66d9ef">u8</span>]<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> FileContents {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">from</span>(bytes: <span style="color:#66d9ef">&amp;</span>[<span style="color:#66d9ef">u8</span>]) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// implementation goes here
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>As for the implementation, we need to do the following sequence of actions:</p>
<ol>
<li>Parse the first <strong>4</strong> bytes as the magic number.</li>
<li>Get the data type and number of dimensions from the magic number.</li>
<li>For each dimension, read the next 4 bytes from the slice, giving us the size in that dimension.</li>
<li>Read the rest of the data, parsing into the correct data type.</li>
</ol>
<p>We&rsquo;ll look at these one at a time.</p>
<p>For step #1, we have the MagicNumber type, so we&rsquo;ll delegate our actual parsing to that type, but first we need to take the first 4 bytes from the slice. We can do this in Rust with a method on slices called <strong>split_at</strong> which takes an index and returns all elements <strong>below</strong> that index as one slice, and the rest as a second slice.</p>
<p>Once we&rsquo;ve split the slice, we need to turn that first (now 4 byte long) slice into an array, specifically <strong>[u8; 4]</strong>. This is because we&rsquo;ve implemented From&lt;[u8; 4]&gt; for MagicNumber so we need to convert before we can turn it into a MagicNumber. We can do this in Rust with the try_into implementation (which we just unwrap).</p>
<p>Finally we can use the From implementation to turn it into a MagicNumber instance, which will fail if the slice isn&rsquo;t right. Overall the code to cover step 1 is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> (magic_number, bytes) <span style="color:#f92672">=</span> bytes.split_at(<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> magic_number: [<span style="color:#66d9ef">u8</span>; <span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> magic_number.try_into().unwrap();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> magic_number: <span style="color:#a6e22e">MagicNumber</span> <span style="color:#f92672">=</span> magic_number.into();</span></span></code></pre></div>
<p>For step #2, we implemented From<!-- raw HTML omitted --> for (DataType, u8), as in we already implemented a way to decompose the struct into its parts, so we can just do:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> (data_type, num_dimensions) <span style="color:#f92672">=</span> magic_number.into();</span></span></code></pre></div>
<p>Step #3 is to read the sizes of the dimensions. We can do this as a fold actually, we take the iterator that runs from 0 to the number of dimensions and call fold on it, with a preallocated Vec. In the callback function we take the sizes Vec and the remaining bytes slice. This part looks as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> (sizes, bytes) <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>num_dimensions).fold(
</span></span><span style="display:flex;"><span>    (Vec::with_capacity(num_dimensions <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>), bytes),
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span>(<span style="color:#66d9ef">mut</span> sizes, bytes), _<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// update sizes and bytes and return here
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p>To take off the first 4 bytes, we use the split_at function again, assert that it&rsquo;s the correct length, then parse it as a <strong>u32</strong> before pushing it to the sizes vector.</p>
<p>The structure from what we already know then is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> (size, bytes) <span style="color:#f92672">=</span> bytes.split_at(<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>assert!(size.len() <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span><span style="color:#f92672">???</span>
</span></span><span style="display:flex;"><span>sizes.push(size);
</span></span><span style="display:flex;"><span>(sizes, bytes)</span></span></code></pre></div>
<p>In the ??? line, we just need to know how to convert the size (which is a byte slice) into a u32. Rust helpfully provides an associated method for this called <strong>from_be_bytes</strong> which takes a [u8; 4] that it assumes is in <strong>big endian</strong> ordering and reinterprets it as a u32. This function only runs on a fixed 4 element array, and we have a slice so we need to use the try_into implementation thusly:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> size <span style="color:#f92672">=</span> <span style="color:#66d9ef">u32</span>::from_be_bytes(size.try_into().unwrap());</span></span></code></pre></div>
<p>Now we have a vector of sizes for the dimensions, which is half the battle!. We just need to read the data in now.</p>
<p>Firstly we need to know how many values we&rsquo;re reading. We know that the data is basically an N-dimensional array and each instance of a given dimension is the same length, which means that the total number of elements in the vector/matrix/etc. is the product of all the sizes.</p>
<p>We can do this in Rust easily with the Iterator API:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> number_values: <span style="color:#66d9ef">u32</span> <span style="color:#f92672">=</span> sizes.iter().cloned().product();</span></span></code></pre></div>
<p>We can then get the number of bytes per value (which tells us how we need to split the slice), from the DataType:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> bytes_per_value: <span style="color:#66d9ef">u8</span> <span style="color:#f92672">=</span> data_type.number_of_bytes();</span></span></code></pre></div>
<p>For parsing the data, we are essentially following the same pattern as we did for parsing the dimension sizes, that is:</p>
<ol>
<li>Fold from 0 to number_values</li>
<li>For each, we split the byte slice so that we break off bytes_per_value bytes</li>
<li>Assert that the split off byte slice is the correct length</li>
<li>Parse the bytes as the appropriate DataType, parse using the From&lt;(&amp;[u8], DataType)&gt; implementation of Value</li>
<li>Push this into the fold state which is returned</li>
</ol>
<p>In its entirety this looks as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> (data, _) <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>number_values).fold(
</span></span><span style="display:flex;"><span>    (Vec::with_capacity(number_values <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>), bytes),
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span>(<span style="color:#66d9ef">mut</span> data, bytes), _<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> (value, bytes) <span style="color:#f92672">=</span> bytes.split_at(bytes_per_value <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>);
</span></span><span style="display:flex;"><span>        assert!(value.len() <span style="color:#f92672">==</span> bytes_per_value <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> value: <span style="color:#a6e22e">Value</span> <span style="color:#f92672">=</span> (value, data_type.clone()).into();
</span></span><span style="display:flex;"><span>        data.push(value);
</span></span><span style="display:flex;"><span>        (data, bytes)
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>);</span></span></code></pre></div>
<p>That&rsquo;s it, we can now construct FileContents from the sizes and data we parsed!</p>
<p>There is however another thing we will need to be able to do, we need to be able to index into this data. Not strictly necessary because we can access the flat data slice, but it will let us instead of writing in calling code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>file_contents.data()[(image_index <span style="color:#f92672">*</span> width <span style="color:#f92672">*</span> height) <span style="color:#f92672">+</span> (y <span style="color:#f92672">*</span> width) <span style="color:#f92672">+</span> x]</span></span></code></pre></div>
<p>we want to simply be able to write:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>file_contents[(image_index, y, x)]</span></span></code></pre></div>
<p>In Rust this operation, as with all other operations, is implemented via a trait. In this case, it&rsquo;s the <strong>Index</strong> trait which takes a generic parameter indicating the type of key, and requires two items:</p>
<ol>
<li>The type of output</li>
<li>An index function that takes a key of the key type, and returns a <strong>reference</strong> to the output type.</li>
</ol>
<p>We can only index correctly into a 3 dimensional data, since we&rsquo;re giving a key with 3 parts, so we need to assert the sizes vector is 3.</p>
<p>We then assert that each individual index is less than the corresponding dimension&rsquo;s size.</p>
<p>If the provided key passes these assertions then the index into the flat data can be calculated as:</p>
<p>$$ index(idx1, idx2, idx3) = (idx1 \times size(2) \times size(1)) + (idx2 \times size(1)) + idx3 $$</p>
<p>And finally we can index into the data array to get a reference to the value at that point.</p>
<p>In its entirety it looks like follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Index<span style="color:#f92672">&lt;</span>(<span style="color:#66d9ef">u32</span>, <span style="color:#66d9ef">u32</span>, <span style="color:#66d9ef">u32</span>)<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> FileContents {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> Value;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">index</span>(<span style="color:#f92672">&amp;</span>self, idx: (<span style="color:#66d9ef">u32</span>, <span style="color:#66d9ef">u32</span>, <span style="color:#66d9ef">u32</span>)) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Self</span>::Output {
</span></span><span style="display:flex;"><span>        assert_eq!(self.sizes.len(), <span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> (idx1, idx2, idx3) <span style="color:#f92672">=</span> idx;
</span></span><span style="display:flex;"><span>        assert!(self.sizes[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&gt;</span> idx1);
</span></span><span style="display:flex;"><span>        assert!(self.sizes[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;</span> idx2);
</span></span><span style="display:flex;"><span>        assert!(self.sizes[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">&gt;</span> idx3);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> idx <span style="color:#f92672">=</span> (idx1 <span style="color:#f92672">*</span> self.sizes[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">*</span> self.sizes[<span style="color:#ae81ff">1</span>]) <span style="color:#f92672">+</span> (idx2 <span style="color:#f92672">*</span> self.sizes[<span style="color:#ae81ff">1</span>]) <span style="color:#f92672">+</span> idx3;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>self.data[idx <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="converting-filecontents-to-input-array">Converting FileContents to input array<a hidden class="anchor" aria-hidden="true" href="#converting-filecontents-to-input-array">#</a></h3>
<p>Now we&rsquo;ve been able to load the IDX files and have FileContents structures for all 4 of them. 2 of them will be 3-dimensional (the images) and 2 of them will be 1-dimensional (the labels).</p>
<p>We need to convert these into ndarray::Array types for use with our network, and this first function will be focussed on converting the <strong>image</strong> data to an Array of f64 elements.</p>
<p>Firstly we can assign meaning to the dimensions in the FileContents structure. The dimensions for the images are:</p>
<ul>
<li><strong>Dimension 0</strong> =&gt; the image axis, allows selecting the image we&rsquo;re referring to</li>
<li><strong>Dimension 1</strong> =&gt; the y coordinate, allows selecting a row in the image</li>
<li><strong>Dimension 2</strong> =&gt; the x coordinate, allows selecting an individual element inside a row</li>
</ul>
<p>So in code we do:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> number_images <span style="color:#f92672">=</span> contents.sizes()[<span style="color:#ae81ff">0</span>] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> height <span style="color:#f92672">=</span> contents.sizes()[<span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> width <span style="color:#f92672">=</span> contents.sizes()[<span style="color:#ae81ff">2</span>] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>;</span></span></code></pre></div>
<p>Next we need to take the data and transform them into a Vec<!-- raw HTML omitted --> so that we can construct an array from them. We can do this by getting an iterator to the data, then mapping the iterator using a function, then collecting the results into a Vec.</p>
<p>For the mapping function, it will take a Value (which we know will be Value::U8), extracts the u8 from inside the enum, and then converts that from a 0-255 integer into a 0.0-1.0 float by dividing by 255.0. The whole procedure looks as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> data <span style="color:#f92672">=</span> contents
</span></span><span style="display:flex;"><span>    .data()
</span></span><span style="display:flex;"><span>    .into_iter()
</span></span><span style="display:flex;"><span>    .map(<span style="color:#f92672">|</span>value<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> value: <span style="color:#66d9ef">u8</span> <span style="color:#f92672">=</span> value.into();
</span></span><span style="display:flex;"><span>        value <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f64</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">255.0</span>
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    .collect();</span></span></code></pre></div>
<p>Now we have the Vec, we can create an Array from it with the standard from_shape_vec function we&rsquo;ve been using. The number of rows is the number of images, and the number of columns will be the image width multiplied by the image height:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>Array::from_shape_vec((number_images, width <span style="color:#f92672">*</span> height), data).unwrap()</span></span></code></pre></div>
<h3 id="converting-filecontents-to-target-array">Converting FileContents to target array<a hidden class="anchor" aria-hidden="true" href="#converting-filecontents-to-target-array">#</a></h3>
<p>Parsing the 1-dimensional FileContents that contain the labels is both simpler but also more complex. Simpler because there&rsquo;s only one dimension to worry about, but more complex because the labels are given as integers in the range 0-9, however for a classification network to do a good job, we want to <strong>one-hot encode</strong> the labels.</p>
<p>What this means is that we need to take the single value, and create 10 columns for it. In those columns, they&rsquo;ll all be 0, except for the one column at the correct index.</p>
<p>Below we can show this mapping:</p>
<ul>
<li>0 =&gt; [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]</li>
<li>1 =&gt; [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]</li>
<li>2 =&gt; [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]</li>
<li>3 =&gt; [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]</li>
<li>4 =&gt; [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]</li>
<li>5 =&gt; [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]</li>
<li>6 =&gt; [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]</li>
<li>7 =&gt; [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]</li>
<li>8 =&gt; [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]</li>
<li>9 =&gt; [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]</li>
</ul>
<p>What we want is a mapping where each element of the file contents maps to <strong>10</strong> elements in the output vector. We can do this by using the flat_map function instead of a regular map, and returning an iterator that produces 10 elements for each input element.</p>
<p>In order to create an iterator we can use the <strong>chain</strong> function to chain together 10 iterators. Each of the iterators will produce only a single value which will be either a 0 or a 1 indicating whether the input value is the associated value.</p>
<p>Then we collect into an array again, this time with 10 columns.</p>
<p>The whole thing looks like follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> number_images <span style="color:#f92672">=</span> contents.sizes()[<span style="color:#ae81ff">0</span>] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> data <span style="color:#f92672">=</span> contents
</span></span><span style="display:flex;"><span>    .data()
</span></span><span style="display:flex;"><span>    .into_iter()
</span></span><span style="display:flex;"><span>    .flat_map(<span style="color:#f92672">|</span>value<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> value: <span style="color:#66d9ef">u8</span> <span style="color:#f92672">=</span> value.into();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> value_0 <span style="color:#f92672">=</span> std::iter::once((value <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u8</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f64</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> value_1 <span style="color:#f92672">=</span> std::iter::once((value <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u8</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f64</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> value_2 <span style="color:#f92672">=</span> std::iter::once((value <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u8</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f64</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> value_3 <span style="color:#f92672">=</span> std::iter::once((value <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>) <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u8</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f64</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> value_4 <span style="color:#f92672">=</span> std::iter::once((value <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>) <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u8</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f64</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> value_5 <span style="color:#f92672">=</span> std::iter::once((value <span style="color:#f92672">==</span> <span style="color:#ae81ff">5</span>) <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u8</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f64</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> value_6 <span style="color:#f92672">=</span> std::iter::once((value <span style="color:#f92672">==</span> <span style="color:#ae81ff">6</span>) <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u8</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f64</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> value_7 <span style="color:#f92672">=</span> std::iter::once((value <span style="color:#f92672">==</span> <span style="color:#ae81ff">7</span>) <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u8</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f64</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> value_8 <span style="color:#f92672">=</span> std::iter::once((value <span style="color:#f92672">==</span> <span style="color:#ae81ff">8</span>) <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u8</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f64</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> value_9 <span style="color:#f92672">=</span> std::iter::once((value <span style="color:#f92672">==</span> <span style="color:#ae81ff">9</span>) <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u8</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f64</span>);
</span></span><span style="display:flex;"><span>        value_0
</span></span><span style="display:flex;"><span>            .chain(value_1)
</span></span><span style="display:flex;"><span>            .chain(value_2)
</span></span><span style="display:flex;"><span>            .chain(value_3)
</span></span><span style="display:flex;"><span>            .chain(value_4)
</span></span><span style="display:flex;"><span>            .chain(value_5)
</span></span><span style="display:flex;"><span>            .chain(value_6)
</span></span><span style="display:flex;"><span>            .chain(value_7)
</span></span><span style="display:flex;"><span>            .chain(value_8)
</span></span><span style="display:flex;"><span>            .chain(value_9)
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    .collect();
</span></span><span style="display:flex;"><span>Array::from_shape_vec((number_images, <span style="color:#ae81ff">10</span>), data).unwrap()</span></span></code></pre></div>
<h3 id="building-the-network">Building the network<a hidden class="anchor" aria-hidden="true" href="#building-the-network">#</a></h3>
<p>Now we have the data prepared and can build and train the network!</p>
<p>Since we&rsquo;ve seen several networks so far, it should be fairly obvious if I just paste the whole setup code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// hyperparameters
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> LEARNING_RATE: <span style="color:#66d9ef">f64</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.001</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> EPOCHS: <span style="color:#66d9ef">u32</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">100000</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> EVAL_EVERY: <span style="color:#66d9ef">u32</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> BATCH_SIZE: <span style="color:#66d9ef">usize</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">256</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> SEED: <span style="color:#66d9ef">u64</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Prepare Network
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> network <span style="color:#f92672">=</span> Network::new(
</span></span><span style="display:flex;"><span>    vec![
</span></span><span style="display:flex;"><span>        Layer::new_with_seed(<span style="color:#ae81ff">65</span>, DenseLayerSetup::new_boxed(Tanh::new_boxed()), SEED),
</span></span><span style="display:flex;"><span>        Layer::new_with_seed(<span style="color:#ae81ff">10</span>, DenseLayerSetup::new_boxed(Linear::new_boxed()), SEED),
</span></span><span style="display:flex;"><span>    ],
</span></span><span style="display:flex;"><span>    Loss::new(SoftmaxCrossEntropy::new_boxed()),
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> optimiser <span style="color:#f92672">=</span> SGD::new(LearningRateFixed::new(LEARNING_RATE));</span></span></code></pre></div>
<p>We&rsquo;re using a fixed learning rate with standard SGD optimiser. We use SoftmaxCrossEntropy loss because this is a classification problem.</p>
<p>This network uses two layers only, one with 65 neurons and an output layer with 10.</p>
<h3 id="calculating-accuracy">Calculating accuracy<a hidden class="anchor" aria-hidden="true" href="#calculating-accuracy">#</a></h3>
<p>In order to determine the accuracy of the network, we need to look at each of the rows of the predictions, alongside the targets for those predictions that we expect, we can use a zip for this. Then we need to filter the zipped iterator of tuples to only include elements where the prediction matches the target. We can then use the <strong>count</strong> function on the iterator to count the correct predictions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> correct_count <span style="color:#f92672">=</span> predictions
</span></span><span style="display:flex;"><span>        .rows()
</span></span><span style="display:flex;"><span>        .into_iter()
</span></span><span style="display:flex;"><span>        .zip(targets.rows().into_iter())
</span></span><span style="display:flex;"><span>        .filter(<span style="color:#f92672">|</span>(prediction, target)<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// perform check here
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        })
</span></span><span style="display:flex;"><span>        .count();</span></span></code></pre></div>
<p>We can&rsquo;t however just do (prediction == target) here, because the targets are guaranteed to be 0 and 1 values (and only have a single 1), but the predictions are more fuzzy than that.</p>
<p>From the predictions, what we actually want to do is take the <strong>highest</strong> element as the guess. So to get the predicted number, we need to go over the elements and indices of the prediction row and track the index of the maximum element, which is done as so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> predicted_max <span style="color:#f92672">=</span> <span style="color:#66d9ef">f64</span>::MIN;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> predicted_number <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>prediction.iter().enumerate().for_each(<span style="color:#f92672">|</span>(idx, value)<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">*</span>value <span style="color:#f92672">&gt;</span> predicted_max {
</span></span><span style="display:flex;"><span>        predicted_max <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>value;
</span></span><span style="display:flex;"><span>        predicted_number <span style="color:#f92672">=</span> idx;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>});</span></span></code></pre></div>
<p>Finding the target number is easier, we&rsquo;re just looking for the index that corresponds to the 1. This can be done with the following code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> target_number <span style="color:#f92672">=</span> target
</span></span><span style="display:flex;"><span>    .iter()
</span></span><span style="display:flex;"><span>    .enumerate()
</span></span><span style="display:flex;"><span>    .filter(<span style="color:#f92672">|</span>(_, value)<span style="color:#f92672">|</span> <span style="color:#f92672">**</span>value <span style="color:#f92672">==</span> <span style="color:#ae81ff">1.0</span>)
</span></span><span style="display:flex;"><span>    .map(<span style="color:#f92672">|</span>(idx, _)<span style="color:#f92672">|</span> idx)
</span></span><span style="display:flex;"><span>    .next()
</span></span><span style="display:flex;"><span>    .unwrap();</span></span></code></pre></div>
<p>And finally we can check the two for equality.</p>
<p>The accuracy then is calculated using the standard percentage calculation of (correct/total) * 100.</p>
<h3 id="results">Results<a hidden class="anchor" aria-hidden="true" href="#results">#</a></h3>
<p>After coding all of this up and running it, we can see that it performs incredibly well on the training data, and not bad on the testing data:</p>
<pre tabindex="0"><code>Accuracy (training): 99.61833333333333%
Accuracy (testing): 97.59%
</code></pre><p>This is using only a simple feed forward neural network so once we learn about convolutional networks we should be able to achieve even greater accuracy!</p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://forgottenmaster.github.io/">Robin Firth</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
